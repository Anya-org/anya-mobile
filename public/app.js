var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __commonJS = (cb, mod3) => function __require2() {
  return mod3 || (0, cb[__getOwnPropNames(cb)[0]])((mod3 = { exports: {} }).exports, mod3), mod3.exports;
};
var __export = (target, all2) => {
  for (var name12 in all2)
    __defProp(target, name12, { get: all2[name12], enumerable: true });
};
var __copyProps = (to, from17, except, desc) => {
  if (from17 && typeof from17 === "object" || typeof from17 === "function") {
    for (let key of __getOwnPropNames(from17))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from17[key], enumerable: !(desc = __getOwnPropDesc(from17, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod3, isNodeMode, target) => (target = mod3 != null ? __create(__getProtoOf(mod3)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod3 || !mod3.__esModule ? __defProp(target, "default", { value: mod3, enumerable: true }) : target,
  mod3
));

// node_modules/@noble/hashes/crypto.js
var require_crypto = __commonJS({
  "node_modules/@noble/hashes/crypto.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.crypto = void 0;
    exports2.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  }
});

// node_modules/@noble/hashes/utils.js
var require_utils = __commonJS({
  "node_modules/@noble/hashes/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.wrapXOFConstructorWithOpts = exports2.wrapConstructorWithOpts = exports2.wrapConstructor = exports2.Hash = exports2.nextTick = exports2.swap32IfBE = exports2.byteSwapIfBE = exports2.swap8IfBE = exports2.isLE = void 0;
    exports2.isBytes = isBytes6;
    exports2.anumber = anumber3;
    exports2.abytes = abytes5;
    exports2.ahash = ahash2;
    exports2.aexists = aexists2;
    exports2.aoutput = aoutput2;
    exports2.u8 = u82;
    exports2.u32 = u323;
    exports2.clean = clean3;
    exports2.createView = createView3;
    exports2.rotr = rotr2;
    exports2.rotl = rotl2;
    exports2.byteSwap = byteSwap2;
    exports2.byteSwap32 = byteSwap322;
    exports2.bytesToHex = bytesToHex4;
    exports2.hexToBytes = hexToBytes5;
    exports2.asyncLoop = asyncLoop2;
    exports2.utf8ToBytes = utf8ToBytes3;
    exports2.bytesToUtf8 = bytesToUtf82;
    exports2.toBytes = toBytes5;
    exports2.kdfInputToBytes = kdfInputToBytes2;
    exports2.concatBytes = concatBytes5;
    exports2.checkOpts = checkOpts2;
    exports2.createHasher = createHasher2;
    exports2.createOptHasher = createOptHasher;
    exports2.createXOFer = createXOFer2;
    exports2.randomBytes = randomBytes3;
    var crypto_1 = require_crypto();
    function isBytes6(a) {
      return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
    }
    function anumber3(n) {
      if (!Number.isSafeInteger(n) || n < 0)
        throw new Error("positive integer expected, got " + n);
    }
    function abytes5(b, ...lengths) {
      if (!isBytes6(b))
        throw new Error("Uint8Array expected");
      if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
    }
    function ahash2(h) {
      if (typeof h !== "function" || typeof h.create !== "function")
        throw new Error("Hash should be wrapped by utils.createHasher");
      anumber3(h.outputLen);
      anumber3(h.blockLen);
    }
    function aexists2(instance, checkFinished = true) {
      if (instance.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance.finished)
        throw new Error("Hash#digest() has already been called");
    }
    function aoutput2(out, instance) {
      abytes5(out);
      const min = instance.outputLen;
      if (out.length < min) {
        throw new Error("digestInto() expects output buffer of length at least " + min);
      }
    }
    function u82(arr) {
      return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    }
    function u323(arr) {
      return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    }
    function clean3(...arrays) {
      for (let i = 0; i < arrays.length; i++) {
        arrays[i].fill(0);
      }
    }
    function createView3(arr) {
      return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    }
    function rotr2(word, shift) {
      return word << 32 - shift | word >>> shift;
    }
    function rotl2(word, shift) {
      return word << shift | word >>> 32 - shift >>> 0;
    }
    exports2.isLE = (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
    function byteSwap2(word) {
      return word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
    }
    exports2.swap8IfBE = exports2.isLE ? (n) => n : (n) => byteSwap2(n);
    exports2.byteSwapIfBE = exports2.swap8IfBE;
    function byteSwap322(arr) {
      for (let i = 0; i < arr.length; i++) {
        arr[i] = byteSwap2(arr[i]);
      }
      return arr;
    }
    exports2.swap32IfBE = exports2.isLE ? (u) => u : byteSwap322;
    var hasHexBuiltin3 = /* @__PURE__ */ (() => (
      // @ts-ignore
      typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
    ))();
    var hexes3 = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex4(bytes) {
      abytes5(bytes);
      if (hasHexBuiltin3)
        return bytes.toHex();
      let hex = "";
      for (let i = 0; i < bytes.length; i++) {
        hex += hexes3[bytes[i]];
      }
      return hex;
    }
    var asciis3 = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
    function asciiToBase163(ch) {
      if (ch >= asciis3._0 && ch <= asciis3._9)
        return ch - asciis3._0;
      if (ch >= asciis3.A && ch <= asciis3.F)
        return ch - (asciis3.A - 10);
      if (ch >= asciis3.a && ch <= asciis3.f)
        return ch - (asciis3.a - 10);
      return;
    }
    function hexToBytes5(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      if (hasHexBuiltin3)
        return Uint8Array.fromHex(hex);
      const hl = hex.length;
      const al = hl / 2;
      if (hl % 2)
        throw new Error("hex string expected, got unpadded hex of length " + hl);
      const array = new Uint8Array(al);
      for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase163(hex.charCodeAt(hi));
        const n2 = asciiToBase163(hex.charCodeAt(hi + 1));
        if (n1 === void 0 || n2 === void 0) {
          const char = hex[hi] + hex[hi + 1];
          throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2;
      }
      return array;
    }
    var nextTick2 = async () => {
    };
    exports2.nextTick = nextTick2;
    async function asyncLoop2(iters, tick, cb) {
      let ts = Date.now();
      for (let i = 0; i < iters; i++) {
        cb(i);
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
          continue;
        await (0, exports2.nextTick)();
        ts += diff;
      }
    }
    function utf8ToBytes3(str) {
      if (typeof str !== "string")
        throw new Error("string expected");
      return new Uint8Array(new TextEncoder().encode(str));
    }
    function bytesToUtf82(bytes) {
      return new TextDecoder().decode(bytes);
    }
    function toBytes5(data) {
      if (typeof data === "string")
        data = utf8ToBytes3(data);
      abytes5(data);
      return data;
    }
    function kdfInputToBytes2(data) {
      if (typeof data === "string")
        data = utf8ToBytes3(data);
      abytes5(data);
      return data;
    }
    function concatBytes5(...arrays) {
      let sum = 0;
      for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        abytes5(a);
        sum += a.length;
      }
      const res = new Uint8Array(sum);
      for (let i = 0, pad = 0; i < arrays.length; i++) {
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
      }
      return res;
    }
    function checkOpts2(defaults, opts) {
      if (opts !== void 0 && {}.toString.call(opts) !== "[object Object]")
        throw new Error("options should be object or undefined");
      const merged = Object.assign(defaults, opts);
      return merged;
    }
    var Hash2 = class {
    };
    exports2.Hash = Hash2;
    function createHasher2(hashCons) {
      const hashC = (msg) => hashCons().update(toBytes5(msg)).digest();
      const tmp = hashCons();
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = () => hashCons();
      return hashC;
    }
    function createOptHasher(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes5(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    function createXOFer2(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes5(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports2.wrapConstructor = createHasher2;
    exports2.wrapConstructorWithOpts = createOptHasher;
    exports2.wrapXOFConstructorWithOpts = createXOFer2;
    function randomBytes3(bytesLength = 32) {
      if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
      }
      if (crypto_1.crypto && typeof crypto_1.crypto.randomBytes === "function") {
        return Uint8Array.from(crypto_1.crypto.randomBytes(bytesLength));
      }
      throw new Error("crypto.getRandomValues must be defined");
    }
  }
});

// node_modules/@noble/hashes/_md.js
var require_md = __commonJS({
  "node_modules/@noble/hashes/_md.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SHA512_IV = exports2.SHA384_IV = exports2.SHA224_IV = exports2.SHA256_IV = exports2.HashMD = void 0;
    exports2.setBigUint64 = setBigUint643;
    exports2.Chi = Chi2;
    exports2.Maj = Maj2;
    var utils_ts_1 = require_utils();
    function setBigUint643(view, byteOffset, value, isLE3) {
      if (typeof view.setBigUint64 === "function")
        return view.setBigUint64(byteOffset, value, isLE3);
      const _32n2 = BigInt(32);
      const _u32_max = BigInt(4294967295);
      const wh = Number(value >> _32n2 & _u32_max);
      const wl = Number(value & _u32_max);
      const h = isLE3 ? 4 : 0;
      const l = isLE3 ? 0 : 4;
      view.setUint32(byteOffset + h, wh, isLE3);
      view.setUint32(byteOffset + l, wl, isLE3);
    }
    function Chi2(a, b, c) {
      return a & b ^ ~a & c;
    }
    function Maj2(a, b, c) {
      return a & b ^ a & c ^ b & c;
    }
    var HashMD2 = class extends utils_ts_1.Hash {
      constructor(blockLen, outputLen, padOffset, isLE3) {
        super();
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE3;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_ts_1.createView)(this.buffer);
      }
      update(data) {
        (0, utils_ts_1.aexists)(this);
        data = (0, utils_ts_1.toBytes)(data);
        (0, utils_ts_1.abytes)(data);
        const { view, buffer: buffer2, blockLen } = this;
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          if (take === blockLen) {
            const dataView2 = (0, utils_ts_1.createView)(data);
            for (; blockLen <= len - pos; pos += blockLen)
              this.process(dataView2, pos);
            continue;
          }
          buffer2.set(data.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(view, 0);
            this.pos = 0;
          }
        }
        this.length += data.length;
        this.roundClean();
        return this;
      }
      digestInto(out) {
        (0, utils_ts_1.aexists)(this);
        (0, utils_ts_1.aoutput)(out, this);
        this.finished = true;
        const { buffer: buffer2, view, blockLen, isLE: isLE3 } = this;
        let { pos } = this;
        buffer2[pos++] = 128;
        (0, utils_ts_1.clean)(this.buffer.subarray(pos));
        if (this.padOffset > blockLen - pos) {
          this.process(view, 0);
          pos = 0;
        }
        for (let i = pos; i < blockLen; i++)
          buffer2[i] = 0;
        setBigUint643(view, blockLen - 8, BigInt(this.length * 8), isLE3);
        this.process(view, 0);
        const oview = (0, utils_ts_1.createView)(out);
        const len = this.outputLen;
        if (len % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
          throw new Error("_sha2: outputLen bigger than state");
        for (let i = 0; i < outLen; i++)
          oview.setUint32(4 * i, state[i], isLE3);
      }
      digest() {
        const { buffer: buffer2, outputLen } = this;
        this.digestInto(buffer2);
        const res = buffer2.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer: buffer2, length: length11, finished, destroyed, pos } = this;
        to.destroyed = destroyed;
        to.finished = finished;
        to.length = length11;
        to.pos = pos;
        if (length11 % blockLen)
          to.buffer.set(buffer2);
        return to;
      }
      clone() {
        return this._cloneInto();
      }
    };
    exports2.HashMD = HashMD2;
    exports2.SHA256_IV = Uint32Array.from([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    exports2.SHA224_IV = Uint32Array.from([
      3238371032,
      914150663,
      812702999,
      4144912697,
      4290775857,
      1750603025,
      1694076839,
      3204075428
    ]);
    exports2.SHA384_IV = Uint32Array.from([
      3418070365,
      3238371032,
      1654270250,
      914150663,
      2438529370,
      812702999,
      355462360,
      4144912697,
      1731405415,
      4290775857,
      2394180231,
      1750603025,
      3675008525,
      1694076839,
      1203062813,
      3204075428
    ]);
    exports2.SHA512_IV = Uint32Array.from([
      1779033703,
      4089235720,
      3144134277,
      2227873595,
      1013904242,
      4271175723,
      2773480762,
      1595750129,
      1359893119,
      2917565137,
      2600822924,
      725511199,
      528734635,
      4215389547,
      1541459225,
      327033209
    ]);
  }
});

// node_modules/@noble/hashes/_u64.js
var require_u64 = __commonJS({
  "node_modules/@noble/hashes/_u64.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.toBig = exports2.shrSL = exports2.shrSH = exports2.rotrSL = exports2.rotrSH = exports2.rotrBL = exports2.rotrBH = exports2.rotr32L = exports2.rotr32H = exports2.rotlSL = exports2.rotlSH = exports2.rotlBL = exports2.rotlBH = exports2.add5L = exports2.add5H = exports2.add4L = exports2.add4H = exports2.add3L = exports2.add3H = void 0;
    exports2.add = add2;
    exports2.fromBig = fromBig2;
    exports2.split = split2;
    var U32_MASK642 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
    var _32n2 = /* @__PURE__ */ BigInt(32);
    function fromBig2(n, le = false) {
      if (le)
        return { h: Number(n & U32_MASK642), l: Number(n >> _32n2 & U32_MASK642) };
      return { h: Number(n >> _32n2 & U32_MASK642) | 0, l: Number(n & U32_MASK642) | 0 };
    }
    function split2(lst, le = false) {
      const len = lst.length;
      let Ah = new Uint32Array(len);
      let Al = new Uint32Array(len);
      for (let i = 0; i < len; i++) {
        const { h, l } = fromBig2(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
      }
      return [Ah, Al];
    }
    var toBig = (h, l) => BigInt(h >>> 0) << _32n2 | BigInt(l >>> 0);
    exports2.toBig = toBig;
    var shrSH2 = (h, _l, s) => h >>> s;
    exports2.shrSH = shrSH2;
    var shrSL2 = (h, l, s) => h << 32 - s | l >>> s;
    exports2.shrSL = shrSL2;
    var rotrSH2 = (h, l, s) => h >>> s | l << 32 - s;
    exports2.rotrSH = rotrSH2;
    var rotrSL2 = (h, l, s) => h << 32 - s | l >>> s;
    exports2.rotrSL = rotrSL2;
    var rotrBH2 = (h, l, s) => h << 64 - s | l >>> s - 32;
    exports2.rotrBH = rotrBH2;
    var rotrBL2 = (h, l, s) => h >>> s - 32 | l << 64 - s;
    exports2.rotrBL = rotrBL2;
    var rotr32H = (_h, l) => l;
    exports2.rotr32H = rotr32H;
    var rotr32L = (h, _l) => h;
    exports2.rotr32L = rotr32L;
    var rotlSH2 = (h, l, s) => h << s | l >>> 32 - s;
    exports2.rotlSH = rotlSH2;
    var rotlSL2 = (h, l, s) => l << s | h >>> 32 - s;
    exports2.rotlSL = rotlSL2;
    var rotlBH2 = (h, l, s) => l << s - 32 | h >>> 64 - s;
    exports2.rotlBH = rotlBH2;
    var rotlBL2 = (h, l, s) => h << s - 32 | l >>> 64 - s;
    exports2.rotlBL = rotlBL2;
    function add2(Ah, Al, Bh, Bl2) {
      const l = (Al >>> 0) + (Bl2 >>> 0);
      return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
    }
    var add3L2 = (Al, Bl2, Cl) => (Al >>> 0) + (Bl2 >>> 0) + (Cl >>> 0);
    exports2.add3L = add3L2;
    var add3H2 = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
    exports2.add3H = add3H2;
    var add4L2 = (Al, Bl2, Cl, Dl) => (Al >>> 0) + (Bl2 >>> 0) + (Cl >>> 0) + (Dl >>> 0);
    exports2.add4L = add4L2;
    var add4H2 = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
    exports2.add4H = add4H2;
    var add5L2 = (Al, Bl2, Cl, Dl, El) => (Al >>> 0) + (Bl2 >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
    exports2.add5L = add5L2;
    var add5H2 = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
    exports2.add5H = add5H2;
    var u64 = {
      fromBig: fromBig2,
      split: split2,
      toBig,
      shrSH: shrSH2,
      shrSL: shrSL2,
      rotrSH: rotrSH2,
      rotrSL: rotrSL2,
      rotrBH: rotrBH2,
      rotrBL: rotrBL2,
      rotr32H,
      rotr32L,
      rotlSH: rotlSH2,
      rotlSL: rotlSL2,
      rotlBH: rotlBH2,
      rotlBL: rotlBL2,
      add: add2,
      add3L: add3L2,
      add3H: add3H2,
      add4L: add4L2,
      add4H: add4H2,
      add5H: add5H2,
      add5L: add5L2
    };
    exports2.default = u64;
  }
});

// node_modules/@noble/hashes/sha2.js
var require_sha2 = __commonJS({
  "node_modules/@noble/hashes/sha2.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sha512_224 = exports2.sha512_256 = exports2.sha384 = exports2.sha512 = exports2.sha224 = exports2.sha256 = exports2.SHA512_256 = exports2.SHA512_224 = exports2.SHA384 = exports2.SHA512 = exports2.SHA224 = exports2.SHA256 = void 0;
    var _md_ts_1 = require_md();
    var u64 = require_u64();
    var utils_ts_1 = require_utils();
    var SHA256_K2 = /* @__PURE__ */ Uint32Array.from([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    var SHA256_W2 = /* @__PURE__ */ new Uint32Array(64);
    var SHA2562 = class extends _md_ts_1.HashMD {
      constructor(outputLen = 32) {
        super(64, outputLen, 8, false);
        this.A = _md_ts_1.SHA256_IV[0] | 0;
        this.B = _md_ts_1.SHA256_IV[1] | 0;
        this.C = _md_ts_1.SHA256_IV[2] | 0;
        this.D = _md_ts_1.SHA256_IV[3] | 0;
        this.E = _md_ts_1.SHA256_IV[4] | 0;
        this.F = _md_ts_1.SHA256_IV[5] | 0;
        this.G = _md_ts_1.SHA256_IV[6] | 0;
        this.H = _md_ts_1.SHA256_IV[7] | 0;
      }
      get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
      }
      // prettier-ignore
      set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
          SHA256_W2[i] = view.getUint32(offset, false);
        for (let i = 16; i < 64; i++) {
          const W15 = SHA256_W2[i - 15];
          const W2 = SHA256_W2[i - 2];
          const s0 = (0, utils_ts_1.rotr)(W15, 7) ^ (0, utils_ts_1.rotr)(W15, 18) ^ W15 >>> 3;
          const s1 = (0, utils_ts_1.rotr)(W2, 17) ^ (0, utils_ts_1.rotr)(W2, 19) ^ W2 >>> 10;
          SHA256_W2[i] = s1 + SHA256_W2[i - 7] + s0 + SHA256_W2[i - 16] | 0;
        }
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
          const sigma1 = (0, utils_ts_1.rotr)(E, 6) ^ (0, utils_ts_1.rotr)(E, 11) ^ (0, utils_ts_1.rotr)(E, 25);
          const T1 = H + sigma1 + (0, _md_ts_1.Chi)(E, F, G) + SHA256_K2[i] + SHA256_W2[i] | 0;
          const sigma0 = (0, utils_ts_1.rotr)(A, 2) ^ (0, utils_ts_1.rotr)(A, 13) ^ (0, utils_ts_1.rotr)(A, 22);
          const T2 = sigma0 + (0, _md_ts_1.Maj)(A, B, C) | 0;
          H = G;
          G = F;
          F = E;
          E = D + T1 | 0;
          D = C;
          C = B;
          B = A;
          A = T1 + T2 | 0;
        }
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        F = F + this.F | 0;
        G = G + this.G | 0;
        H = H + this.H | 0;
        this.set(A, B, C, D, E, F, G, H);
      }
      roundClean() {
        (0, utils_ts_1.clean)(SHA256_W2);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        (0, utils_ts_1.clean)(this.buffer);
      }
    };
    exports2.SHA256 = SHA2562;
    var SHA224 = class extends SHA2562 {
      constructor() {
        super(28);
        this.A = _md_ts_1.SHA224_IV[0] | 0;
        this.B = _md_ts_1.SHA224_IV[1] | 0;
        this.C = _md_ts_1.SHA224_IV[2] | 0;
        this.D = _md_ts_1.SHA224_IV[3] | 0;
        this.E = _md_ts_1.SHA224_IV[4] | 0;
        this.F = _md_ts_1.SHA224_IV[5] | 0;
        this.G = _md_ts_1.SHA224_IV[6] | 0;
        this.H = _md_ts_1.SHA224_IV[7] | 0;
      }
    };
    exports2.SHA224 = SHA224;
    var K5122 = /* @__PURE__ */ (() => u64.split([
      "0x428a2f98d728ae22",
      "0x7137449123ef65cd",
      "0xb5c0fbcfec4d3b2f",
      "0xe9b5dba58189dbbc",
      "0x3956c25bf348b538",
      "0x59f111f1b605d019",
      "0x923f82a4af194f9b",
      "0xab1c5ed5da6d8118",
      "0xd807aa98a3030242",
      "0x12835b0145706fbe",
      "0x243185be4ee4b28c",
      "0x550c7dc3d5ffb4e2",
      "0x72be5d74f27b896f",
      "0x80deb1fe3b1696b1",
      "0x9bdc06a725c71235",
      "0xc19bf174cf692694",
      "0xe49b69c19ef14ad2",
      "0xefbe4786384f25e3",
      "0x0fc19dc68b8cd5b5",
      "0x240ca1cc77ac9c65",
      "0x2de92c6f592b0275",
      "0x4a7484aa6ea6e483",
      "0x5cb0a9dcbd41fbd4",
      "0x76f988da831153b5",
      "0x983e5152ee66dfab",
      "0xa831c66d2db43210",
      "0xb00327c898fb213f",
      "0xbf597fc7beef0ee4",
      "0xc6e00bf33da88fc2",
      "0xd5a79147930aa725",
      "0x06ca6351e003826f",
      "0x142929670a0e6e70",
      "0x27b70a8546d22ffc",
      "0x2e1b21385c26c926",
      "0x4d2c6dfc5ac42aed",
      "0x53380d139d95b3df",
      "0x650a73548baf63de",
      "0x766a0abb3c77b2a8",
      "0x81c2c92e47edaee6",
      "0x92722c851482353b",
      "0xa2bfe8a14cf10364",
      "0xa81a664bbc423001",
      "0xc24b8b70d0f89791",
      "0xc76c51a30654be30",
      "0xd192e819d6ef5218",
      "0xd69906245565a910",
      "0xf40e35855771202a",
      "0x106aa07032bbd1b8",
      "0x19a4c116b8d2d0c8",
      "0x1e376c085141ab53",
      "0x2748774cdf8eeb99",
      "0x34b0bcb5e19b48a8",
      "0x391c0cb3c5c95a63",
      "0x4ed8aa4ae3418acb",
      "0x5b9cca4f7763e373",
      "0x682e6ff3d6b2b8a3",
      "0x748f82ee5defb2fc",
      "0x78a5636f43172f60",
      "0x84c87814a1f0ab72",
      "0x8cc702081a6439ec",
      "0x90befffa23631e28",
      "0xa4506cebde82bde9",
      "0xbef9a3f7b2c67915",
      "0xc67178f2e372532b",
      "0xca273eceea26619c",
      "0xd186b8c721c0c207",
      "0xeada7dd6cde0eb1e",
      "0xf57d4f7fee6ed178",
      "0x06f067aa72176fba",
      "0x0a637dc5a2c898a6",
      "0x113f9804bef90dae",
      "0x1b710b35131c471b",
      "0x28db77f523047d84",
      "0x32caab7b40c72493",
      "0x3c9ebe0a15c9bebc",
      "0x431d67c49c100d4c",
      "0x4cc5d4becb3e42b6",
      "0x597f299cfc657e2a",
      "0x5fcb6fab3ad6faec",
      "0x6c44198c4a475817"
    ].map((n) => BigInt(n))))();
    var SHA512_Kh2 = /* @__PURE__ */ (() => K5122[0])();
    var SHA512_Kl2 = /* @__PURE__ */ (() => K5122[1])();
    var SHA512_W_H2 = /* @__PURE__ */ new Uint32Array(80);
    var SHA512_W_L2 = /* @__PURE__ */ new Uint32Array(80);
    var SHA5122 = class extends _md_ts_1.HashMD {
      constructor(outputLen = 64) {
        super(128, outputLen, 16, false);
        this.Ah = _md_ts_1.SHA512_IV[0] | 0;
        this.Al = _md_ts_1.SHA512_IV[1] | 0;
        this.Bh = _md_ts_1.SHA512_IV[2] | 0;
        this.Bl = _md_ts_1.SHA512_IV[3] | 0;
        this.Ch = _md_ts_1.SHA512_IV[4] | 0;
        this.Cl = _md_ts_1.SHA512_IV[5] | 0;
        this.Dh = _md_ts_1.SHA512_IV[6] | 0;
        this.Dl = _md_ts_1.SHA512_IV[7] | 0;
        this.Eh = _md_ts_1.SHA512_IV[8] | 0;
        this.El = _md_ts_1.SHA512_IV[9] | 0;
        this.Fh = _md_ts_1.SHA512_IV[10] | 0;
        this.Fl = _md_ts_1.SHA512_IV[11] | 0;
        this.Gh = _md_ts_1.SHA512_IV[12] | 0;
        this.Gl = _md_ts_1.SHA512_IV[13] | 0;
        this.Hh = _md_ts_1.SHA512_IV[14] | 0;
        this.Hl = _md_ts_1.SHA512_IV[15] | 0;
      }
      // prettier-ignore
      get() {
        const { Ah, Al, Bh, Bl: Bl2, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        return [Ah, Al, Bh, Bl2, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
      }
      // prettier-ignore
      set(Ah, Al, Bh, Bl2, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
        this.Ah = Ah | 0;
        this.Al = Al | 0;
        this.Bh = Bh | 0;
        this.Bl = Bl2 | 0;
        this.Ch = Ch | 0;
        this.Cl = Cl | 0;
        this.Dh = Dh | 0;
        this.Dl = Dl | 0;
        this.Eh = Eh | 0;
        this.El = El | 0;
        this.Fh = Fh | 0;
        this.Fl = Fl | 0;
        this.Gh = Gh | 0;
        this.Gl = Gl | 0;
        this.Hh = Hh | 0;
        this.Hl = Hl | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4) {
          SHA512_W_H2[i] = view.getUint32(offset);
          SHA512_W_L2[i] = view.getUint32(offset += 4);
        }
        for (let i = 16; i < 80; i++) {
          const W15h = SHA512_W_H2[i - 15] | 0;
          const W15l = SHA512_W_L2[i - 15] | 0;
          const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);
          const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);
          const W2h = SHA512_W_H2[i - 2] | 0;
          const W2l = SHA512_W_L2[i - 2] | 0;
          const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);
          const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);
          const SUMl = u64.add4L(s0l, s1l, SHA512_W_L2[i - 7], SHA512_W_L2[i - 16]);
          const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H2[i - 7], SHA512_W_H2[i - 16]);
          SHA512_W_H2[i] = SUMh | 0;
          SHA512_W_L2[i] = SUMl | 0;
        }
        let { Ah, Al, Bh, Bl: Bl2, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        for (let i = 0; i < 80; i++) {
          const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);
          const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);
          const CHIh = Eh & Fh ^ ~Eh & Gh;
          const CHIl = El & Fl ^ ~El & Gl;
          const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl2[i], SHA512_W_L2[i]);
          const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh2[i], SHA512_W_H2[i]);
          const T1l = T1ll | 0;
          const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);
          const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);
          const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
          const MAJl = Al & Bl2 ^ Al & Cl ^ Bl2 & Cl;
          Hh = Gh | 0;
          Hl = Gl | 0;
          Gh = Fh | 0;
          Gl = Fl | 0;
          Fh = Eh | 0;
          Fl = El | 0;
          ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
          Dh = Ch | 0;
          Dl = Cl | 0;
          Ch = Bh | 0;
          Cl = Bl2 | 0;
          Bh = Ah | 0;
          Bl2 = Al | 0;
          const All = u64.add3L(T1l, sigma0l, MAJl);
          Ah = u64.add3H(All, T1h, sigma0h, MAJh);
          Al = All | 0;
        }
        ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
        ({ h: Bh, l: Bl2 } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl2 | 0));
        ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
        ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
        ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
        ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
        ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
        ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
        this.set(Ah, Al, Bh, Bl2, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
      }
      roundClean() {
        (0, utils_ts_1.clean)(SHA512_W_H2, SHA512_W_L2);
      }
      destroy() {
        (0, utils_ts_1.clean)(this.buffer);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      }
    };
    exports2.SHA512 = SHA5122;
    var SHA384 = class extends SHA5122 {
      constructor() {
        super(48);
        this.Ah = _md_ts_1.SHA384_IV[0] | 0;
        this.Al = _md_ts_1.SHA384_IV[1] | 0;
        this.Bh = _md_ts_1.SHA384_IV[2] | 0;
        this.Bl = _md_ts_1.SHA384_IV[3] | 0;
        this.Ch = _md_ts_1.SHA384_IV[4] | 0;
        this.Cl = _md_ts_1.SHA384_IV[5] | 0;
        this.Dh = _md_ts_1.SHA384_IV[6] | 0;
        this.Dl = _md_ts_1.SHA384_IV[7] | 0;
        this.Eh = _md_ts_1.SHA384_IV[8] | 0;
        this.El = _md_ts_1.SHA384_IV[9] | 0;
        this.Fh = _md_ts_1.SHA384_IV[10] | 0;
        this.Fl = _md_ts_1.SHA384_IV[11] | 0;
        this.Gh = _md_ts_1.SHA384_IV[12] | 0;
        this.Gl = _md_ts_1.SHA384_IV[13] | 0;
        this.Hh = _md_ts_1.SHA384_IV[14] | 0;
        this.Hl = _md_ts_1.SHA384_IV[15] | 0;
      }
    };
    exports2.SHA384 = SHA384;
    var T224_IV = /* @__PURE__ */ Uint32Array.from([
      2352822216,
      424955298,
      1944164710,
      2312950998,
      502970286,
      855612546,
      1738396948,
      1479516111,
      258812777,
      2077511080,
      2011393907,
      79989058,
      1067287976,
      1780299464,
      286451373,
      2446758561
    ]);
    var T256_IV = /* @__PURE__ */ Uint32Array.from([
      573645204,
      4230739756,
      2673172387,
      3360449730,
      596883563,
      1867755857,
      2520282905,
      1497426621,
      2519219938,
      2827943907,
      3193839141,
      1401305490,
      721525244,
      746961066,
      246885852,
      2177182882
    ]);
    var SHA512_224 = class extends SHA5122 {
      constructor() {
        super(28);
        this.Ah = T224_IV[0] | 0;
        this.Al = T224_IV[1] | 0;
        this.Bh = T224_IV[2] | 0;
        this.Bl = T224_IV[3] | 0;
        this.Ch = T224_IV[4] | 0;
        this.Cl = T224_IV[5] | 0;
        this.Dh = T224_IV[6] | 0;
        this.Dl = T224_IV[7] | 0;
        this.Eh = T224_IV[8] | 0;
        this.El = T224_IV[9] | 0;
        this.Fh = T224_IV[10] | 0;
        this.Fl = T224_IV[11] | 0;
        this.Gh = T224_IV[12] | 0;
        this.Gl = T224_IV[13] | 0;
        this.Hh = T224_IV[14] | 0;
        this.Hl = T224_IV[15] | 0;
      }
    };
    exports2.SHA512_224 = SHA512_224;
    var SHA512_256 = class extends SHA5122 {
      constructor() {
        super(32);
        this.Ah = T256_IV[0] | 0;
        this.Al = T256_IV[1] | 0;
        this.Bh = T256_IV[2] | 0;
        this.Bl = T256_IV[3] | 0;
        this.Ch = T256_IV[4] | 0;
        this.Cl = T256_IV[5] | 0;
        this.Dh = T256_IV[6] | 0;
        this.Dl = T256_IV[7] | 0;
        this.Eh = T256_IV[8] | 0;
        this.El = T256_IV[9] | 0;
        this.Fh = T256_IV[10] | 0;
        this.Fl = T256_IV[11] | 0;
        this.Gh = T256_IV[12] | 0;
        this.Gl = T256_IV[13] | 0;
        this.Hh = T256_IV[14] | 0;
        this.Hl = T256_IV[15] | 0;
      }
    };
    exports2.SHA512_256 = SHA512_256;
    exports2.sha256 = (0, utils_ts_1.createHasher)(() => new SHA2562());
    exports2.sha224 = (0, utils_ts_1.createHasher)(() => new SHA224());
    exports2.sha512 = (0, utils_ts_1.createHasher)(() => new SHA5122());
    exports2.sha384 = (0, utils_ts_1.createHasher)(() => new SHA384());
    exports2.sha512_256 = (0, utils_ts_1.createHasher)(() => new SHA512_256());
    exports2.sha512_224 = (0, utils_ts_1.createHasher)(() => new SHA512_224());
  }
});

// node_modules/@noble/hashes/sha256.js
var require_sha256 = __commonJS({
  "node_modules/@noble/hashes/sha256.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sha224 = exports2.SHA224 = exports2.sha256 = exports2.SHA256 = void 0;
    var sha2_ts_1 = require_sha2();
    exports2.SHA256 = sha2_ts_1.SHA256;
    exports2.sha256 = sha2_ts_1.sha256;
    exports2.SHA224 = sha2_ts_1.SHA224;
    exports2.sha224 = sha2_ts_1.sha224;
  }
});

// node_modules/@noble/hashes/sha512.js
var require_sha512 = __commonJS({
  "node_modules/@noble/hashes/sha512.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sha512_256 = exports2.SHA512_256 = exports2.sha512_224 = exports2.SHA512_224 = exports2.sha384 = exports2.SHA384 = exports2.sha512 = exports2.SHA512 = void 0;
    var sha2_ts_1 = require_sha2();
    exports2.SHA512 = sha2_ts_1.SHA512;
    exports2.sha512 = sha2_ts_1.sha512;
    exports2.SHA384 = sha2_ts_1.SHA384;
    exports2.sha384 = sha2_ts_1.sha384;
    exports2.SHA512_224 = sha2_ts_1.SHA512_224;
    exports2.sha512_224 = sha2_ts_1.sha512_224;
    exports2.SHA512_256 = sha2_ts_1.SHA512_256;
    exports2.sha512_256 = sha2_ts_1.sha512_256;
  }
});

// node_modules/@noble/hashes/hmac.js
var require_hmac = __commonJS({
  "node_modules/@noble/hashes/hmac.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hmac = exports2.HMAC = void 0;
    var utils_ts_1 = require_utils();
    var HMAC2 = class extends utils_ts_1.Hash {
      constructor(hash, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        (0, utils_ts_1.ahash)(hash);
        const key = (0, utils_ts_1.toBytes)(_key);
        this.iHash = hash.create();
        if (typeof this.iHash.update !== "function")
          throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
        for (let i = 0; i < pad.length; i++)
          pad[i] ^= 54;
        this.iHash.update(pad);
        this.oHash = hash.create();
        for (let i = 0; i < pad.length; i++)
          pad[i] ^= 54 ^ 92;
        this.oHash.update(pad);
        (0, utils_ts_1.clean)(pad);
      }
      update(buf2) {
        (0, utils_ts_1.aexists)(this);
        this.iHash.update(buf2);
        return this;
      }
      digestInto(out) {
        (0, utils_ts_1.aexists)(this);
        (0, utils_ts_1.abytes)(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
      }
      digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
      }
      _cloneInto(to) {
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
      }
      clone() {
        return this._cloneInto();
      }
      destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
      }
    };
    exports2.HMAC = HMAC2;
    var hmac2 = (hash, key, message) => new HMAC2(hash, key).update(message).digest();
    exports2.hmac = hmac2;
    exports2.hmac.create = (hash, key) => new HMAC2(hash, key);
  }
});

// node_modules/@noble/hashes/pbkdf2.js
var require_pbkdf2 = __commonJS({
  "node_modules/@noble/hashes/pbkdf2.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.pbkdf2 = pbkdf23;
    exports2.pbkdf2Async = pbkdf2Async2;
    var hmac_ts_1 = require_hmac();
    var utils_ts_1 = require_utils();
    function pbkdf2Init2(hash, _password, _salt, _opts) {
      (0, utils_ts_1.ahash)(hash);
      const opts = (0, utils_ts_1.checkOpts)({ dkLen: 32, asyncTick: 10 }, _opts);
      const { c, dkLen, asyncTick } = opts;
      (0, utils_ts_1.anumber)(c);
      (0, utils_ts_1.anumber)(dkLen);
      (0, utils_ts_1.anumber)(asyncTick);
      if (c < 1)
        throw new Error("iterations (c) should be >= 1");
      const password = (0, utils_ts_1.kdfInputToBytes)(_password);
      const salt = (0, utils_ts_1.kdfInputToBytes)(_salt);
      const DK = new Uint8Array(dkLen);
      const PRF = hmac_ts_1.hmac.create(hash, password);
      const PRFSalt = PRF._cloneInto().update(salt);
      return { c, dkLen, asyncTick, DK, PRF, PRFSalt };
    }
    function pbkdf2Output2(PRF, PRFSalt, DK, prfW, u) {
      PRF.destroy();
      PRFSalt.destroy();
      if (prfW)
        prfW.destroy();
      (0, utils_ts_1.clean)(u);
      return DK;
    }
    function pbkdf23(hash, password, salt, opts) {
      const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init2(hash, password, salt, opts);
      let prfW;
      const arr = new Uint8Array(4);
      const view = (0, utils_ts_1.createView)(arr);
      const u = new Uint8Array(PRF.outputLen);
      for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
        const Ti = DK.subarray(pos, pos + PRF.outputLen);
        view.setInt32(0, ti, false);
        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
        Ti.set(u.subarray(0, Ti.length));
        for (let ui = 1; ui < c; ui++) {
          PRF._cloneInto(prfW).update(u).digestInto(u);
          for (let i = 0; i < Ti.length; i++)
            Ti[i] ^= u[i];
        }
      }
      return pbkdf2Output2(PRF, PRFSalt, DK, prfW, u);
    }
    async function pbkdf2Async2(hash, password, salt, opts) {
      const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init2(hash, password, salt, opts);
      let prfW;
      const arr = new Uint8Array(4);
      const view = (0, utils_ts_1.createView)(arr);
      const u = new Uint8Array(PRF.outputLen);
      for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
        const Ti = DK.subarray(pos, pos + PRF.outputLen);
        view.setInt32(0, ti, false);
        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
        Ti.set(u.subarray(0, Ti.length));
        await (0, utils_ts_1.asyncLoop)(c - 1, asyncTick, () => {
          PRF._cloneInto(prfW).update(u).digestInto(u);
          for (let i = 0; i < Ti.length; i++)
            Ti[i] ^= u[i];
        });
      }
      return pbkdf2Output2(PRF, PRFSalt, DK, prfW, u);
    }
  }
});

// node_modules/bip39/src/wordlists/czech.json
var require_czech = __commonJS({
  "node_modules/bip39/src/wordlists/czech.json"(exports2, module2) {
    module2.exports = [
      "abdikace",
      "abeceda",
      "adresa",
      "agrese",
      "akce",
      "aktovka",
      "alej",
      "alkohol",
      "amputace",
      "ananas",
      "andulka",
      "anekdota",
      "anketa",
      "antika",
      "anulovat",
      "archa",
      "arogance",
      "asfalt",
      "asistent",
      "aspirace",
      "astma",
      "astronom",
      "atlas",
      "atletika",
      "atol",
      "autobus",
      "azyl",
      "babka",
      "bachor",
      "bacil",
      "baculka",
      "badatel",
      "bageta",
      "bagr",
      "bahno",
      "bakterie",
      "balada",
      "baletka",
      "balkon",
      "balonek",
      "balvan",
      "balza",
      "bambus",
      "bankomat",
      "barbar",
      "baret",
      "barman",
      "baroko",
      "barva",
      "baterka",
      "batoh",
      "bavlna",
      "bazalka",
      "bazilika",
      "bazuka",
      "bedna",
      "beran",
      "beseda",
      "bestie",
      "beton",
      "bezinka",
      "bezmoc",
      "beztak",
      "bicykl",
      "bidlo",
      "biftek",
      "bikiny",
      "bilance",
      "biograf",
      "biolog",
      "bitva",
      "bizon",
      "blahobyt",
      "blatouch",
      "blecha",
      "bledule",
      "blesk",
      "blikat",
      "blizna",
      "blokovat",
      "bloudit",
      "blud",
      "bobek",
      "bobr",
      "bodlina",
      "bodnout",
      "bohatost",
      "bojkot",
      "bojovat",
      "bokorys",
      "bolest",
      "borec",
      "borovice",
      "bota",
      "boubel",
      "bouchat",
      "bouda",
      "boule",
      "bourat",
      "boxer",
      "bradavka",
      "brambora",
      "branka",
      "bratr",
      "brepta",
      "briketa",
      "brko",
      "brloh",
      "bronz",
      "broskev",
      "brunetka",
      "brusinka",
      "brzda",
      "brzy",
      "bublina",
      "bubnovat",
      "buchta",
      "buditel",
      "budka",
      "budova",
      "bufet",
      "bujarost",
      "bukvice",
      "buldok",
      "bulva",
      "bunda",
      "bunkr",
      "burza",
      "butik",
      "buvol",
      "buzola",
      "bydlet",
      "bylina",
      "bytovka",
      "bzukot",
      "capart",
      "carevna",
      "cedr",
      "cedule",
      "cejch",
      "cejn",
      "cela",
      "celer",
      "celkem",
      "celnice",
      "cenina",
      "cennost",
      "cenovka",
      "centrum",
      "cenzor",
      "cestopis",
      "cetka",
      "chalupa",
      "chapadlo",
      "charita",
      "chata",
      "chechtat",
      "chemie",
      "chichot",
      "chirurg",
      "chlad",
      "chleba",
      "chlubit",
      "chmel",
      "chmura",
      "chobot",
      "chochol",
      "chodba",
      "cholera",
      "chomout",
      "chopit",
      "choroba",
      "chov",
      "chrapot",
      "chrlit",
      "chrt",
      "chrup",
      "chtivost",
      "chudina",
      "chutnat",
      "chvat",
      "chvilka",
      "chvost",
      "chyba",
      "chystat",
      "chytit",
      "cibule",
      "cigareta",
      "cihelna",
      "cihla",
      "cinkot",
      "cirkus",
      "cisterna",
      "citace",
      "citrus",
      "cizinec",
      "cizost",
      "clona",
      "cokoliv",
      "couvat",
      "ctitel",
      "ctnost",
      "cudnost",
      "cuketa",
      "cukr",
      "cupot",
      "cvaknout",
      "cval",
      "cvik",
      "cvrkot",
      "cyklista",
      "daleko",
      "dareba",
      "datel",
      "datum",
      "dcera",
      "debata",
      "dechovka",
      "decibel",
      "deficit",
      "deflace",
      "dekl",
      "dekret",
      "demokrat",
      "deprese",
      "derby",
      "deska",
      "detektiv",
      "dikobraz",
      "diktovat",
      "dioda",
      "diplom",
      "disk",
      "displej",
      "divadlo",
      "divoch",
      "dlaha",
      "dlouho",
      "dluhopis",
      "dnes",
      "dobro",
      "dobytek",
      "docent",
      "dochutit",
      "dodnes",
      "dohled",
      "dohoda",
      "dohra",
      "dojem",
      "dojnice",
      "doklad",
      "dokola",
      "doktor",
      "dokument",
      "dolar",
      "doleva",
      "dolina",
      "doma",
      "dominant",
      "domluvit",
      "domov",
      "donutit",
      "dopad",
      "dopis",
      "doplnit",
      "doposud",
      "doprovod",
      "dopustit",
      "dorazit",
      "dorost",
      "dort",
      "dosah",
      "doslov",
      "dostatek",
      "dosud",
      "dosyta",
      "dotaz",
      "dotek",
      "dotknout",
      "doufat",
      "doutnat",
      "dovozce",
      "dozadu",
      "doznat",
      "dozorce",
      "drahota",
      "drak",
      "dramatik",
      "dravec",
      "draze",
      "drdol",
      "drobnost",
      "drogerie",
      "drozd",
      "drsnost",
      "drtit",
      "drzost",
      "duben",
      "duchovno",
      "dudek",
      "duha",
      "duhovka",
      "dusit",
      "dusno",
      "dutost",
      "dvojice",
      "dvorec",
      "dynamit",
      "ekolog",
      "ekonomie",
      "elektron",
      "elipsa",
      "email",
      "emise",
      "emoce",
      "empatie",
      "epizoda",
      "epocha",
      "epopej",
      "epos",
      "esej",
      "esence",
      "eskorta",
      "eskymo",
      "etiketa",
      "euforie",
      "evoluce",
      "exekuce",
      "exkurze",
      "expedice",
      "exploze",
      "export",
      "extrakt",
      "facka",
      "fajfka",
      "fakulta",
      "fanatik",
      "fantazie",
      "farmacie",
      "favorit",
      "fazole",
      "federace",
      "fejeton",
      "fenka",
      "fialka",
      "figurant",
      "filozof",
      "filtr",
      "finance",
      "finta",
      "fixace",
      "fjord",
      "flanel",
      "flirt",
      "flotila",
      "fond",
      "fosfor",
      "fotbal",
      "fotka",
      "foton",
      "frakce",
      "freska",
      "fronta",
      "fukar",
      "funkce",
      "fyzika",
      "galeje",
      "garant",
      "genetika",
      "geolog",
      "gilotina",
      "glazura",
      "glejt",
      "golem",
      "golfista",
      "gotika",
      "graf",
      "gramofon",
      "granule",
      "grep",
      "gril",
      "grog",
      "groteska",
      "guma",
      "hadice",
      "hadr",
      "hala",
      "halenka",
      "hanba",
      "hanopis",
      "harfa",
      "harpuna",
      "havran",
      "hebkost",
      "hejkal",
      "hejno",
      "hejtman",
      "hektar",
      "helma",
      "hematom",
      "herec",
      "herna",
      "heslo",
      "hezky",
      "historik",
      "hladovka",
      "hlasivky",
      "hlava",
      "hledat",
      "hlen",
      "hlodavec",
      "hloh",
      "hloupost",
      "hltat",
      "hlubina",
      "hluchota",
      "hmat",
      "hmota",
      "hmyz",
      "hnis",
      "hnojivo",
      "hnout",
      "hoblina",
      "hoboj",
      "hoch",
      "hodiny",
      "hodlat",
      "hodnota",
      "hodovat",
      "hojnost",
      "hokej",
      "holinka",
      "holka",
      "holub",
      "homole",
      "honitba",
      "honorace",
      "horal",
      "horda",
      "horizont",
      "horko",
      "horlivec",
      "hormon",
      "hornina",
      "horoskop",
      "horstvo",
      "hospoda",
      "hostina",
      "hotovost",
      "houba",
      "houf",
      "houpat",
      "houska",
      "hovor",
      "hradba",
      "hranice",
      "hravost",
      "hrazda",
      "hrbolek",
      "hrdina",
      "hrdlo",
      "hrdost",
      "hrnek",
      "hrobka",
      "hromada",
      "hrot",
      "hrouda",
      "hrozen",
      "hrstka",
      "hrubost",
      "hryzat",
      "hubenost",
      "hubnout",
      "hudba",
      "hukot",
      "humr",
      "husita",
      "hustota",
      "hvozd",
      "hybnost",
      "hydrant",
      "hygiena",
      "hymna",
      "hysterik",
      "idylka",
      "ihned",
      "ikona",
      "iluze",
      "imunita",
      "infekce",
      "inflace",
      "inkaso",
      "inovace",
      "inspekce",
      "internet",
      "invalida",
      "investor",
      "inzerce",
      "ironie",
      "jablko",
      "jachta",
      "jahoda",
      "jakmile",
      "jakost",
      "jalovec",
      "jantar",
      "jarmark",
      "jaro",
      "jasan",
      "jasno",
      "jatka",
      "javor",
      "jazyk",
      "jedinec",
      "jedle",
      "jednatel",
      "jehlan",
      "jekot",
      "jelen",
      "jelito",
      "jemnost",
      "jenom",
      "jepice",
      "jeseter",
      "jevit",
      "jezdec",
      "jezero",
      "jinak",
      "jindy",
      "jinoch",
      "jiskra",
      "jistota",
      "jitrnice",
      "jizva",
      "jmenovat",
      "jogurt",
      "jurta",
      "kabaret",
      "kabel",
      "kabinet",
      "kachna",
      "kadet",
      "kadidlo",
      "kahan",
      "kajak",
      "kajuta",
      "kakao",
      "kaktus",
      "kalamita",
      "kalhoty",
      "kalibr",
      "kalnost",
      "kamera",
      "kamkoliv",
      "kamna",
      "kanibal",
      "kanoe",
      "kantor",
      "kapalina",
      "kapela",
      "kapitola",
      "kapka",
      "kaple",
      "kapota",
      "kapr",
      "kapusta",
      "kapybara",
      "karamel",
      "karotka",
      "karton",
      "kasa",
      "katalog",
      "katedra",
      "kauce",
      "kauza",
      "kavalec",
      "kazajka",
      "kazeta",
      "kazivost",
      "kdekoliv",
      "kdesi",
      "kedluben",
      "kemp",
      "keramika",
      "kino",
      "klacek",
      "kladivo",
      "klam",
      "klapot",
      "klasika",
      "klaun",
      "klec",
      "klenba",
      "klepat",
      "klesnout",
      "klid",
      "klima",
      "klisna",
      "klobouk",
      "klokan",
      "klopa",
      "kloub",
      "klubovna",
      "klusat",
      "kluzkost",
      "kmen",
      "kmitat",
      "kmotr",
      "kniha",
      "knot",
      "koalice",
      "koberec",
      "kobka",
      "kobliha",
      "kobyla",
      "kocour",
      "kohout",
      "kojenec",
      "kokos",
      "koktejl",
      "kolaps",
      "koleda",
      "kolize",
      "kolo",
      "komando",
      "kometa",
      "komik",
      "komnata",
      "komora",
      "kompas",
      "komunita",
      "konat",
      "koncept",
      "kondice",
      "konec",
      "konfese",
      "kongres",
      "konina",
      "konkurs",
      "kontakt",
      "konzerva",
      "kopanec",
      "kopie",
      "kopnout",
      "koprovka",
      "korbel",
      "korektor",
      "kormidlo",
      "koroptev",
      "korpus",
      "koruna",
      "koryto",
      "korzet",
      "kosatec",
      "kostka",
      "kotel",
      "kotleta",
      "kotoul",
      "koukat",
      "koupelna",
      "kousek",
      "kouzlo",
      "kovboj",
      "koza",
      "kozoroh",
      "krabice",
      "krach",
      "krajina",
      "kralovat",
      "krasopis",
      "kravata",
      "kredit",
      "krejcar",
      "kresba",
      "kreveta",
      "kriket",
      "kritik",
      "krize",
      "krkavec",
      "krmelec",
      "krmivo",
      "krocan",
      "krok",
      "kronika",
      "kropit",
      "kroupa",
      "krovka",
      "krtek",
      "kruhadlo",
      "krupice",
      "krutost",
      "krvinka",
      "krychle",
      "krypta",
      "krystal",
      "kryt",
      "kudlanka",
      "kufr",
      "kujnost",
      "kukla",
      "kulajda",
      "kulich",
      "kulka",
      "kulomet",
      "kultura",
      "kuna",
      "kupodivu",
      "kurt",
      "kurzor",
      "kutil",
      "kvalita",
      "kvasinka",
      "kvestor",
      "kynolog",
      "kyselina",
      "kytara",
      "kytice",
      "kytka",
      "kytovec",
      "kyvadlo",
      "labrador",
      "lachtan",
      "ladnost",
      "laik",
      "lakomec",
      "lamela",
      "lampa",
      "lanovka",
      "lasice",
      "laso",
      "lastura",
      "latinka",
      "lavina",
      "lebka",
      "leckdy",
      "leden",
      "lednice",
      "ledovka",
      "ledvina",
      "legenda",
      "legie",
      "legrace",
      "lehce",
      "lehkost",
      "lehnout",
      "lektvar",
      "lenochod",
      "lentilka",
      "lepenka",
      "lepidlo",
      "letadlo",
      "letec",
      "letmo",
      "letokruh",
      "levhart",
      "levitace",
      "levobok",
      "libra",
      "lichotka",
      "lidojed",
      "lidskost",
      "lihovina",
      "lijavec",
      "lilek",
      "limetka",
      "linie",
      "linka",
      "linoleum",
      "listopad",
      "litina",
      "litovat",
      "lobista",
      "lodivod",
      "logika",
      "logoped",
      "lokalita",
      "loket",
      "lomcovat",
      "lopata",
      "lopuch",
      "lord",
      "losos",
      "lotr",
      "loudal",
      "louh",
      "louka",
      "louskat",
      "lovec",
      "lstivost",
      "lucerna",
      "lucifer",
      "lump",
      "lusk",
      "lustrace",
      "lvice",
      "lyra",
      "lyrika",
      "lysina",
      "madam",
      "madlo",
      "magistr",
      "mahagon",
      "majetek",
      "majitel",
      "majorita",
      "makak",
      "makovice",
      "makrela",
      "malba",
      "malina",
      "malovat",
      "malvice",
      "maminka",
      "mandle",
      "manko",
      "marnost",
      "masakr",
      "maskot",
      "masopust",
      "matice",
      "matrika",
      "maturita",
      "mazanec",
      "mazivo",
      "mazlit",
      "mazurka",
      "mdloba",
      "mechanik",
      "meditace",
      "medovina",
      "melasa",
      "meloun",
      "mentolka",
      "metla",
      "metoda",
      "metr",
      "mezera",
      "migrace",
      "mihnout",
      "mihule",
      "mikina",
      "mikrofon",
      "milenec",
      "milimetr",
      "milost",
      "mimika",
      "mincovna",
      "minibar",
      "minomet",
      "minulost",
      "miska",
      "mistr",
      "mixovat",
      "mladost",
      "mlha",
      "mlhovina",
      "mlok",
      "mlsat",
      "mluvit",
      "mnich",
      "mnohem",
      "mobil",
      "mocnost",
      "modelka",
      "modlitba",
      "mohyla",
      "mokro",
      "molekula",
      "momentka",
      "monarcha",
      "monokl",
      "monstrum",
      "montovat",
      "monzun",
      "mosaz",
      "moskyt",
      "most",
      "motivace",
      "motorka",
      "motyka",
      "moucha",
      "moudrost",
      "mozaika",
      "mozek",
      "mozol",
      "mramor",
      "mravenec",
      "mrkev",
      "mrtvola",
      "mrzet",
      "mrzutost",
      "mstitel",
      "mudrc",
      "muflon",
      "mulat",
      "mumie",
      "munice",
      "muset",
      "mutace",
      "muzeum",
      "muzikant",
      "myslivec",
      "mzda",
      "nabourat",
      "nachytat",
      "nadace",
      "nadbytek",
      "nadhoz",
      "nadobro",
      "nadpis",
      "nahlas",
      "nahnat",
      "nahodile",
      "nahradit",
      "naivita",
      "najednou",
      "najisto",
      "najmout",
      "naklonit",
      "nakonec",
      "nakrmit",
      "nalevo",
      "namazat",
      "namluvit",
      "nanometr",
      "naoko",
      "naopak",
      "naostro",
      "napadat",
      "napevno",
      "naplnit",
      "napnout",
      "naposled",
      "naprosto",
      "narodit",
      "naruby",
      "narychlo",
      "nasadit",
      "nasekat",
      "naslepo",
      "nastat",
      "natolik",
      "navenek",
      "navrch",
      "navzdory",
      "nazvat",
      "nebe",
      "nechat",
      "necky",
      "nedaleko",
      "nedbat",
      "neduh",
      "negace",
      "nehet",
      "nehoda",
      "nejen",
      "nejprve",
      "neklid",
      "nelibost",
      "nemilost",
      "nemoc",
      "neochota",
      "neonka",
      "nepokoj",
      "nerost",
      "nerv",
      "nesmysl",
      "nesoulad",
      "netvor",
      "neuron",
      "nevina",
      "nezvykle",
      "nicota",
      "nijak",
      "nikam",
      "nikdy",
      "nikl",
      "nikterak",
      "nitro",
      "nocleh",
      "nohavice",
      "nominace",
      "nora",
      "norek",
      "nositel",
      "nosnost",
      "nouze",
      "noviny",
      "novota",
      "nozdra",
      "nuda",
      "nudle",
      "nuget",
      "nutit",
      "nutnost",
      "nutrie",
      "nymfa",
      "obal",
      "obarvit",
      "obava",
      "obdiv",
      "obec",
      "obehnat",
      "obejmout",
      "obezita",
      "obhajoba",
      "obilnice",
      "objasnit",
      "objekt",
      "obklopit",
      "oblast",
      "oblek",
      "obliba",
      "obloha",
      "obluda",
      "obnos",
      "obohatit",
      "obojek",
      "obout",
      "obrazec",
      "obrna",
      "obruba",
      "obrys",
      "obsah",
      "obsluha",
      "obstarat",
      "obuv",
      "obvaz",
      "obvinit",
      "obvod",
      "obvykle",
      "obyvatel",
      "obzor",
      "ocas",
      "ocel",
      "ocenit",
      "ochladit",
      "ochota",
      "ochrana",
      "ocitnout",
      "odboj",
      "odbyt",
      "odchod",
      "odcizit",
      "odebrat",
      "odeslat",
      "odevzdat",
      "odezva",
      "odhadce",
      "odhodit",
      "odjet",
      "odjinud",
      "odkaz",
      "odkoupit",
      "odliv",
      "odluka",
      "odmlka",
      "odolnost",
      "odpad",
      "odpis",
      "odplout",
      "odpor",
      "odpustit",
      "odpykat",
      "odrazka",
      "odsoudit",
      "odstup",
      "odsun",
      "odtok",
      "odtud",
      "odvaha",
      "odveta",
      "odvolat",
      "odvracet",
      "odznak",
      "ofina",
      "ofsajd",
      "ohlas",
      "ohnisko",
      "ohrada",
      "ohrozit",
      "ohryzek",
      "okap",
      "okenice",
      "oklika",
      "okno",
      "okouzlit",
      "okovy",
      "okrasa",
      "okres",
      "okrsek",
      "okruh",
      "okupant",
      "okurka",
      "okusit",
      "olejnina",
      "olizovat",
      "omak",
      "omeleta",
      "omezit",
      "omladina",
      "omlouvat",
      "omluva",
      "omyl",
      "onehdy",
      "opakovat",
      "opasek",
      "operace",
      "opice",
      "opilost",
      "opisovat",
      "opora",
      "opozice",
      "opravdu",
      "oproti",
      "orbital",
      "orchestr",
      "orgie",
      "orlice",
      "orloj",
      "ortel",
      "osada",
      "oschnout",
      "osika",
      "osivo",
      "oslava",
      "oslepit",
      "oslnit",
      "oslovit",
      "osnova",
      "osoba",
      "osolit",
      "ospalec",
      "osten",
      "ostraha",
      "ostuda",
      "ostych",
      "osvojit",
      "oteplit",
      "otisk",
      "otop",
      "otrhat",
      "otrlost",
      "otrok",
      "otruby",
      "otvor",
      "ovanout",
      "ovar",
      "oves",
      "ovlivnit",
      "ovoce",
      "oxid",
      "ozdoba",
      "pachatel",
      "pacient",
      "padouch",
      "pahorek",
      "pakt",
      "palanda",
      "palec",
      "palivo",
      "paluba",
      "pamflet",
      "pamlsek",
      "panenka",
      "panika",
      "panna",
      "panovat",
      "panstvo",
      "pantofle",
      "paprika",
      "parketa",
      "parodie",
      "parta",
      "paruka",
      "paryba",
      "paseka",
      "pasivita",
      "pastelka",
      "patent",
      "patrona",
      "pavouk",
      "pazneht",
      "pazourek",
      "pecka",
      "pedagog",
      "pejsek",
      "peklo",
      "peloton",
      "penalta",
      "pendrek",
      "penze",
      "periskop",
      "pero",
      "pestrost",
      "petarda",
      "petice",
      "petrolej",
      "pevnina",
      "pexeso",
      "pianista",
      "piha",
      "pijavice",
      "pikle",
      "piknik",
      "pilina",
      "pilnost",
      "pilulka",
      "pinzeta",
      "pipeta",
      "pisatel",
      "pistole",
      "pitevna",
      "pivnice",
      "pivovar",
      "placenta",
      "plakat",
      "plamen",
      "planeta",
      "plastika",
      "platit",
      "plavidlo",
      "plaz",
      "plech",
      "plemeno",
      "plenta",
      "ples",
      "pletivo",
      "plevel",
      "plivat",
      "plnit",
      "plno",
      "plocha",
      "plodina",
      "plomba",
      "plout",
      "pluk",
      "plyn",
      "pobavit",
      "pobyt",
      "pochod",
      "pocit",
      "poctivec",
      "podat",
      "podcenit",
      "podepsat",
      "podhled",
      "podivit",
      "podklad",
      "podmanit",
      "podnik",
      "podoba",
      "podpora",
      "podraz",
      "podstata",
      "podvod",
      "podzim",
      "poezie",
      "pohanka",
      "pohnutka",
      "pohovor",
      "pohroma",
      "pohyb",
      "pointa",
      "pojistka",
      "pojmout",
      "pokazit",
      "pokles",
      "pokoj",
      "pokrok",
      "pokuta",
      "pokyn",
      "poledne",
      "polibek",
      "polknout",
      "poloha",
      "polynom",
      "pomalu",
      "pominout",
      "pomlka",
      "pomoc",
      "pomsta",
      "pomyslet",
      "ponechat",
      "ponorka",
      "ponurost",
      "popadat",
      "popel",
      "popisek",
      "poplach",
      "poprosit",
      "popsat",
      "popud",
      "poradce",
      "porce",
      "porod",
      "porucha",
      "poryv",
      "posadit",
      "posed",
      "posila",
      "poskok",
      "poslanec",
      "posoudit",
      "pospolu",
      "postava",
      "posudek",
      "posyp",
      "potah",
      "potkan",
      "potlesk",
      "potomek",
      "potrava",
      "potupa",
      "potvora",
      "poukaz",
      "pouto",
      "pouzdro",
      "povaha",
      "povidla",
      "povlak",
      "povoz",
      "povrch",
      "povstat",
      "povyk",
      "povzdech",
      "pozdrav",
      "pozemek",
      "poznatek",
      "pozor",
      "pozvat",
      "pracovat",
      "prahory",
      "praktika",
      "prales",
      "praotec",
      "praporek",
      "prase",
      "pravda",
      "princip",
      "prkno",
      "probudit",
      "procento",
      "prodej",
      "profese",
      "prohra",
      "projekt",
      "prolomit",
      "promile",
      "pronikat",
      "propad",
      "prorok",
      "prosba",
      "proton",
      "proutek",
      "provaz",
      "prskavka",
      "prsten",
      "prudkost",
      "prut",
      "prvek",
      "prvohory",
      "psanec",
      "psovod",
      "pstruh",
      "ptactvo",
      "puberta",
      "puch",
      "pudl",
      "pukavec",
      "puklina",
      "pukrle",
      "pult",
      "pumpa",
      "punc",
      "pupen",
      "pusa",
      "pusinka",
      "pustina",
      "putovat",
      "putyka",
      "pyramida",
      "pysk",
      "pytel",
      "racek",
      "rachot",
      "radiace",
      "radnice",
      "radon",
      "raft",
      "ragby",
      "raketa",
      "rakovina",
      "rameno",
      "rampouch",
      "rande",
      "rarach",
      "rarita",
      "rasovna",
      "rastr",
      "ratolest",
      "razance",
      "razidlo",
      "reagovat",
      "reakce",
      "recept",
      "redaktor",
      "referent",
      "reflex",
      "rejnok",
      "reklama",
      "rekord",
      "rekrut",
      "rektor",
      "reputace",
      "revize",
      "revma",
      "revolver",
      "rezerva",
      "riskovat",
      "riziko",
      "robotika",
      "rodokmen",
      "rohovka",
      "rokle",
      "rokoko",
      "romaneto",
      "ropovod",
      "ropucha",
      "rorejs",
      "rosol",
      "rostlina",
      "rotmistr",
      "rotoped",
      "rotunda",
      "roubenka",
      "roucho",
      "roup",
      "roura",
      "rovina",
      "rovnice",
      "rozbor",
      "rozchod",
      "rozdat",
      "rozeznat",
      "rozhodce",
      "rozinka",
      "rozjezd",
      "rozkaz",
      "rozloha",
      "rozmar",
      "rozpad",
      "rozruch",
      "rozsah",
      "roztok",
      "rozum",
      "rozvod",
      "rubrika",
      "ruchadlo",
      "rukavice",
      "rukopis",
      "ryba",
      "rybolov",
      "rychlost",
      "rydlo",
      "rypadlo",
      "rytina",
      "ryzost",
      "sadista",
      "sahat",
      "sako",
      "samec",
      "samizdat",
      "samota",
      "sanitka",
      "sardinka",
      "sasanka",
      "satelit",
      "sazba",
      "sazenice",
      "sbor",
      "schovat",
      "sebranka",
      "secese",
      "sedadlo",
      "sediment",
      "sedlo",
      "sehnat",
      "sejmout",
      "sekera",
      "sekta",
      "sekunda",
      "sekvoje",
      "semeno",
      "seno",
      "servis",
      "sesadit",
      "seshora",
      "seskok",
      "seslat",
      "sestra",
      "sesuv",
      "sesypat",
      "setba",
      "setina",
      "setkat",
      "setnout",
      "setrvat",
      "sever",
      "seznam",
      "shoda",
      "shrnout",
      "sifon",
      "silnice",
      "sirka",
      "sirotek",
      "sirup",
      "situace",
      "skafandr",
      "skalisko",
      "skanzen",
      "skaut",
      "skeptik",
      "skica",
      "skladba",
      "sklenice",
      "sklo",
      "skluz",
      "skoba",
      "skokan",
      "skoro",
      "skripta",
      "skrz",
      "skupina",
      "skvost",
      "skvrna",
      "slabika",
      "sladidlo",
      "slanina",
      "slast",
      "slavnost",
      "sledovat",
      "slepec",
      "sleva",
      "slezina",
      "slib",
      "slina",
      "sliznice",
      "slon",
      "sloupek",
      "slovo",
      "sluch",
      "sluha",
      "slunce",
      "slupka",
      "slza",
      "smaragd",
      "smetana",
      "smilstvo",
      "smlouva",
      "smog",
      "smrad",
      "smrk",
      "smrtka",
      "smutek",
      "smysl",
      "snad",
      "snaha",
      "snob",
      "sobota",
      "socha",
      "sodovka",
      "sokol",
      "sopka",
      "sotva",
      "souboj",
      "soucit",
      "soudce",
      "souhlas",
      "soulad",
      "soumrak",
      "souprava",
      "soused",
      "soutok",
      "souviset",
      "spalovna",
      "spasitel",
      "spis",
      "splav",
      "spodek",
      "spojenec",
      "spolu",
      "sponzor",
      "spornost",
      "spousta",
      "sprcha",
      "spustit",
      "sranda",
      "sraz",
      "srdce",
      "srna",
      "srnec",
      "srovnat",
      "srpen",
      "srst",
      "srub",
      "stanice",
      "starosta",
      "statika",
      "stavba",
      "stehno",
      "stezka",
      "stodola",
      "stolek",
      "stopa",
      "storno",
      "stoupat",
      "strach",
      "stres",
      "strhnout",
      "strom",
      "struna",
      "studna",
      "stupnice",
      "stvol",
      "styk",
      "subjekt",
      "subtropy",
      "suchar",
      "sudost",
      "sukno",
      "sundat",
      "sunout",
      "surikata",
      "surovina",
      "svah",
      "svalstvo",
      "svetr",
      "svatba",
      "svazek",
      "svisle",
      "svitek",
      "svoboda",
      "svodidlo",
      "svorka",
      "svrab",
      "sykavka",
      "sykot",
      "synek",
      "synovec",
      "sypat",
      "sypkost",
      "syrovost",
      "sysel",
      "sytost",
      "tabletka",
      "tabule",
      "tahoun",
      "tajemno",
      "tajfun",
      "tajga",
      "tajit",
      "tajnost",
      "taktika",
      "tamhle",
      "tampon",
      "tancovat",
      "tanec",
      "tanker",
      "tapeta",
      "tavenina",
      "tazatel",
      "technika",
      "tehdy",
      "tekutina",
      "telefon",
      "temnota",
      "tendence",
      "tenista",
      "tenor",
      "teplota",
      "tepna",
      "teprve",
      "terapie",
      "termoska",
      "textil",
      "ticho",
      "tiskopis",
      "titulek",
      "tkadlec",
      "tkanina",
      "tlapka",
      "tleskat",
      "tlukot",
      "tlupa",
      "tmel",
      "toaleta",
      "topinka",
      "topol",
      "torzo",
      "touha",
      "toulec",
      "tradice",
      "traktor",
      "tramp",
      "trasa",
      "traverza",
      "trefit",
      "trest",
      "trezor",
      "trhavina",
      "trhlina",
      "trochu",
      "trojice",
      "troska",
      "trouba",
      "trpce",
      "trpitel",
      "trpkost",
      "trubec",
      "truchlit",
      "truhlice",
      "trus",
      "trvat",
      "tudy",
      "tuhnout",
      "tuhost",
      "tundra",
      "turista",
      "turnaj",
      "tuzemsko",
      "tvaroh",
      "tvorba",
      "tvrdost",
      "tvrz",
      "tygr",
      "tykev",
      "ubohost",
      "uboze",
      "ubrat",
      "ubrousek",
      "ubrus",
      "ubytovna",
      "ucho",
      "uctivost",
      "udivit",
      "uhradit",
      "ujednat",
      "ujistit",
      "ujmout",
      "ukazatel",
      "uklidnit",
      "uklonit",
      "ukotvit",
      "ukrojit",
      "ulice",
      "ulita",
      "ulovit",
      "umyvadlo",
      "unavit",
      "uniforma",
      "uniknout",
      "upadnout",
      "uplatnit",
      "uplynout",
      "upoutat",
      "upravit",
      "uran",
      "urazit",
      "usednout",
      "usilovat",
      "usmrtit",
      "usnadnit",
      "usnout",
      "usoudit",
      "ustlat",
      "ustrnout",
      "utahovat",
      "utkat",
      "utlumit",
      "utonout",
      "utopenec",
      "utrousit",
      "uvalit",
      "uvolnit",
      "uvozovka",
      "uzdravit",
      "uzel",
      "uzenina",
      "uzlina",
      "uznat",
      "vagon",
      "valcha",
      "valoun",
      "vana",
      "vandal",
      "vanilka",
      "varan",
      "varhany",
      "varovat",
      "vcelku",
      "vchod",
      "vdova",
      "vedro",
      "vegetace",
      "vejce",
      "velbloud",
      "veletrh",
      "velitel",
      "velmoc",
      "velryba",
      "venkov",
      "veranda",
      "verze",
      "veselka",
      "veskrze",
      "vesnice",
      "vespodu",
      "vesta",
      "veterina",
      "veverka",
      "vibrace",
      "vichr",
      "videohra",
      "vidina",
      "vidle",
      "vila",
      "vinice",
      "viset",
      "vitalita",
      "vize",
      "vizitka",
      "vjezd",
      "vklad",
      "vkus",
      "vlajka",
      "vlak",
      "vlasec",
      "vlevo",
      "vlhkost",
      "vliv",
      "vlnovka",
      "vloupat",
      "vnucovat",
      "vnuk",
      "voda",
      "vodivost",
      "vodoznak",
      "vodstvo",
      "vojensky",
      "vojna",
      "vojsko",
      "volant",
      "volba",
      "volit",
      "volno",
      "voskovka",
      "vozidlo",
      "vozovna",
      "vpravo",
      "vrabec",
      "vracet",
      "vrah",
      "vrata",
      "vrba",
      "vrcholek",
      "vrhat",
      "vrstva",
      "vrtule",
      "vsadit",
      "vstoupit",
      "vstup",
      "vtip",
      "vybavit",
      "vybrat",
      "vychovat",
      "vydat",
      "vydra",
      "vyfotit",
      "vyhledat",
      "vyhnout",
      "vyhodit",
      "vyhradit",
      "vyhubit",
      "vyjasnit",
      "vyjet",
      "vyjmout",
      "vyklopit",
      "vykonat",
      "vylekat",
      "vymazat",
      "vymezit",
      "vymizet",
      "vymyslet",
      "vynechat",
      "vynikat",
      "vynutit",
      "vypadat",
      "vyplatit",
      "vypravit",
      "vypustit",
      "vyrazit",
      "vyrovnat",
      "vyrvat",
      "vyslovit",
      "vysoko",
      "vystavit",
      "vysunout",
      "vysypat",
      "vytasit",
      "vytesat",
      "vytratit",
      "vyvinout",
      "vyvolat",
      "vyvrhel",
      "vyzdobit",
      "vyznat",
      "vzadu",
      "vzbudit",
      "vzchopit",
      "vzdor",
      "vzduch",
      "vzdychat",
      "vzestup",
      "vzhledem",
      "vzkaz",
      "vzlykat",
      "vznik",
      "vzorek",
      "vzpoura",
      "vztah",
      "vztek",
      "xylofon",
      "zabrat",
      "zabydlet",
      "zachovat",
      "zadarmo",
      "zadusit",
      "zafoukat",
      "zahltit",
      "zahodit",
      "zahrada",
      "zahynout",
      "zajatec",
      "zajet",
      "zajistit",
      "zaklepat",
      "zakoupit",
      "zalepit",
      "zamezit",
      "zamotat",
      "zamyslet",
      "zanechat",
      "zanikat",
      "zaplatit",
      "zapojit",
      "zapsat",
      "zarazit",
      "zastavit",
      "zasunout",
      "zatajit",
      "zatemnit",
      "zatknout",
      "zaujmout",
      "zavalit",
      "zavelet",
      "zavinit",
      "zavolat",
      "zavrtat",
      "zazvonit",
      "zbavit",
      "zbrusu",
      "zbudovat",
      "zbytek",
      "zdaleka",
      "zdarma",
      "zdatnost",
      "zdivo",
      "zdobit",
      "zdroj",
      "zdvih",
      "zdymadlo",
      "zelenina",
      "zeman",
      "zemina",
      "zeptat",
      "zezadu",
      "zezdola",
      "zhatit",
      "zhltnout",
      "zhluboka",
      "zhotovit",
      "zhruba",
      "zima",
      "zimnice",
      "zjemnit",
      "zklamat",
      "zkoumat",
      "zkratka",
      "zkumavka",
      "zlato",
      "zlehka",
      "zloba",
      "zlom",
      "zlost",
      "zlozvyk",
      "zmapovat",
      "zmar",
      "zmatek",
      "zmije",
      "zmizet",
      "zmocnit",
      "zmodrat",
      "zmrzlina",
      "zmutovat",
      "znak",
      "znalost",
      "znamenat",
      "znovu",
      "zobrazit",
      "zotavit",
      "zoubek",
      "zoufale",
      "zplodit",
      "zpomalit",
      "zprava",
      "zprostit",
      "zprudka",
      "zprvu",
      "zrada",
      "zranit",
      "zrcadlo",
      "zrnitost",
      "zrno",
      "zrovna",
      "zrychlit",
      "zrzavost",
      "zticha",
      "ztratit",
      "zubovina",
      "zubr",
      "zvednout",
      "zvenku",
      "zvesela",
      "zvon",
      "zvrat",
      "zvukovod",
      "zvyk"
    ];
  }
});

// node_modules/bip39/src/wordlists/chinese_simplified.json
var require_chinese_simplified = __commonJS({
  "node_modules/bip39/src/wordlists/chinese_simplified.json"(exports2, module2) {
    module2.exports = [
      "\u7684",
      "\u4E00",
      "\u662F",
      "\u5728",
      "\u4E0D",
      "\u4E86",
      "\u6709",
      "\u548C",
      "\u4EBA",
      "\u8FD9",
      "\u4E2D",
      "\u5927",
      "\u4E3A",
      "\u4E0A",
      "\u4E2A",
      "\u56FD",
      "\u6211",
      "\u4EE5",
      "\u8981",
      "\u4ED6",
      "\u65F6",
      "\u6765",
      "\u7528",
      "\u4EEC",
      "\u751F",
      "\u5230",
      "\u4F5C",
      "\u5730",
      "\u4E8E",
      "\u51FA",
      "\u5C31",
      "\u5206",
      "\u5BF9",
      "\u6210",
      "\u4F1A",
      "\u53EF",
      "\u4E3B",
      "\u53D1",
      "\u5E74",
      "\u52A8",
      "\u540C",
      "\u5DE5",
      "\u4E5F",
      "\u80FD",
      "\u4E0B",
      "\u8FC7",
      "\u5B50",
      "\u8BF4",
      "\u4EA7",
      "\u79CD",
      "\u9762",
      "\u800C",
      "\u65B9",
      "\u540E",
      "\u591A",
      "\u5B9A",
      "\u884C",
      "\u5B66",
      "\u6CD5",
      "\u6240",
      "\u6C11",
      "\u5F97",
      "\u7ECF",
      "\u5341",
      "\u4E09",
      "\u4E4B",
      "\u8FDB",
      "\u7740",
      "\u7B49",
      "\u90E8",
      "\u5EA6",
      "\u5BB6",
      "\u7535",
      "\u529B",
      "\u91CC",
      "\u5982",
      "\u6C34",
      "\u5316",
      "\u9AD8",
      "\u81EA",
      "\u4E8C",
      "\u7406",
      "\u8D77",
      "\u5C0F",
      "\u7269",
      "\u73B0",
      "\u5B9E",
      "\u52A0",
      "\u91CF",
      "\u90FD",
      "\u4E24",
      "\u4F53",
      "\u5236",
      "\u673A",
      "\u5F53",
      "\u4F7F",
      "\u70B9",
      "\u4ECE",
      "\u4E1A",
      "\u672C",
      "\u53BB",
      "\u628A",
      "\u6027",
      "\u597D",
      "\u5E94",
      "\u5F00",
      "\u5B83",
      "\u5408",
      "\u8FD8",
      "\u56E0",
      "\u7531",
      "\u5176",
      "\u4E9B",
      "\u7136",
      "\u524D",
      "\u5916",
      "\u5929",
      "\u653F",
      "\u56DB",
      "\u65E5",
      "\u90A3",
      "\u793E",
      "\u4E49",
      "\u4E8B",
      "\u5E73",
      "\u5F62",
      "\u76F8",
      "\u5168",
      "\u8868",
      "\u95F4",
      "\u6837",
      "\u4E0E",
      "\u5173",
      "\u5404",
      "\u91CD",
      "\u65B0",
      "\u7EBF",
      "\u5185",
      "\u6570",
      "\u6B63",
      "\u5FC3",
      "\u53CD",
      "\u4F60",
      "\u660E",
      "\u770B",
      "\u539F",
      "\u53C8",
      "\u4E48",
      "\u5229",
      "\u6BD4",
      "\u6216",
      "\u4F46",
      "\u8D28",
      "\u6C14",
      "\u7B2C",
      "\u5411",
      "\u9053",
      "\u547D",
      "\u6B64",
      "\u53D8",
      "\u6761",
      "\u53EA",
      "\u6CA1",
      "\u7ED3",
      "\u89E3",
      "\u95EE",
      "\u610F",
      "\u5EFA",
      "\u6708",
      "\u516C",
      "\u65E0",
      "\u7CFB",
      "\u519B",
      "\u5F88",
      "\u60C5",
      "\u8005",
      "\u6700",
      "\u7ACB",
      "\u4EE3",
      "\u60F3",
      "\u5DF2",
      "\u901A",
      "\u5E76",
      "\u63D0",
      "\u76F4",
      "\u9898",
      "\u515A",
      "\u7A0B",
      "\u5C55",
      "\u4E94",
      "\u679C",
      "\u6599",
      "\u8C61",
      "\u5458",
      "\u9769",
      "\u4F4D",
      "\u5165",
      "\u5E38",
      "\u6587",
      "\u603B",
      "\u6B21",
      "\u54C1",
      "\u5F0F",
      "\u6D3B",
      "\u8BBE",
      "\u53CA",
      "\u7BA1",
      "\u7279",
      "\u4EF6",
      "\u957F",
      "\u6C42",
      "\u8001",
      "\u5934",
      "\u57FA",
      "\u8D44",
      "\u8FB9",
      "\u6D41",
      "\u8DEF",
      "\u7EA7",
      "\u5C11",
      "\u56FE",
      "\u5C71",
      "\u7EDF",
      "\u63A5",
      "\u77E5",
      "\u8F83",
      "\u5C06",
      "\u7EC4",
      "\u89C1",
      "\u8BA1",
      "\u522B",
      "\u5979",
      "\u624B",
      "\u89D2",
      "\u671F",
      "\u6839",
      "\u8BBA",
      "\u8FD0",
      "\u519C",
      "\u6307",
      "\u51E0",
      "\u4E5D",
      "\u533A",
      "\u5F3A",
      "\u653E",
      "\u51B3",
      "\u897F",
      "\u88AB",
      "\u5E72",
      "\u505A",
      "\u5FC5",
      "\u6218",
      "\u5148",
      "\u56DE",
      "\u5219",
      "\u4EFB",
      "\u53D6",
      "\u636E",
      "\u5904",
      "\u961F",
      "\u5357",
      "\u7ED9",
      "\u8272",
      "\u5149",
      "\u95E8",
      "\u5373",
      "\u4FDD",
      "\u6CBB",
      "\u5317",
      "\u9020",
      "\u767E",
      "\u89C4",
      "\u70ED",
      "\u9886",
      "\u4E03",
      "\u6D77",
      "\u53E3",
      "\u4E1C",
      "\u5BFC",
      "\u5668",
      "\u538B",
      "\u5FD7",
      "\u4E16",
      "\u91D1",
      "\u589E",
      "\u4E89",
      "\u6D4E",
      "\u9636",
      "\u6CB9",
      "\u601D",
      "\u672F",
      "\u6781",
      "\u4EA4",
      "\u53D7",
      "\u8054",
      "\u4EC0",
      "\u8BA4",
      "\u516D",
      "\u5171",
      "\u6743",
      "\u6536",
      "\u8BC1",
      "\u6539",
      "\u6E05",
      "\u7F8E",
      "\u518D",
      "\u91C7",
      "\u8F6C",
      "\u66F4",
      "\u5355",
      "\u98CE",
      "\u5207",
      "\u6253",
      "\u767D",
      "\u6559",
      "\u901F",
      "\u82B1",
      "\u5E26",
      "\u5B89",
      "\u573A",
      "\u8EAB",
      "\u8F66",
      "\u4F8B",
      "\u771F",
      "\u52A1",
      "\u5177",
      "\u4E07",
      "\u6BCF",
      "\u76EE",
      "\u81F3",
      "\u8FBE",
      "\u8D70",
      "\u79EF",
      "\u793A",
      "\u8BAE",
      "\u58F0",
      "\u62A5",
      "\u6597",
      "\u5B8C",
      "\u7C7B",
      "\u516B",
      "\u79BB",
      "\u534E",
      "\u540D",
      "\u786E",
      "\u624D",
      "\u79D1",
      "\u5F20",
      "\u4FE1",
      "\u9A6C",
      "\u8282",
      "\u8BDD",
      "\u7C73",
      "\u6574",
      "\u7A7A",
      "\u5143",
      "\u51B5",
      "\u4ECA",
      "\u96C6",
      "\u6E29",
      "\u4F20",
      "\u571F",
      "\u8BB8",
      "\u6B65",
      "\u7FA4",
      "\u5E7F",
      "\u77F3",
      "\u8BB0",
      "\u9700",
      "\u6BB5",
      "\u7814",
      "\u754C",
      "\u62C9",
      "\u6797",
      "\u5F8B",
      "\u53EB",
      "\u4E14",
      "\u7A76",
      "\u89C2",
      "\u8D8A",
      "\u7EC7",
      "\u88C5",
      "\u5F71",
      "\u7B97",
      "\u4F4E",
      "\u6301",
      "\u97F3",
      "\u4F17",
      "\u4E66",
      "\u5E03",
      "\u590D",
      "\u5BB9",
      "\u513F",
      "\u987B",
      "\u9645",
      "\u5546",
      "\u975E",
      "\u9A8C",
      "\u8FDE",
      "\u65AD",
      "\u6DF1",
      "\u96BE",
      "\u8FD1",
      "\u77FF",
      "\u5343",
      "\u5468",
      "\u59D4",
      "\u7D20",
      "\u6280",
      "\u5907",
      "\u534A",
      "\u529E",
      "\u9752",
      "\u7701",
      "\u5217",
      "\u4E60",
      "\u54CD",
      "\u7EA6",
      "\u652F",
      "\u822C",
      "\u53F2",
      "\u611F",
      "\u52B3",
      "\u4FBF",
      "\u56E2",
      "\u5F80",
      "\u9178",
      "\u5386",
      "\u5E02",
      "\u514B",
      "\u4F55",
      "\u9664",
      "\u6D88",
      "\u6784",
      "\u5E9C",
      "\u79F0",
      "\u592A",
      "\u51C6",
      "\u7CBE",
      "\u503C",
      "\u53F7",
      "\u7387",
      "\u65CF",
      "\u7EF4",
      "\u5212",
      "\u9009",
      "\u6807",
      "\u5199",
      "\u5B58",
      "\u5019",
      "\u6BDB",
      "\u4EB2",
      "\u5FEB",
      "\u6548",
      "\u65AF",
      "\u9662",
      "\u67E5",
      "\u6C5F",
      "\u578B",
      "\u773C",
      "\u738B",
      "\u6309",
      "\u683C",
      "\u517B",
      "\u6613",
      "\u7F6E",
      "\u6D3E",
      "\u5C42",
      "\u7247",
      "\u59CB",
      "\u5374",
      "\u4E13",
      "\u72B6",
      "\u80B2",
      "\u5382",
      "\u4EAC",
      "\u8BC6",
      "\u9002",
      "\u5C5E",
      "\u5706",
      "\u5305",
      "\u706B",
      "\u4F4F",
      "\u8C03",
      "\u6EE1",
      "\u53BF",
      "\u5C40",
      "\u7167",
      "\u53C2",
      "\u7EA2",
      "\u7EC6",
      "\u5F15",
      "\u542C",
      "\u8BE5",
      "\u94C1",
      "\u4EF7",
      "\u4E25",
      "\u9996",
      "\u5E95",
      "\u6DB2",
      "\u5B98",
      "\u5FB7",
      "\u968F",
      "\u75C5",
      "\u82CF",
      "\u5931",
      "\u5C14",
      "\u6B7B",
      "\u8BB2",
      "\u914D",
      "\u5973",
      "\u9EC4",
      "\u63A8",
      "\u663E",
      "\u8C08",
      "\u7F6A",
      "\u795E",
      "\u827A",
      "\u5462",
      "\u5E2D",
      "\u542B",
      "\u4F01",
      "\u671B",
      "\u5BC6",
      "\u6279",
      "\u8425",
      "\u9879",
      "\u9632",
      "\u4E3E",
      "\u7403",
      "\u82F1",
      "\u6C27",
      "\u52BF",
      "\u544A",
      "\u674E",
      "\u53F0",
      "\u843D",
      "\u6728",
      "\u5E2E",
      "\u8F6E",
      "\u7834",
      "\u4E9A",
      "\u5E08",
      "\u56F4",
      "\u6CE8",
      "\u8FDC",
      "\u5B57",
      "\u6750",
      "\u6392",
      "\u4F9B",
      "\u6CB3",
      "\u6001",
      "\u5C01",
      "\u53E6",
      "\u65BD",
      "\u51CF",
      "\u6811",
      "\u6EB6",
      "\u600E",
      "\u6B62",
      "\u6848",
      "\u8A00",
      "\u58EB",
      "\u5747",
      "\u6B66",
      "\u56FA",
      "\u53F6",
      "\u9C7C",
      "\u6CE2",
      "\u89C6",
      "\u4EC5",
      "\u8D39",
      "\u7D27",
      "\u7231",
      "\u5DE6",
      "\u7AE0",
      "\u65E9",
      "\u671D",
      "\u5BB3",
      "\u7EED",
      "\u8F7B",
      "\u670D",
      "\u8BD5",
      "\u98DF",
      "\u5145",
      "\u5175",
      "\u6E90",
      "\u5224",
      "\u62A4",
      "\u53F8",
      "\u8DB3",
      "\u67D0",
      "\u7EC3",
      "\u5DEE",
      "\u81F4",
      "\u677F",
      "\u7530",
      "\u964D",
      "\u9ED1",
      "\u72AF",
      "\u8D1F",
      "\u51FB",
      "\u8303",
      "\u7EE7",
      "\u5174",
      "\u4F3C",
      "\u4F59",
      "\u575A",
      "\u66F2",
      "\u8F93",
      "\u4FEE",
      "\u6545",
      "\u57CE",
      "\u592B",
      "\u591F",
      "\u9001",
      "\u7B14",
      "\u8239",
      "\u5360",
      "\u53F3",
      "\u8D22",
      "\u5403",
      "\u5BCC",
      "\u6625",
      "\u804C",
      "\u89C9",
      "\u6C49",
      "\u753B",
      "\u529F",
      "\u5DF4",
      "\u8DDF",
      "\u867D",
      "\u6742",
      "\u98DE",
      "\u68C0",
      "\u5438",
      "\u52A9",
      "\u5347",
      "\u9633",
      "\u4E92",
      "\u521D",
      "\u521B",
      "\u6297",
      "\u8003",
      "\u6295",
      "\u574F",
      "\u7B56",
      "\u53E4",
      "\u5F84",
      "\u6362",
      "\u672A",
      "\u8DD1",
      "\u7559",
      "\u94A2",
      "\u66FE",
      "\u7AEF",
      "\u8D23",
      "\u7AD9",
      "\u7B80",
      "\u8FF0",
      "\u94B1",
      "\u526F",
      "\u5C3D",
      "\u5E1D",
      "\u5C04",
      "\u8349",
      "\u51B2",
      "\u627F",
      "\u72EC",
      "\u4EE4",
      "\u9650",
      "\u963F",
      "\u5BA3",
      "\u73AF",
      "\u53CC",
      "\u8BF7",
      "\u8D85",
      "\u5FAE",
      "\u8BA9",
      "\u63A7",
      "\u5DDE",
      "\u826F",
      "\u8F74",
      "\u627E",
      "\u5426",
      "\u7EAA",
      "\u76CA",
      "\u4F9D",
      "\u4F18",
      "\u9876",
      "\u7840",
      "\u8F7D",
      "\u5012",
      "\u623F",
      "\u7A81",
      "\u5750",
      "\u7C89",
      "\u654C",
      "\u7565",
      "\u5BA2",
      "\u8881",
      "\u51B7",
      "\u80DC",
      "\u7EDD",
      "\u6790",
      "\u5757",
      "\u5242",
      "\u6D4B",
      "\u4E1D",
      "\u534F",
      "\u8BC9",
      "\u5FF5",
      "\u9648",
      "\u4ECD",
      "\u7F57",
      "\u76D0",
      "\u53CB",
      "\u6D0B",
      "\u9519",
      "\u82E6",
      "\u591C",
      "\u5211",
      "\u79FB",
      "\u9891",
      "\u9010",
      "\u9760",
      "\u6DF7",
      "\u6BCD",
      "\u77ED",
      "\u76AE",
      "\u7EC8",
      "\u805A",
      "\u6C7D",
      "\u6751",
      "\u4E91",
      "\u54EA",
      "\u65E2",
      "\u8DDD",
      "\u536B",
      "\u505C",
      "\u70C8",
      "\u592E",
      "\u5BDF",
      "\u70E7",
      "\u8FC5",
      "\u5883",
      "\u82E5",
      "\u5370",
      "\u6D32",
      "\u523B",
      "\u62EC",
      "\u6FC0",
      "\u5B54",
      "\u641E",
      "\u751A",
      "\u5BA4",
      "\u5F85",
      "\u6838",
      "\u6821",
      "\u6563",
      "\u4FB5",
      "\u5427",
      "\u7532",
      "\u6E38",
      "\u4E45",
      "\u83DC",
      "\u5473",
      "\u65E7",
      "\u6A21",
      "\u6E56",
      "\u8D27",
      "\u635F",
      "\u9884",
      "\u963B",
      "\u6BEB",
      "\u666E",
      "\u7A33",
      "\u4E59",
      "\u5988",
      "\u690D",
      "\u606F",
      "\u6269",
      "\u94F6",
      "\u8BED",
      "\u6325",
      "\u9152",
      "\u5B88",
      "\u62FF",
      "\u5E8F",
      "\u7EB8",
      "\u533B",
      "\u7F3A",
      "\u96E8",
      "\u5417",
      "\u9488",
      "\u5218",
      "\u554A",
      "\u6025",
      "\u5531",
      "\u8BEF",
      "\u8BAD",
      "\u613F",
      "\u5BA1",
      "\u9644",
      "\u83B7",
      "\u8336",
      "\u9C9C",
      "\u7CAE",
      "\u65A4",
      "\u5B69",
      "\u8131",
      "\u786B",
      "\u80A5",
      "\u5584",
      "\u9F99",
      "\u6F14",
      "\u7236",
      "\u6E10",
      "\u8840",
      "\u6B22",
      "\u68B0",
      "\u638C",
      "\u6B4C",
      "\u6C99",
      "\u521A",
      "\u653B",
      "\u8C13",
      "\u76FE",
      "\u8BA8",
      "\u665A",
      "\u7C92",
      "\u4E71",
      "\u71C3",
      "\u77DB",
      "\u4E4E",
      "\u6740",
      "\u836F",
      "\u5B81",
      "\u9C81",
      "\u8D35",
      "\u949F",
      "\u7164",
      "\u8BFB",
      "\u73ED",
      "\u4F2F",
      "\u9999",
      "\u4ECB",
      "\u8FEB",
      "\u53E5",
      "\u4E30",
      "\u57F9",
      "\u63E1",
      "\u5170",
      "\u62C5",
      "\u5F26",
      "\u86CB",
      "\u6C89",
      "\u5047",
      "\u7A7F",
      "\u6267",
      "\u7B54",
      "\u4E50",
      "\u8C01",
      "\u987A",
      "\u70DF",
      "\u7F29",
      "\u5F81",
      "\u8138",
      "\u559C",
      "\u677E",
      "\u811A",
      "\u56F0",
      "\u5F02",
      "\u514D",
      "\u80CC",
      "\u661F",
      "\u798F",
      "\u4E70",
      "\u67D3",
      "\u4E95",
      "\u6982",
      "\u6162",
      "\u6015",
      "\u78C1",
      "\u500D",
      "\u7956",
      "\u7687",
      "\u4FC3",
      "\u9759",
      "\u8865",
      "\u8BC4",
      "\u7FFB",
      "\u8089",
      "\u8DF5",
      "\u5C3C",
      "\u8863",
      "\u5BBD",
      "\u626C",
      "\u68C9",
      "\u5E0C",
      "\u4F24",
      "\u64CD",
      "\u5782",
      "\u79CB",
      "\u5B9C",
      "\u6C22",
      "\u5957",
      "\u7763",
      "\u632F",
      "\u67B6",
      "\u4EAE",
      "\u672B",
      "\u5BAA",
      "\u5E86",
      "\u7F16",
      "\u725B",
      "\u89E6",
      "\u6620",
      "\u96F7",
      "\u9500",
      "\u8BD7",
      "\u5EA7",
      "\u5C45",
      "\u6293",
      "\u88C2",
      "\u80DE",
      "\u547C",
      "\u5A18",
      "\u666F",
      "\u5A01",
      "\u7EFF",
      "\u6676",
      "\u539A",
      "\u76DF",
      "\u8861",
      "\u9E21",
      "\u5B59",
      "\u5EF6",
      "\u5371",
      "\u80F6",
      "\u5C4B",
      "\u4E61",
      "\u4E34",
      "\u9646",
      "\u987E",
      "\u6389",
      "\u5440",
      "\u706F",
      "\u5C81",
      "\u63AA",
      "\u675F",
      "\u8010",
      "\u5267",
      "\u7389",
      "\u8D75",
      "\u8DF3",
      "\u54E5",
      "\u5B63",
      "\u8BFE",
      "\u51EF",
      "\u80E1",
      "\u989D",
      "\u6B3E",
      "\u7ECD",
      "\u5377",
      "\u9F50",
      "\u4F1F",
      "\u84B8",
      "\u6B96",
      "\u6C38",
      "\u5B97",
      "\u82D7",
      "\u5DDD",
      "\u7089",
      "\u5CA9",
      "\u5F31",
      "\u96F6",
      "\u6768",
      "\u594F",
      "\u6CBF",
      "\u9732",
      "\u6746",
      "\u63A2",
      "\u6ED1",
      "\u9547",
      "\u996D",
      "\u6D53",
      "\u822A",
      "\u6000",
      "\u8D76",
      "\u5E93",
      "\u593A",
      "\u4F0A",
      "\u7075",
      "\u7A0E",
      "\u9014",
      "\u706D",
      "\u8D5B",
      "\u5F52",
      "\u53EC",
      "\u9F13",
      "\u64AD",
      "\u76D8",
      "\u88C1",
      "\u9669",
      "\u5EB7",
      "\u552F",
      "\u5F55",
      "\u83CC",
      "\u7EAF",
      "\u501F",
      "\u7CD6",
      "\u76D6",
      "\u6A2A",
      "\u7B26",
      "\u79C1",
      "\u52AA",
      "\u5802",
      "\u57DF",
      "\u67AA",
      "\u6DA6",
      "\u5E45",
      "\u54C8",
      "\u7ADF",
      "\u719F",
      "\u866B",
      "\u6CFD",
      "\u8111",
      "\u58E4",
      "\u78B3",
      "\u6B27",
      "\u904D",
      "\u4FA7",
      "\u5BE8",
      "\u6562",
      "\u5F7B",
      "\u8651",
      "\u659C",
      "\u8584",
      "\u5EAD",
      "\u7EB3",
      "\u5F39",
      "\u9972",
      "\u4F38",
      "\u6298",
      "\u9EA6",
      "\u6E7F",
      "\u6697",
      "\u8377",
      "\u74E6",
      "\u585E",
      "\u5E8A",
      "\u7B51",
      "\u6076",
      "\u6237",
      "\u8BBF",
      "\u5854",
      "\u5947",
      "\u900F",
      "\u6881",
      "\u5200",
      "\u65CB",
      "\u8FF9",
      "\u5361",
      "\u6C2F",
      "\u9047",
      "\u4EFD",
      "\u6BD2",
      "\u6CE5",
      "\u9000",
      "\u6D17",
      "\u6446",
      "\u7070",
      "\u5F69",
      "\u5356",
      "\u8017",
      "\u590F",
      "\u62E9",
      "\u5FD9",
      "\u94DC",
      "\u732E",
      "\u786C",
      "\u4E88",
      "\u7E41",
      "\u5708",
      "\u96EA",
      "\u51FD",
      "\u4EA6",
      "\u62BD",
      "\u7BC7",
      "\u9635",
      "\u9634",
      "\u4E01",
      "\u5C3A",
      "\u8FFD",
      "\u5806",
      "\u96C4",
      "\u8FCE",
      "\u6CDB",
      "\u7238",
      "\u697C",
      "\u907F",
      "\u8C0B",
      "\u5428",
      "\u91CE",
      "\u732A",
      "\u65D7",
      "\u7D2F",
      "\u504F",
      "\u5178",
      "\u9986",
      "\u7D22",
      "\u79E6",
      "\u8102",
      "\u6F6E",
      "\u7237",
      "\u8C46",
      "\u5FFD",
      "\u6258",
      "\u60CA",
      "\u5851",
      "\u9057",
      "\u6108",
      "\u6731",
      "\u66FF",
      "\u7EA4",
      "\u7C97",
      "\u503E",
      "\u5C1A",
      "\u75DB",
      "\u695A",
      "\u8C22",
      "\u594B",
      "\u8D2D",
      "\u78E8",
      "\u541B",
      "\u6C60",
      "\u65C1",
      "\u788E",
      "\u9AA8",
      "\u76D1",
      "\u6355",
      "\u5F1F",
      "\u66B4",
      "\u5272",
      "\u8D2F",
      "\u6B8A",
      "\u91CA",
      "\u8BCD",
      "\u4EA1",
      "\u58C1",
      "\u987F",
      "\u5B9D",
      "\u5348",
      "\u5C18",
      "\u95FB",
      "\u63ED",
      "\u70AE",
      "\u6B8B",
      "\u51AC",
      "\u6865",
      "\u5987",
      "\u8B66",
      "\u7EFC",
      "\u62DB",
      "\u5434",
      "\u4ED8",
      "\u6D6E",
      "\u906D",
      "\u5F90",
      "\u60A8",
      "\u6447",
      "\u8C37",
      "\u8D5E",
      "\u7BB1",
      "\u9694",
      "\u8BA2",
      "\u7537",
      "\u5439",
      "\u56ED",
      "\u7EB7",
      "\u5510",
      "\u8D25",
      "\u5B8B",
      "\u73BB",
      "\u5DE8",
      "\u8015",
      "\u5766",
      "\u8363",
      "\u95ED",
      "\u6E7E",
      "\u952E",
      "\u51E1",
      "\u9A7B",
      "\u9505",
      "\u6551",
      "\u6069",
      "\u5265",
      "\u51DD",
      "\u78B1",
      "\u9F7F",
      "\u622A",
      "\u70BC",
      "\u9EBB",
      "\u7EBA",
      "\u7981",
      "\u5E9F",
      "\u76DB",
      "\u7248",
      "\u7F13",
      "\u51C0",
      "\u775B",
      "\u660C",
      "\u5A5A",
      "\u6D89",
      "\u7B52",
      "\u5634",
      "\u63D2",
      "\u5CB8",
      "\u6717",
      "\u5E84",
      "\u8857",
      "\u85CF",
      "\u59D1",
      "\u8D38",
      "\u8150",
      "\u5974",
      "\u5566",
      "\u60EF",
      "\u4E58",
      "\u4F19",
      "\u6062",
      "\u5300",
      "\u7EB1",
      "\u624E",
      "\u8FA9",
      "\u8033",
      "\u5F6A",
      "\u81E3",
      "\u4EBF",
      "\u7483",
      "\u62B5",
      "\u8109",
      "\u79C0",
      "\u8428",
      "\u4FC4",
      "\u7F51",
      "\u821E",
      "\u5E97",
      "\u55B7",
      "\u7EB5",
      "\u5BF8",
      "\u6C57",
      "\u6302",
      "\u6D2A",
      "\u8D3A",
      "\u95EA",
      "\u67EC",
      "\u7206",
      "\u70EF",
      "\u6D25",
      "\u7A3B",
      "\u5899",
      "\u8F6F",
      "\u52C7",
      "\u50CF",
      "\u6EDA",
      "\u5398",
      "\u8499",
      "\u82B3",
      "\u80AF",
      "\u5761",
      "\u67F1",
      "\u8361",
      "\u817F",
      "\u4EEA",
      "\u65C5",
      "\u5C3E",
      "\u8F67",
      "\u51B0",
      "\u8D21",
      "\u767B",
      "\u9ECE",
      "\u524A",
      "\u94BB",
      "\u52D2",
      "\u9003",
      "\u969C",
      "\u6C28",
      "\u90ED",
      "\u5CF0",
      "\u5E01",
      "\u6E2F",
      "\u4F0F",
      "\u8F68",
      "\u4EA9",
      "\u6BD5",
      "\u64E6",
      "\u83AB",
      "\u523A",
      "\u6D6A",
      "\u79D8",
      "\u63F4",
      "\u682A",
      "\u5065",
      "\u552E",
      "\u80A1",
      "\u5C9B",
      "\u7518",
      "\u6CE1",
      "\u7761",
      "\u7AE5",
      "\u94F8",
      "\u6C64",
      "\u9600",
      "\u4F11",
      "\u6C47",
      "\u820D",
      "\u7267",
      "\u7ED5",
      "\u70B8",
      "\u54F2",
      "\u78F7",
      "\u7EE9",
      "\u670B",
      "\u6DE1",
      "\u5C16",
      "\u542F",
      "\u9677",
      "\u67F4",
      "\u5448",
      "\u5F92",
      "\u989C",
      "\u6CEA",
      "\u7A0D",
      "\u5FD8",
      "\u6CF5",
      "\u84DD",
      "\u62D6",
      "\u6D1E",
      "\u6388",
      "\u955C",
      "\u8F9B",
      "\u58EE",
      "\u950B",
      "\u8D2B",
      "\u865A",
      "\u5F2F",
      "\u6469",
      "\u6CF0",
      "\u5E7C",
      "\u5EF7",
      "\u5C0A",
      "\u7A97",
      "\u7EB2",
      "\u5F04",
      "\u96B6",
      "\u7591",
      "\u6C0F",
      "\u5BAB",
      "\u59D0",
      "\u9707",
      "\u745E",
      "\u602A",
      "\u5C24",
      "\u7434",
      "\u5FAA",
      "\u63CF",
      "\u819C",
      "\u8FDD",
      "\u5939",
      "\u8170",
      "\u7F18",
      "\u73E0",
      "\u7A77",
      "\u68EE",
      "\u679D",
      "\u7AF9",
      "\u6C9F",
      "\u50AC",
      "\u7EF3",
      "\u5FC6",
      "\u90A6",
      "\u5269",
      "\u5E78",
      "\u6D46",
      "\u680F",
      "\u62E5",
      "\u7259",
      "\u8D2E",
      "\u793C",
      "\u6EE4",
      "\u94A0",
      "\u7EB9",
      "\u7F62",
      "\u62CD",
      "\u54B1",
      "\u558A",
      "\u8896",
      "\u57C3",
      "\u52E4",
      "\u7F5A",
      "\u7126",
      "\u6F5C",
      "\u4F0D",
      "\u58A8",
      "\u6B32",
      "\u7F1D",
      "\u59D3",
      "\u520A",
      "\u9971",
      "\u4EFF",
      "\u5956",
      "\u94DD",
      "\u9B3C",
      "\u4E3D",
      "\u8DE8",
      "\u9ED8",
      "\u6316",
      "\u94FE",
      "\u626B",
      "\u559D",
      "\u888B",
      "\u70AD",
      "\u6C61",
      "\u5E55",
      "\u8BF8",
      "\u5F27",
      "\u52B1",
      "\u6885",
      "\u5976",
      "\u6D01",
      "\u707E",
      "\u821F",
      "\u9274",
      "\u82EF",
      "\u8BBC",
      "\u62B1",
      "\u6BC1",
      "\u61C2",
      "\u5BD2",
      "\u667A",
      "\u57D4",
      "\u5BC4",
      "\u5C4A",
      "\u8DC3",
      "\u6E21",
      "\u6311",
      "\u4E39",
      "\u8270",
      "\u8D1D",
      "\u78B0",
      "\u62D4",
      "\u7239",
      "\u6234",
      "\u7801",
      "\u68A6",
      "\u82BD",
      "\u7194",
      "\u8D64",
      "\u6E14",
      "\u54ED",
      "\u656C",
      "\u9897",
      "\u5954",
      "\u94C5",
      "\u4EF2",
      "\u864E",
      "\u7A00",
      "\u59B9",
      "\u4E4F",
      "\u73CD",
      "\u7533",
      "\u684C",
      "\u9075",
      "\u5141",
      "\u9686",
      "\u87BA",
      "\u4ED3",
      "\u9B4F",
      "\u9510",
      "\u6653",
      "\u6C2E",
      "\u517C",
      "\u9690",
      "\u788D",
      "\u8D6B",
      "\u62E8",
      "\u5FE0",
      "\u8083",
      "\u7F38",
      "\u7275",
      "\u62A2",
      "\u535A",
      "\u5DE7",
      "\u58F3",
      "\u5144",
      "\u675C",
      "\u8BAF",
      "\u8BDA",
      "\u78A7",
      "\u7965",
      "\u67EF",
      "\u9875",
      "\u5DE1",
      "\u77E9",
      "\u60B2",
      "\u704C",
      "\u9F84",
      "\u4F26",
      "\u7968",
      "\u5BFB",
      "\u6842",
      "\u94FA",
      "\u5723",
      "\u6050",
      "\u6070",
      "\u90D1",
      "\u8DA3",
      "\u62AC",
      "\u8352",
      "\u817E",
      "\u8D34",
      "\u67D4",
      "\u6EF4",
      "\u731B",
      "\u9614",
      "\u8F86",
      "\u59BB",
      "\u586B",
      "\u64A4",
      "\u50A8",
      "\u7B7E",
      "\u95F9",
      "\u6270",
      "\u7D2B",
      "\u7802",
      "\u9012",
      "\u620F",
      "\u540A",
      "\u9676",
      "\u4F10",
      "\u5582",
      "\u7597",
      "\u74F6",
      "\u5A46",
      "\u629A",
      "\u81C2",
      "\u6478",
      "\u5FCD",
      "\u867E",
      "\u8721",
      "\u90BB",
      "\u80F8",
      "\u5DE9",
      "\u6324",
      "\u5076",
      "\u5F03",
      "\u69FD",
      "\u52B2",
      "\u4E73",
      "\u9093",
      "\u5409",
      "\u4EC1",
      "\u70C2",
      "\u7816",
      "\u79DF",
      "\u4E4C",
      "\u8230",
      "\u4F34",
      "\u74DC",
      "\u6D45",
      "\u4E19",
      "\u6682",
      "\u71E5",
      "\u6A61",
      "\u67F3",
      "\u8FF7",
      "\u6696",
      "\u724C",
      "\u79E7",
      "\u80C6",
      "\u8BE6",
      "\u7C27",
      "\u8E0F",
      "\u74F7",
      "\u8C31",
      "\u5446",
      "\u5BBE",
      "\u7CCA",
      "\u6D1B",
      "\u8F89",
      "\u6124",
      "\u7ADE",
      "\u9699",
      "\u6012",
      "\u7C98",
      "\u4E43",
      "\u7EEA",
      "\u80A9",
      "\u7C4D",
      "\u654F",
      "\u6D82",
      "\u7199",
      "\u7686",
      "\u4FA6",
      "\u60AC",
      "\u6398",
      "\u4EAB",
      "\u7EA0",
      "\u9192",
      "\u72C2",
      "\u9501",
      "\u6DC0",
      "\u6068",
      "\u7272",
      "\u9738",
      "\u722C",
      "\u8D4F",
      "\u9006",
      "\u73A9",
      "\u9675",
      "\u795D",
      "\u79D2",
      "\u6D59",
      "\u8C8C",
      "\u5F79",
      "\u5F7C",
      "\u6089",
      "\u9E2D",
      "\u8D8B",
      "\u51E4",
      "\u6668",
      "\u755C",
      "\u8F88",
      "\u79E9",
      "\u5375",
      "\u7F72",
      "\u68AF",
      "\u708E",
      "\u6EE9",
      "\u68CB",
      "\u9A71",
      "\u7B5B",
      "\u5CE1",
      "\u5192",
      "\u5565",
      "\u5BFF",
      "\u8BD1",
      "\u6D78",
      "\u6CC9",
      "\u5E3D",
      "\u8FDF",
      "\u7845",
      "\u7586",
      "\u8D37",
      "\u6F0F",
      "\u7A3F",
      "\u51A0",
      "\u5AE9",
      "\u80C1",
      "\u82AF",
      "\u7262",
      "\u53DB",
      "\u8680",
      "\u5965",
      "\u9E23",
      "\u5CAD",
      "\u7F8A",
      "\u51ED",
      "\u4E32",
      "\u5858",
      "\u7ED8",
      "\u9175",
      "\u878D",
      "\u76C6",
      "\u9521",
      "\u5E99",
      "\u7B79",
      "\u51BB",
      "\u8F85",
      "\u6444",
      "\u88AD",
      "\u7B4B",
      "\u62D2",
      "\u50DA",
      "\u65F1",
      "\u94BE",
      "\u9E1F",
      "\u6F06",
      "\u6C88",
      "\u7709",
      "\u758F",
      "\u6DFB",
      "\u68D2",
      "\u7A57",
      "\u785D",
      "\u97E9",
      "\u903C",
      "\u626D",
      "\u4FA8",
      "\u51C9",
      "\u633A",
      "\u7897",
      "\u683D",
      "\u7092",
      "\u676F",
      "\u60A3",
      "\u998F",
      "\u529D",
      "\u8C6A",
      "\u8FBD",
      "\u52C3",
      "\u9E3F",
      "\u65E6",
      "\u540F",
      "\u62DC",
      "\u72D7",
      "\u57CB",
      "\u8F8A",
      "\u63A9",
      "\u996E",
      "\u642C",
      "\u9A82",
      "\u8F9E",
      "\u52FE",
      "\u6263",
      "\u4F30",
      "\u848B",
      "\u7ED2",
      "\u96FE",
      "\u4E08",
      "\u6735",
      "\u59C6",
      "\u62DF",
      "\u5B87",
      "\u8F91",
      "\u9655",
      "\u96D5",
      "\u507F",
      "\u84C4",
      "\u5D07",
      "\u526A",
      "\u5021",
      "\u5385",
      "\u54AC",
      "\u9A76",
      "\u85AF",
      "\u5237",
      "\u65A5",
      "\u756A",
      "\u8D4B",
      "\u5949",
      "\u4F5B",
      "\u6D47",
      "\u6F2B",
      "\u66FC",
      "\u6247",
      "\u9499",
      "\u6843",
      "\u6276",
      "\u4ED4",
      "\u8FD4",
      "\u4FD7",
      "\u4E8F",
      "\u8154",
      "\u978B",
      "\u68F1",
      "\u8986",
      "\u6846",
      "\u6084",
      "\u53D4",
      "\u649E",
      "\u9A97",
      "\u52D8",
      "\u65FA",
      "\u6CB8",
      "\u5B64",
      "\u5410",
      "\u5B5F",
      "\u6E20",
      "\u5C48",
      "\u75BE",
      "\u5999",
      "\u60DC",
      "\u4EF0",
      "\u72E0",
      "\u80C0",
      "\u8C10",
      "\u629B",
      "\u9709",
      "\u6851",
      "\u5C97",
      "\u561B",
      "\u8870",
      "\u76D7",
      "\u6E17",
      "\u810F",
      "\u8D56",
      "\u6D8C",
      "\u751C",
      "\u66F9",
      "\u9605",
      "\u808C",
      "\u54E9",
      "\u5389",
      "\u70C3",
      "\u7EAC",
      "\u6BC5",
      "\u6628",
      "\u4F2A",
      "\u75C7",
      "\u716E",
      "\u53F9",
      "\u9489",
      "\u642D",
      "\u830E",
      "\u7B3C",
      "\u9177",
      "\u5077",
      "\u5F13",
      "\u9525",
      "\u6052",
      "\u6770",
      "\u5751",
      "\u9F3B",
      "\u7FFC",
      "\u7EB6",
      "\u53D9",
      "\u72F1",
      "\u902E",
      "\u7F50",
      "\u7EDC",
      "\u68DA",
      "\u6291",
      "\u81A8",
      "\u852C",
      "\u5BFA",
      "\u9AA4",
      "\u7A46",
      "\u51B6",
      "\u67AF",
      "\u518C",
      "\u5C38",
      "\u51F8",
      "\u7EC5",
      "\u576F",
      "\u727A",
      "\u7130",
      "\u8F70",
      "\u6B23",
      "\u664B",
      "\u7626",
      "\u5FA1",
      "\u952D",
      "\u9526",
      "\u4E27",
      "\u65EC",
      "\u953B",
      "\u5784",
      "\u641C",
      "\u6251",
      "\u9080",
      "\u4EAD",
      "\u916F",
      "\u8FC8",
      "\u8212",
      "\u8106",
      "\u9176",
      "\u95F2",
      "\u5FE7",
      "\u915A",
      "\u987D",
      "\u7FBD",
      "\u6DA8",
      "\u5378",
      "\u4ED7",
      "\u966A",
      "\u8F9F",
      "\u60E9",
      "\u676D",
      "\u59DA",
      "\u809A",
      "\u6349",
      "\u98D8",
      "\u6F02",
      "\u6606",
      "\u6B3A",
      "\u543E",
      "\u90CE",
      "\u70F7",
      "\u6C41",
      "\u5475",
      "\u9970",
      "\u8427",
      "\u96C5",
      "\u90AE",
      "\u8FC1",
      "\u71D5",
      "\u6492",
      "\u59FB",
      "\u8D74",
      "\u5BB4",
      "\u70E6",
      "\u503A",
      "\u5E10",
      "\u6591",
      "\u94C3",
      "\u65E8",
      "\u9187",
      "\u8463",
      "\u997C",
      "\u96CF",
      "\u59FF",
      "\u62CC",
      "\u5085",
      "\u8179",
      "\u59A5",
      "\u63C9",
      "\u8D24",
      "\u62C6",
      "\u6B6A",
      "\u8461",
      "\u80FA",
      "\u4E22",
      "\u6D69",
      "\u5FBD",
      "\u6602",
      "\u57AB",
      "\u6321",
      "\u89C8",
      "\u8D2A",
      "\u6170",
      "\u7F34",
      "\u6C6A",
      "\u614C",
      "\u51AF",
      "\u8BFA",
      "\u59DC",
      "\u8C0A",
      "\u51F6",
      "\u52A3",
      "\u8BEC",
      "\u8000",
      "\u660F",
      "\u8EBA",
      "\u76C8",
      "\u9A91",
      "\u4E54",
      "\u6EAA",
      "\u4E1B",
      "\u5362",
      "\u62B9",
      "\u95F7",
      "\u54A8",
      "\u522E",
      "\u9A7E",
      "\u7F06",
      "\u609F",
      "\u6458",
      "\u94D2",
      "\u63B7",
      "\u9887",
      "\u5E7B",
      "\u67C4",
      "\u60E0",
      "\u60E8",
      "\u4F73",
      "\u4EC7",
      "\u814A",
      "\u7A9D",
      "\u6DA4",
      "\u5251",
      "\u77A7",
      "\u5821",
      "\u6CFC",
      "\u8471",
      "\u7F69",
      "\u970D",
      "\u635E",
      "\u80CE",
      "\u82CD",
      "\u6EE8",
      "\u4FE9",
      "\u6345",
      "\u6E58",
      "\u780D",
      "\u971E",
      "\u90B5",
      "\u8404",
      "\u75AF",
      "\u6DEE",
      "\u9042",
      "\u718A",
      "\u7CAA",
      "\u70D8",
      "\u5BBF",
      "\u6863",
      "\u6208",
      "\u9A73",
      "\u5AC2",
      "\u88D5",
      "\u5F99",
      "\u7BAD",
      "\u6350",
      "\u80A0",
      "\u6491",
      "\u6652",
      "\u8FA8",
      "\u6BBF",
      "\u83B2",
      "\u644A",
      "\u6405",
      "\u9171",
      "\u5C4F",
      "\u75AB",
      "\u54C0",
      "\u8521",
      "\u5835",
      "\u6CAB",
      "\u76B1",
      "\u7545",
      "\u53E0",
      "\u9601",
      "\u83B1",
      "\u6572",
      "\u8F96",
      "\u94A9",
      "\u75D5",
      "\u575D",
      "\u5DF7",
      "\u997F",
      "\u7978",
      "\u4E18",
      "\u7384",
      "\u6E9C",
      "\u66F0",
      "\u903B",
      "\u5F6D",
      "\u5C1D",
      "\u537F",
      "\u59A8",
      "\u8247",
      "\u541E",
      "\u97E6",
      "\u6028",
      "\u77EE",
      "\u6B47"
    ];
  }
});

// node_modules/bip39/src/wordlists/chinese_traditional.json
var require_chinese_traditional = __commonJS({
  "node_modules/bip39/src/wordlists/chinese_traditional.json"(exports2, module2) {
    module2.exports = [
      "\u7684",
      "\u4E00",
      "\u662F",
      "\u5728",
      "\u4E0D",
      "\u4E86",
      "\u6709",
      "\u548C",
      "\u4EBA",
      "\u9019",
      "\u4E2D",
      "\u5927",
      "\u70BA",
      "\u4E0A",
      "\u500B",
      "\u570B",
      "\u6211",
      "\u4EE5",
      "\u8981",
      "\u4ED6",
      "\u6642",
      "\u4F86",
      "\u7528",
      "\u5011",
      "\u751F",
      "\u5230",
      "\u4F5C",
      "\u5730",
      "\u65BC",
      "\u51FA",
      "\u5C31",
      "\u5206",
      "\u5C0D",
      "\u6210",
      "\u6703",
      "\u53EF",
      "\u4E3B",
      "\u767C",
      "\u5E74",
      "\u52D5",
      "\u540C",
      "\u5DE5",
      "\u4E5F",
      "\u80FD",
      "\u4E0B",
      "\u904E",
      "\u5B50",
      "\u8AAA",
      "\u7522",
      "\u7A2E",
      "\u9762",
      "\u800C",
      "\u65B9",
      "\u5F8C",
      "\u591A",
      "\u5B9A",
      "\u884C",
      "\u5B78",
      "\u6CD5",
      "\u6240",
      "\u6C11",
      "\u5F97",
      "\u7D93",
      "\u5341",
      "\u4E09",
      "\u4E4B",
      "\u9032",
      "\u8457",
      "\u7B49",
      "\u90E8",
      "\u5EA6",
      "\u5BB6",
      "\u96FB",
      "\u529B",
      "\u88E1",
      "\u5982",
      "\u6C34",
      "\u5316",
      "\u9AD8",
      "\u81EA",
      "\u4E8C",
      "\u7406",
      "\u8D77",
      "\u5C0F",
      "\u7269",
      "\u73FE",
      "\u5BE6",
      "\u52A0",
      "\u91CF",
      "\u90FD",
      "\u5169",
      "\u9AD4",
      "\u5236",
      "\u6A5F",
      "\u7576",
      "\u4F7F",
      "\u9EDE",
      "\u5F9E",
      "\u696D",
      "\u672C",
      "\u53BB",
      "\u628A",
      "\u6027",
      "\u597D",
      "\u61C9",
      "\u958B",
      "\u5B83",
      "\u5408",
      "\u9084",
      "\u56E0",
      "\u7531",
      "\u5176",
      "\u4E9B",
      "\u7136",
      "\u524D",
      "\u5916",
      "\u5929",
      "\u653F",
      "\u56DB",
      "\u65E5",
      "\u90A3",
      "\u793E",
      "\u7FA9",
      "\u4E8B",
      "\u5E73",
      "\u5F62",
      "\u76F8",
      "\u5168",
      "\u8868",
      "\u9593",
      "\u6A23",
      "\u8207",
      "\u95DC",
      "\u5404",
      "\u91CD",
      "\u65B0",
      "\u7DDA",
      "\u5167",
      "\u6578",
      "\u6B63",
      "\u5FC3",
      "\u53CD",
      "\u4F60",
      "\u660E",
      "\u770B",
      "\u539F",
      "\u53C8",
      "\u9EBC",
      "\u5229",
      "\u6BD4",
      "\u6216",
      "\u4F46",
      "\u8CEA",
      "\u6C23",
      "\u7B2C",
      "\u5411",
      "\u9053",
      "\u547D",
      "\u6B64",
      "\u8B8A",
      "\u689D",
      "\u53EA",
      "\u6C92",
      "\u7D50",
      "\u89E3",
      "\u554F",
      "\u610F",
      "\u5EFA",
      "\u6708",
      "\u516C",
      "\u7121",
      "\u7CFB",
      "\u8ECD",
      "\u5F88",
      "\u60C5",
      "\u8005",
      "\u6700",
      "\u7ACB",
      "\u4EE3",
      "\u60F3",
      "\u5DF2",
      "\u901A",
      "\u4E26",
      "\u63D0",
      "\u76F4",
      "\u984C",
      "\u9EE8",
      "\u7A0B",
      "\u5C55",
      "\u4E94",
      "\u679C",
      "\u6599",
      "\u8C61",
      "\u54E1",
      "\u9769",
      "\u4F4D",
      "\u5165",
      "\u5E38",
      "\u6587",
      "\u7E3D",
      "\u6B21",
      "\u54C1",
      "\u5F0F",
      "\u6D3B",
      "\u8A2D",
      "\u53CA",
      "\u7BA1",
      "\u7279",
      "\u4EF6",
      "\u9577",
      "\u6C42",
      "\u8001",
      "\u982D",
      "\u57FA",
      "\u8CC7",
      "\u908A",
      "\u6D41",
      "\u8DEF",
      "\u7D1A",
      "\u5C11",
      "\u5716",
      "\u5C71",
      "\u7D71",
      "\u63A5",
      "\u77E5",
      "\u8F03",
      "\u5C07",
      "\u7D44",
      "\u898B",
      "\u8A08",
      "\u5225",
      "\u5979",
      "\u624B",
      "\u89D2",
      "\u671F",
      "\u6839",
      "\u8AD6",
      "\u904B",
      "\u8FB2",
      "\u6307",
      "\u5E7E",
      "\u4E5D",
      "\u5340",
      "\u5F37",
      "\u653E",
      "\u6C7A",
      "\u897F",
      "\u88AB",
      "\u5E79",
      "\u505A",
      "\u5FC5",
      "\u6230",
      "\u5148",
      "\u56DE",
      "\u5247",
      "\u4EFB",
      "\u53D6",
      "\u64DA",
      "\u8655",
      "\u968A",
      "\u5357",
      "\u7D66",
      "\u8272",
      "\u5149",
      "\u9580",
      "\u5373",
      "\u4FDD",
      "\u6CBB",
      "\u5317",
      "\u9020",
      "\u767E",
      "\u898F",
      "\u71B1",
      "\u9818",
      "\u4E03",
      "\u6D77",
      "\u53E3",
      "\u6771",
      "\u5C0E",
      "\u5668",
      "\u58D3",
      "\u5FD7",
      "\u4E16",
      "\u91D1",
      "\u589E",
      "\u722D",
      "\u6FDF",
      "\u968E",
      "\u6CB9",
      "\u601D",
      "\u8853",
      "\u6975",
      "\u4EA4",
      "\u53D7",
      "\u806F",
      "\u4EC0",
      "\u8A8D",
      "\u516D",
      "\u5171",
      "\u6B0A",
      "\u6536",
      "\u8B49",
      "\u6539",
      "\u6E05",
      "\u7F8E",
      "\u518D",
      "\u63A1",
      "\u8F49",
      "\u66F4",
      "\u55AE",
      "\u98A8",
      "\u5207",
      "\u6253",
      "\u767D",
      "\u6559",
      "\u901F",
      "\u82B1",
      "\u5E36",
      "\u5B89",
      "\u5834",
      "\u8EAB",
      "\u8ECA",
      "\u4F8B",
      "\u771F",
      "\u52D9",
      "\u5177",
      "\u842C",
      "\u6BCF",
      "\u76EE",
      "\u81F3",
      "\u9054",
      "\u8D70",
      "\u7A4D",
      "\u793A",
      "\u8B70",
      "\u8072",
      "\u5831",
      "\u9B25",
      "\u5B8C",
      "\u985E",
      "\u516B",
      "\u96E2",
      "\u83EF",
      "\u540D",
      "\u78BA",
      "\u624D",
      "\u79D1",
      "\u5F35",
      "\u4FE1",
      "\u99AC",
      "\u7BC0",
      "\u8A71",
      "\u7C73",
      "\u6574",
      "\u7A7A",
      "\u5143",
      "\u6CC1",
      "\u4ECA",
      "\u96C6",
      "\u6EAB",
      "\u50B3",
      "\u571F",
      "\u8A31",
      "\u6B65",
      "\u7FA4",
      "\u5EE3",
      "\u77F3",
      "\u8A18",
      "\u9700",
      "\u6BB5",
      "\u7814",
      "\u754C",
      "\u62C9",
      "\u6797",
      "\u5F8B",
      "\u53EB",
      "\u4E14",
      "\u7A76",
      "\u89C0",
      "\u8D8A",
      "\u7E54",
      "\u88DD",
      "\u5F71",
      "\u7B97",
      "\u4F4E",
      "\u6301",
      "\u97F3",
      "\u773E",
      "\u66F8",
      "\u5E03",
      "\u590D",
      "\u5BB9",
      "\u5152",
      "\u9808",
      "\u969B",
      "\u5546",
      "\u975E",
      "\u9A57",
      "\u9023",
      "\u65B7",
      "\u6DF1",
      "\u96E3",
      "\u8FD1",
      "\u7926",
      "\u5343",
      "\u9031",
      "\u59D4",
      "\u7D20",
      "\u6280",
      "\u5099",
      "\u534A",
      "\u8FA6",
      "\u9752",
      "\u7701",
      "\u5217",
      "\u7FD2",
      "\u97FF",
      "\u7D04",
      "\u652F",
      "\u822C",
      "\u53F2",
      "\u611F",
      "\u52DE",
      "\u4FBF",
      "\u5718",
      "\u5F80",
      "\u9178",
      "\u6B77",
      "\u5E02",
      "\u514B",
      "\u4F55",
      "\u9664",
      "\u6D88",
      "\u69CB",
      "\u5E9C",
      "\u7A31",
      "\u592A",
      "\u6E96",
      "\u7CBE",
      "\u503C",
      "\u865F",
      "\u7387",
      "\u65CF",
      "\u7DAD",
      "\u5283",
      "\u9078",
      "\u6A19",
      "\u5BEB",
      "\u5B58",
      "\u5019",
      "\u6BDB",
      "\u89AA",
      "\u5FEB",
      "\u6548",
      "\u65AF",
      "\u9662",
      "\u67E5",
      "\u6C5F",
      "\u578B",
      "\u773C",
      "\u738B",
      "\u6309",
      "\u683C",
      "\u990A",
      "\u6613",
      "\u7F6E",
      "\u6D3E",
      "\u5C64",
      "\u7247",
      "\u59CB",
      "\u537B",
      "\u5C08",
      "\u72C0",
      "\u80B2",
      "\u5EE0",
      "\u4EAC",
      "\u8B58",
      "\u9069",
      "\u5C6C",
      "\u5713",
      "\u5305",
      "\u706B",
      "\u4F4F",
      "\u8ABF",
      "\u6EFF",
      "\u7E23",
      "\u5C40",
      "\u7167",
      "\u53C3",
      "\u7D05",
      "\u7D30",
      "\u5F15",
      "\u807D",
      "\u8A72",
      "\u9435",
      "\u50F9",
      "\u56B4",
      "\u9996",
      "\u5E95",
      "\u6DB2",
      "\u5B98",
      "\u5FB7",
      "\u96A8",
      "\u75C5",
      "\u8607",
      "\u5931",
      "\u723E",
      "\u6B7B",
      "\u8B1B",
      "\u914D",
      "\u5973",
      "\u9EC3",
      "\u63A8",
      "\u986F",
      "\u8AC7",
      "\u7F6A",
      "\u795E",
      "\u85DD",
      "\u5462",
      "\u5E2D",
      "\u542B",
      "\u4F01",
      "\u671B",
      "\u5BC6",
      "\u6279",
      "\u71DF",
      "\u9805",
      "\u9632",
      "\u8209",
      "\u7403",
      "\u82F1",
      "\u6C27",
      "\u52E2",
      "\u544A",
      "\u674E",
      "\u53F0",
      "\u843D",
      "\u6728",
      "\u5E6B",
      "\u8F2A",
      "\u7834",
      "\u4E9E",
      "\u5E2B",
      "\u570D",
      "\u6CE8",
      "\u9060",
      "\u5B57",
      "\u6750",
      "\u6392",
      "\u4F9B",
      "\u6CB3",
      "\u614B",
      "\u5C01",
      "\u53E6",
      "\u65BD",
      "\u6E1B",
      "\u6A39",
      "\u6EB6",
      "\u600E",
      "\u6B62",
      "\u6848",
      "\u8A00",
      "\u58EB",
      "\u5747",
      "\u6B66",
      "\u56FA",
      "\u8449",
      "\u9B5A",
      "\u6CE2",
      "\u8996",
      "\u50C5",
      "\u8CBB",
      "\u7DCA",
      "\u611B",
      "\u5DE6",
      "\u7AE0",
      "\u65E9",
      "\u671D",
      "\u5BB3",
      "\u7E8C",
      "\u8F15",
      "\u670D",
      "\u8A66",
      "\u98DF",
      "\u5145",
      "\u5175",
      "\u6E90",
      "\u5224",
      "\u8B77",
      "\u53F8",
      "\u8DB3",
      "\u67D0",
      "\u7DF4",
      "\u5DEE",
      "\u81F4",
      "\u677F",
      "\u7530",
      "\u964D",
      "\u9ED1",
      "\u72AF",
      "\u8CA0",
      "\u64CA",
      "\u8303",
      "\u7E7C",
      "\u8208",
      "\u4F3C",
      "\u9918",
      "\u5805",
      "\u66F2",
      "\u8F38",
      "\u4FEE",
      "\u6545",
      "\u57CE",
      "\u592B",
      "\u5920",
      "\u9001",
      "\u7B46",
      "\u8239",
      "\u4F54",
      "\u53F3",
      "\u8CA1",
      "\u5403",
      "\u5BCC",
      "\u6625",
      "\u8077",
      "\u89BA",
      "\u6F22",
      "\u756B",
      "\u529F",
      "\u5DF4",
      "\u8DDF",
      "\u96D6",
      "\u96DC",
      "\u98DB",
      "\u6AA2",
      "\u5438",
      "\u52A9",
      "\u6607",
      "\u967D",
      "\u4E92",
      "\u521D",
      "\u5275",
      "\u6297",
      "\u8003",
      "\u6295",
      "\u58DE",
      "\u7B56",
      "\u53E4",
      "\u5F91",
      "\u63DB",
      "\u672A",
      "\u8DD1",
      "\u7559",
      "\u92FC",
      "\u66FE",
      "\u7AEF",
      "\u8CAC",
      "\u7AD9",
      "\u7C21",
      "\u8FF0",
      "\u9322",
      "\u526F",
      "\u76E1",
      "\u5E1D",
      "\u5C04",
      "\u8349",
      "\u885D",
      "\u627F",
      "\u7368",
      "\u4EE4",
      "\u9650",
      "\u963F",
      "\u5BA3",
      "\u74B0",
      "\u96D9",
      "\u8ACB",
      "\u8D85",
      "\u5FAE",
      "\u8B93",
      "\u63A7",
      "\u5DDE",
      "\u826F",
      "\u8EF8",
      "\u627E",
      "\u5426",
      "\u7D00",
      "\u76CA",
      "\u4F9D",
      "\u512A",
      "\u9802",
      "\u790E",
      "\u8F09",
      "\u5012",
      "\u623F",
      "\u7A81",
      "\u5750",
      "\u7C89",
      "\u6575",
      "\u7565",
      "\u5BA2",
      "\u8881",
      "\u51B7",
      "\u52DD",
      "\u7D55",
      "\u6790",
      "\u584A",
      "\u5291",
      "\u6E2C",
      "\u7D72",
      "\u5354",
      "\u8A34",
      "\u5FF5",
      "\u9673",
      "\u4ECD",
      "\u7F85",
      "\u9E7D",
      "\u53CB",
      "\u6D0B",
      "\u932F",
      "\u82E6",
      "\u591C",
      "\u5211",
      "\u79FB",
      "\u983B",
      "\u9010",
      "\u9760",
      "\u6DF7",
      "\u6BCD",
      "\u77ED",
      "\u76AE",
      "\u7D42",
      "\u805A",
      "\u6C7D",
      "\u6751",
      "\u96F2",
      "\u54EA",
      "\u65E2",
      "\u8DDD",
      "\u885B",
      "\u505C",
      "\u70C8",
      "\u592E",
      "\u5BDF",
      "\u71D2",
      "\u8FC5",
      "\u5883",
      "\u82E5",
      "\u5370",
      "\u6D32",
      "\u523B",
      "\u62EC",
      "\u6FC0",
      "\u5B54",
      "\u641E",
      "\u751A",
      "\u5BA4",
      "\u5F85",
      "\u6838",
      "\u6821",
      "\u6563",
      "\u4FB5",
      "\u5427",
      "\u7532",
      "\u904A",
      "\u4E45",
      "\u83DC",
      "\u5473",
      "\u820A",
      "\u6A21",
      "\u6E56",
      "\u8CA8",
      "\u640D",
      "\u9810",
      "\u963B",
      "\u6BEB",
      "\u666E",
      "\u7A69",
      "\u4E59",
      "\u5ABD",
      "\u690D",
      "\u606F",
      "\u64F4",
      "\u9280",
      "\u8A9E",
      "\u63EE",
      "\u9152",
      "\u5B88",
      "\u62FF",
      "\u5E8F",
      "\u7D19",
      "\u91AB",
      "\u7F3A",
      "\u96E8",
      "\u55CE",
      "\u91DD",
      "\u5289",
      "\u554A",
      "\u6025",
      "\u5531",
      "\u8AA4",
      "\u8A13",
      "\u9858",
      "\u5BE9",
      "\u9644",
      "\u7372",
      "\u8336",
      "\u9BAE",
      "\u7CE7",
      "\u65A4",
      "\u5B69",
      "\u812B",
      "\u786B",
      "\u80A5",
      "\u5584",
      "\u9F8D",
      "\u6F14",
      "\u7236",
      "\u6F38",
      "\u8840",
      "\u6B61",
      "\u68B0",
      "\u638C",
      "\u6B4C",
      "\u6C99",
      "\u525B",
      "\u653B",
      "\u8B02",
      "\u76FE",
      "\u8A0E",
      "\u665A",
      "\u7C92",
      "\u4E82",
      "\u71C3",
      "\u77DB",
      "\u4E4E",
      "\u6BBA",
      "\u85E5",
      "\u5BE7",
      "\u9B6F",
      "\u8CB4",
      "\u9418",
      "\u7164",
      "\u8B80",
      "\u73ED",
      "\u4F2F",
      "\u9999",
      "\u4ECB",
      "\u8FEB",
      "\u53E5",
      "\u8C50",
      "\u57F9",
      "\u63E1",
      "\u862D",
      "\u64D4",
      "\u5F26",
      "\u86CB",
      "\u6C89",
      "\u5047",
      "\u7A7F",
      "\u57F7",
      "\u7B54",
      "\u6A02",
      "\u8AB0",
      "\u9806",
      "\u7159",
      "\u7E2E",
      "\u5FB5",
      "\u81C9",
      "\u559C",
      "\u677E",
      "\u8173",
      "\u56F0",
      "\u7570",
      "\u514D",
      "\u80CC",
      "\u661F",
      "\u798F",
      "\u8CB7",
      "\u67D3",
      "\u4E95",
      "\u6982",
      "\u6162",
      "\u6015",
      "\u78C1",
      "\u500D",
      "\u7956",
      "\u7687",
      "\u4FC3",
      "\u975C",
      "\u88DC",
      "\u8A55",
      "\u7FFB",
      "\u8089",
      "\u8E10",
      "\u5C3C",
      "\u8863",
      "\u5BEC",
      "\u63DA",
      "\u68C9",
      "\u5E0C",
      "\u50B7",
      "\u64CD",
      "\u5782",
      "\u79CB",
      "\u5B9C",
      "\u6C2B",
      "\u5957",
      "\u7763",
      "\u632F",
      "\u67B6",
      "\u4EAE",
      "\u672B",
      "\u61B2",
      "\u6176",
      "\u7DE8",
      "\u725B",
      "\u89F8",
      "\u6620",
      "\u96F7",
      "\u92B7",
      "\u8A69",
      "\u5EA7",
      "\u5C45",
      "\u6293",
      "\u88C2",
      "\u80DE",
      "\u547C",
      "\u5A18",
      "\u666F",
      "\u5A01",
      "\u7DA0",
      "\u6676",
      "\u539A",
      "\u76DF",
      "\u8861",
      "\u96DE",
      "\u5B6B",
      "\u5EF6",
      "\u5371",
      "\u81A0",
      "\u5C4B",
      "\u9109",
      "\u81E8",
      "\u9678",
      "\u9867",
      "\u6389",
      "\u5440",
      "\u71C8",
      "\u6B72",
      "\u63AA",
      "\u675F",
      "\u8010",
      "\u5287",
      "\u7389",
      "\u8D99",
      "\u8DF3",
      "\u54E5",
      "\u5B63",
      "\u8AB2",
      "\u51F1",
      "\u80E1",
      "\u984D",
      "\u6B3E",
      "\u7D39",
      "\u5377",
      "\u9F4A",
      "\u5049",
      "\u84B8",
      "\u6B96",
      "\u6C38",
      "\u5B97",
      "\u82D7",
      "\u5DDD",
      "\u7210",
      "\u5CA9",
      "\u5F31",
      "\u96F6",
      "\u694A",
      "\u594F",
      "\u6CBF",
      "\u9732",
      "\u687F",
      "\u63A2",
      "\u6ED1",
      "\u93AE",
      "\u98EF",
      "\u6FC3",
      "\u822A",
      "\u61F7",
      "\u8D95",
      "\u5EAB",
      "\u596A",
      "\u4F0A",
      "\u9748",
      "\u7A05",
      "\u9014",
      "\u6EC5",
      "\u8CFD",
      "\u6B78",
      "\u53EC",
      "\u9F13",
      "\u64AD",
      "\u76E4",
      "\u88C1",
      "\u96AA",
      "\u5EB7",
      "\u552F",
      "\u9304",
      "\u83CC",
      "\u7D14",
      "\u501F",
      "\u7CD6",
      "\u84CB",
      "\u6A6B",
      "\u7B26",
      "\u79C1",
      "\u52AA",
      "\u5802",
      "\u57DF",
      "\u69CD",
      "\u6F64",
      "\u5E45",
      "\u54C8",
      "\u7ADF",
      "\u719F",
      "\u87F2",
      "\u6FA4",
      "\u8166",
      "\u58E4",
      "\u78B3",
      "\u6B50",
      "\u904D",
      "\u5074",
      "\u5BE8",
      "\u6562",
      "\u5FB9",
      "\u616E",
      "\u659C",
      "\u8584",
      "\u5EAD",
      "\u7D0D",
      "\u5F48",
      "\u98FC",
      "\u4F38",
      "\u6298",
      "\u9EA5",
      "\u6FD5",
      "\u6697",
      "\u8377",
      "\u74E6",
      "\u585E",
      "\u5E8A",
      "\u7BC9",
      "\u60E1",
      "\u6236",
      "\u8A2A",
      "\u5854",
      "\u5947",
      "\u900F",
      "\u6881",
      "\u5200",
      "\u65CB",
      "\u8DE1",
      "\u5361",
      "\u6C2F",
      "\u9047",
      "\u4EFD",
      "\u6BD2",
      "\u6CE5",
      "\u9000",
      "\u6D17",
      "\u64FA",
      "\u7070",
      "\u5F69",
      "\u8CE3",
      "\u8017",
      "\u590F",
      "\u64C7",
      "\u5FD9",
      "\u9285",
      "\u737B",
      "\u786C",
      "\u4E88",
      "\u7E41",
      "\u5708",
      "\u96EA",
      "\u51FD",
      "\u4EA6",
      "\u62BD",
      "\u7BC7",
      "\u9663",
      "\u9670",
      "\u4E01",
      "\u5C3A",
      "\u8FFD",
      "\u5806",
      "\u96C4",
      "\u8FCE",
      "\u6CDB",
      "\u7238",
      "\u6A13",
      "\u907F",
      "\u8B00",
      "\u5678",
      "\u91CE",
      "\u8C6C",
      "\u65D7",
      "\u7D2F",
      "\u504F",
      "\u5178",
      "\u9928",
      "\u7D22",
      "\u79E6",
      "\u8102",
      "\u6F6E",
      "\u723A",
      "\u8C46",
      "\u5FFD",
      "\u6258",
      "\u9A5A",
      "\u5851",
      "\u907A",
      "\u6108",
      "\u6731",
      "\u66FF",
      "\u7E96",
      "\u7C97",
      "\u50BE",
      "\u5C1A",
      "\u75DB",
      "\u695A",
      "\u8B1D",
      "\u596E",
      "\u8CFC",
      "\u78E8",
      "\u541B",
      "\u6C60",
      "\u65C1",
      "\u788E",
      "\u9AA8",
      "\u76E3",
      "\u6355",
      "\u5F1F",
      "\u66B4",
      "\u5272",
      "\u8CAB",
      "\u6B8A",
      "\u91CB",
      "\u8A5E",
      "\u4EA1",
      "\u58C1",
      "\u9813",
      "\u5BF6",
      "\u5348",
      "\u5875",
      "\u805E",
      "\u63ED",
      "\u70AE",
      "\u6B98",
      "\u51AC",
      "\u6A4B",
      "\u5A66",
      "\u8B66",
      "\u7D9C",
      "\u62DB",
      "\u5433",
      "\u4ED8",
      "\u6D6E",
      "\u906D",
      "\u5F90",
      "\u60A8",
      "\u6416",
      "\u8C37",
      "\u8D0A",
      "\u7BB1",
      "\u9694",
      "\u8A02",
      "\u7537",
      "\u5439",
      "\u5712",
      "\u7D1B",
      "\u5510",
      "\u6557",
      "\u5B8B",
      "\u73BB",
      "\u5DE8",
      "\u8015",
      "\u5766",
      "\u69AE",
      "\u9589",
      "\u7063",
      "\u9375",
      "\u51E1",
      "\u99D0",
      "\u934B",
      "\u6551",
      "\u6069",
      "\u525D",
      "\u51DD",
      "\u9E7C",
      "\u9F52",
      "\u622A",
      "\u7149",
      "\u9EBB",
      "\u7D21",
      "\u7981",
      "\u5EE2",
      "\u76DB",
      "\u7248",
      "\u7DE9",
      "\u6DE8",
      "\u775B",
      "\u660C",
      "\u5A5A",
      "\u6D89",
      "\u7B52",
      "\u5634",
      "\u63D2",
      "\u5CB8",
      "\u6717",
      "\u838A",
      "\u8857",
      "\u85CF",
      "\u59D1",
      "\u8CBF",
      "\u8150",
      "\u5974",
      "\u5566",
      "\u6163",
      "\u4E58",
      "\u5925",
      "\u6062",
      "\u52FB",
      "\u7D17",
      "\u624E",
      "\u8FAF",
      "\u8033",
      "\u5F6A",
      "\u81E3",
      "\u5104",
      "\u7483",
      "\u62B5",
      "\u8108",
      "\u79C0",
      "\u85A9",
      "\u4FC4",
      "\u7DB2",
      "\u821E",
      "\u5E97",
      "\u5674",
      "\u7E31",
      "\u5BF8",
      "\u6C57",
      "\u639B",
      "\u6D2A",
      "\u8CC0",
      "\u9583",
      "\u67EC",
      "\u7206",
      "\u70EF",
      "\u6D25",
      "\u7A3B",
      "\u7246",
      "\u8EDF",
      "\u52C7",
      "\u50CF",
      "\u6EFE",
      "\u5398",
      "\u8499",
      "\u82B3",
      "\u80AF",
      "\u5761",
      "\u67F1",
      "\u76EA",
      "\u817F",
      "\u5100",
      "\u65C5",
      "\u5C3E",
      "\u8ECB",
      "\u51B0",
      "\u8CA2",
      "\u767B",
      "\u9ECE",
      "\u524A",
      "\u947D",
      "\u52D2",
      "\u9003",
      "\u969C",
      "\u6C28",
      "\u90ED",
      "\u5CF0",
      "\u5E63",
      "\u6E2F",
      "\u4F0F",
      "\u8ECC",
      "\u755D",
      "\u7562",
      "\u64E6",
      "\u83AB",
      "\u523A",
      "\u6D6A",
      "\u79D8",
      "\u63F4",
      "\u682A",
      "\u5065",
      "\u552E",
      "\u80A1",
      "\u5CF6",
      "\u7518",
      "\u6CE1",
      "\u7761",
      "\u7AE5",
      "\u9444",
      "\u6E6F",
      "\u95A5",
      "\u4F11",
      "\u532F",
      "\u820D",
      "\u7267",
      "\u7E5E",
      "\u70B8",
      "\u54F2",
      "\u78F7",
      "\u7E3E",
      "\u670B",
      "\u6DE1",
      "\u5C16",
      "\u555F",
      "\u9677",
      "\u67F4",
      "\u5448",
      "\u5F92",
      "\u984F",
      "\u6DDA",
      "\u7A0D",
      "\u5FD8",
      "\u6CF5",
      "\u85CD",
      "\u62D6",
      "\u6D1E",
      "\u6388",
      "\u93E1",
      "\u8F9B",
      "\u58EF",
      "\u92D2",
      "\u8CA7",
      "\u865B",
      "\u5F4E",
      "\u6469",
      "\u6CF0",
      "\u5E7C",
      "\u5EF7",
      "\u5C0A",
      "\u7A97",
      "\u7DB1",
      "\u5F04",
      "\u96B8",
      "\u7591",
      "\u6C0F",
      "\u5BAE",
      "\u59D0",
      "\u9707",
      "\u745E",
      "\u602A",
      "\u5C24",
      "\u7434",
      "\u5FAA",
      "\u63CF",
      "\u819C",
      "\u9055",
      "\u593E",
      "\u8170",
      "\u7DE3",
      "\u73E0",
      "\u7AAE",
      "\u68EE",
      "\u679D",
      "\u7AF9",
      "\u6E9D",
      "\u50AC",
      "\u7E69",
      "\u61B6",
      "\u90A6",
      "\u5269",
      "\u5E78",
      "\u6F3F",
      "\u6B04",
      "\u64C1",
      "\u7259",
      "\u8CAF",
      "\u79AE",
      "\u6FFE",
      "\u9209",
      "\u7D0B",
      "\u7F77",
      "\u62CD",
      "\u54B1",
      "\u558A",
      "\u8896",
      "\u57C3",
      "\u52E4",
      "\u7F70",
      "\u7126",
      "\u6F5B",
      "\u4F0D",
      "\u58A8",
      "\u6B32",
      "\u7E2B",
      "\u59D3",
      "\u520A",
      "\u98FD",
      "\u4EFF",
      "\u734E",
      "\u92C1",
      "\u9B3C",
      "\u9E97",
      "\u8DE8",
      "\u9ED8",
      "\u6316",
      "\u93C8",
      "\u6383",
      "\u559D",
      "\u888B",
      "\u70AD",
      "\u6C61",
      "\u5E55",
      "\u8AF8",
      "\u5F27",
      "\u52F5",
      "\u6885",
      "\u5976",
      "\u6F54",
      "\u707D",
      "\u821F",
      "\u9451",
      "\u82EF",
      "\u8A1F",
      "\u62B1",
      "\u6BC0",
      "\u61C2",
      "\u5BD2",
      "\u667A",
      "\u57D4",
      "\u5BC4",
      "\u5C46",
      "\u8E8D",
      "\u6E21",
      "\u6311",
      "\u4E39",
      "\u8271",
      "\u8C9D",
      "\u78B0",
      "\u62D4",
      "\u7239",
      "\u6234",
      "\u78BC",
      "\u5922",
      "\u82BD",
      "\u7194",
      "\u8D64",
      "\u6F01",
      "\u54ED",
      "\u656C",
      "\u9846",
      "\u5954",
      "\u925B",
      "\u4EF2",
      "\u864E",
      "\u7A00",
      "\u59B9",
      "\u4E4F",
      "\u73CD",
      "\u7533",
      "\u684C",
      "\u9075",
      "\u5141",
      "\u9686",
      "\u87BA",
      "\u5009",
      "\u9B4F",
      "\u92B3",
      "\u66C9",
      "\u6C2E",
      "\u517C",
      "\u96B1",
      "\u7919",
      "\u8D6B",
      "\u64A5",
      "\u5FE0",
      "\u8085",
      "\u7F38",
      "\u727D",
      "\u6436",
      "\u535A",
      "\u5DE7",
      "\u6BBC",
      "\u5144",
      "\u675C",
      "\u8A0A",
      "\u8AA0",
      "\u78A7",
      "\u7965",
      "\u67EF",
      "\u9801",
      "\u5DE1",
      "\u77E9",
      "\u60B2",
      "\u704C",
      "\u9F61",
      "\u502B",
      "\u7968",
      "\u5C0B",
      "\u6842",
      "\u92EA",
      "\u8056",
      "\u6050",
      "\u6070",
      "\u912D",
      "\u8DA3",
      "\u62AC",
      "\u8352",
      "\u9A30",
      "\u8CBC",
      "\u67D4",
      "\u6EF4",
      "\u731B",
      "\u95CA",
      "\u8F1B",
      "\u59BB",
      "\u586B",
      "\u64A4",
      "\u5132",
      "\u7C3D",
      "\u9B27",
      "\u64FE",
      "\u7D2B",
      "\u7802",
      "\u905E",
      "\u6232",
      "\u540A",
      "\u9676",
      "\u4F10",
      "\u9935",
      "\u7642",
      "\u74F6",
      "\u5A46",
      "\u64AB",
      "\u81C2",
      "\u6478",
      "\u5FCD",
      "\u8766",
      "\u881F",
      "\u9130",
      "\u80F8",
      "\u978F",
      "\u64E0",
      "\u5076",
      "\u68C4",
      "\u69FD",
      "\u52C1",
      "\u4E73",
      "\u9127",
      "\u5409",
      "\u4EC1",
      "\u721B",
      "\u78DA",
      "\u79DF",
      "\u70CF",
      "\u8266",
      "\u4F34",
      "\u74DC",
      "\u6DFA",
      "\u4E19",
      "\u66AB",
      "\u71E5",
      "\u6A61",
      "\u67F3",
      "\u8FF7",
      "\u6696",
      "\u724C",
      "\u79E7",
      "\u81BD",
      "\u8A73",
      "\u7C27",
      "\u8E0F",
      "\u74F7",
      "\u8B5C",
      "\u5446",
      "\u8CD3",
      "\u7CCA",
      "\u6D1B",
      "\u8F1D",
      "\u61A4",
      "\u7AF6",
      "\u9699",
      "\u6012",
      "\u7C98",
      "\u4E43",
      "\u7DD2",
      "\u80A9",
      "\u7C4D",
      "\u654F",
      "\u5857",
      "\u7199",
      "\u7686",
      "\u5075",
      "\u61F8",
      "\u6398",
      "\u4EAB",
      "\u7CFE",
      "\u9192",
      "\u72C2",
      "\u9396",
      "\u6DC0",
      "\u6068",
      "\u7272",
      "\u9738",
      "\u722C",
      "\u8CDE",
      "\u9006",
      "\u73A9",
      "\u9675",
      "\u795D",
      "\u79D2",
      "\u6D59",
      "\u8C8C",
      "\u5F79",
      "\u5F7C",
      "\u6089",
      "\u9D28",
      "\u8DA8",
      "\u9CF3",
      "\u6668",
      "\u755C",
      "\u8F29",
      "\u79E9",
      "\u5375",
      "\u7F72",
      "\u68AF",
      "\u708E",
      "\u7058",
      "\u68CB",
      "\u9A45",
      "\u7BE9",
      "\u5CFD",
      "\u5192",
      "\u5565",
      "\u58FD",
      "\u8B6F",
      "\u6D78",
      "\u6CC9",
      "\u5E3D",
      "\u9072",
      "\u77FD",
      "\u7586",
      "\u8CB8",
      "\u6F0F",
      "\u7A3F",
      "\u51A0",
      "\u5AE9",
      "\u8105",
      "\u82AF",
      "\u7262",
      "\u53DB",
      "\u8755",
      "\u5967",
      "\u9CF4",
      "\u5DBA",
      "\u7F8A",
      "\u6191",
      "\u4E32",
      "\u5858",
      "\u7E6A",
      "\u9175",
      "\u878D",
      "\u76C6",
      "\u932B",
      "\u5EDF",
      "\u7C4C",
      "\u51CD",
      "\u8F14",
      "\u651D",
      "\u8972",
      "\u7B4B",
      "\u62D2",
      "\u50DA",
      "\u65F1",
      "\u9240",
      "\u9CE5",
      "\u6F06",
      "\u6C88",
      "\u7709",
      "\u758F",
      "\u6DFB",
      "\u68D2",
      "\u7A57",
      "\u785D",
      "\u97D3",
      "\u903C",
      "\u626D",
      "\u50D1",
      "\u6DBC",
      "\u633A",
      "\u7897",
      "\u683D",
      "\u7092",
      "\u676F",
      "\u60A3",
      "\u993E",
      "\u52F8",
      "\u8C6A",
      "\u907C",
      "\u52C3",
      "\u9D3B",
      "\u65E6",
      "\u540F",
      "\u62DC",
      "\u72D7",
      "\u57CB",
      "\u8F25",
      "\u63A9",
      "\u98F2",
      "\u642C",
      "\u7F75",
      "\u8FAD",
      "\u52FE",
      "\u6263",
      "\u4F30",
      "\u8523",
      "\u7D68",
      "\u9727",
      "\u4E08",
      "\u6735",
      "\u59C6",
      "\u64EC",
      "\u5B87",
      "\u8F2F",
      "\u965D",
      "\u96D5",
      "\u511F",
      "\u84C4",
      "\u5D07",
      "\u526A",
      "\u5021",
      "\u5EF3",
      "\u54AC",
      "\u99DB",
      "\u85AF",
      "\u5237",
      "\u65A5",
      "\u756A",
      "\u8CE6",
      "\u5949",
      "\u4F5B",
      "\u6F86",
      "\u6F2B",
      "\u66FC",
      "\u6247",
      "\u9223",
      "\u6843",
      "\u6276",
      "\u4ED4",
      "\u8FD4",
      "\u4FD7",
      "\u8667",
      "\u8154",
      "\u978B",
      "\u68F1",
      "\u8986",
      "\u6846",
      "\u6084",
      "\u53D4",
      "\u649E",
      "\u9A19",
      "\u52D8",
      "\u65FA",
      "\u6CB8",
      "\u5B64",
      "\u5410",
      "\u5B5F",
      "\u6E20",
      "\u5C48",
      "\u75BE",
      "\u5999",
      "\u60DC",
      "\u4EF0",
      "\u72E0",
      "\u8139",
      "\u8AE7",
      "\u62CB",
      "\u9EF4",
      "\u6851",
      "\u5D17",
      "\u561B",
      "\u8870",
      "\u76DC",
      "\u6EF2",
      "\u81DF",
      "\u8CF4",
      "\u6E67",
      "\u751C",
      "\u66F9",
      "\u95B1",
      "\u808C",
      "\u54E9",
      "\u53B2",
      "\u70F4",
      "\u7DEF",
      "\u6BC5",
      "\u6628",
      "\u507D",
      "\u75C7",
      "\u716E",
      "\u5606",
      "\u91D8",
      "\u642D",
      "\u8396",
      "\u7C60",
      "\u9177",
      "\u5077",
      "\u5F13",
      "\u9310",
      "\u6046",
      "\u5091",
      "\u5751",
      "\u9F3B",
      "\u7FFC",
      "\u7DB8",
      "\u6558",
      "\u7344",
      "\u902E",
      "\u7F50",
      "\u7D61",
      "\u68DA",
      "\u6291",
      "\u81A8",
      "\u852C",
      "\u5BFA",
      "\u9A5F",
      "\u7A46",
      "\u51B6",
      "\u67AF",
      "\u518A",
      "\u5C4D",
      "\u51F8",
      "\u7D33",
      "\u576F",
      "\u72A7",
      "\u7130",
      "\u8F5F",
      "\u6B23",
      "\u6649",
      "\u7626",
      "\u79A6",
      "\u9320",
      "\u9326",
      "\u55AA",
      "\u65EC",
      "\u935B",
      "\u58DF",
      "\u641C",
      "\u64B2",
      "\u9080",
      "\u4EAD",
      "\u916F",
      "\u9081",
      "\u8212",
      "\u8106",
      "\u9176",
      "\u9592",
      "\u6182",
      "\u915A",
      "\u9811",
      "\u7FBD",
      "\u6F32",
      "\u5378",
      "\u4ED7",
      "\u966A",
      "\u95E2",
      "\u61F2",
      "\u676D",
      "\u59DA",
      "\u809A",
      "\u6349",
      "\u98C4",
      "\u6F02",
      "\u6606",
      "\u6B3A",
      "\u543E",
      "\u90CE",
      "\u70F7",
      "\u6C41",
      "\u5475",
      "\u98FE",
      "\u856D",
      "\u96C5",
      "\u90F5",
      "\u9077",
      "\u71D5",
      "\u6492",
      "\u59FB",
      "\u8D74",
      "\u5BB4",
      "\u7169",
      "\u50B5",
      "\u5E33",
      "\u6591",
      "\u9234",
      "\u65E8",
      "\u9187",
      "\u8463",
      "\u9905",
      "\u96DB",
      "\u59FF",
      "\u62CC",
      "\u5085",
      "\u8179",
      "\u59A5",
      "\u63C9",
      "\u8CE2",
      "\u62C6",
      "\u6B6A",
      "\u8461",
      "\u80FA",
      "\u4E1F",
      "\u6D69",
      "\u5FBD",
      "\u6602",
      "\u588A",
      "\u64CB",
      "\u89BD",
      "\u8CAA",
      "\u6170",
      "\u7E73",
      "\u6C6A",
      "\u614C",
      "\u99AE",
      "\u8AFE",
      "\u59DC",
      "\u8ABC",
      "\u5147",
      "\u52A3",
      "\u8AA3",
      "\u8000",
      "\u660F",
      "\u8EBA",
      "\u76C8",
      "\u9A0E",
      "\u55AC",
      "\u6EAA",
      "\u53E2",
      "\u76E7",
      "\u62B9",
      "\u60B6",
      "\u8AEE",
      "\u522E",
      "\u99D5",
      "\u7E9C",
      "\u609F",
      "\u6458",
      "\u927A",
      "\u64F2",
      "\u9817",
      "\u5E7B",
      "\u67C4",
      "\u60E0",
      "\u6158",
      "\u4F73",
      "\u4EC7",
      "\u81D8",
      "\u7AA9",
      "\u6ECC",
      "\u528D",
      "\u77A7",
      "\u5821",
      "\u6F51",
      "\u8525",
      "\u7F69",
      "\u970D",
      "\u6488",
      "\u80CE",
      "\u84BC",
      "\u6FF1",
      "\u5006",
      "\u6345",
      "\u6E58",
      "\u780D",
      "\u971E",
      "\u90B5",
      "\u8404",
      "\u760B",
      "\u6DEE",
      "\u9042",
      "\u718A",
      "\u7CDE",
      "\u70D8",
      "\u5BBF",
      "\u6A94",
      "\u6208",
      "\u99C1",
      "\u5AC2",
      "\u88D5",
      "\u5F99",
      "\u7BAD",
      "\u6350",
      "\u8178",
      "\u6490",
      "\u66EC",
      "\u8FA8",
      "\u6BBF",
      "\u84EE",
      "\u6524",
      "\u652A",
      "\u91AC",
      "\u5C4F",
      "\u75AB",
      "\u54C0",
      "\u8521",
      "\u5835",
      "\u6CAB",
      "\u76BA",
      "\u66A2",
      "\u758A",
      "\u95A3",
      "\u840A",
      "\u6572",
      "\u8F44",
      "\u9264",
      "\u75D5",
      "\u58E9",
      "\u5DF7",
      "\u9913",
      "\u798D",
      "\u4E18",
      "\u7384",
      "\u6E9C",
      "\u66F0",
      "\u908F",
      "\u5F6D",
      "\u5617",
      "\u537F",
      "\u59A8",
      "\u8247",
      "\u541E",
      "\u97CB",
      "\u6028",
      "\u77EE",
      "\u6B47"
    ];
  }
});

// node_modules/bip39/src/wordlists/korean.json
var require_korean = __commonJS({
  "node_modules/bip39/src/wordlists/korean.json"(exports2, module2) {
    module2.exports = [
      "\u1100\u1161\u1100\u1167\u11A8",
      "\u1100\u1161\u1101\u1173\u11B7",
      "\u1100\u1161\u1102\u1161\u11AB",
      "\u1100\u1161\u1102\u1173\u11BC",
      "\u1100\u1161\u1103\u1173\u11A8",
      "\u1100\u1161\u1105\u1173\u110E\u1175\u11B7",
      "\u1100\u1161\u1106\u116E\u11B7",
      "\u1100\u1161\u1107\u1161\u11BC",
      "\u1100\u1161\u1109\u1161\u11BC",
      "\u1100\u1161\u1109\u1173\u11B7",
      "\u1100\u1161\u110B\u116E\u11AB\u1103\u1166",
      "\u1100\u1161\u110B\u1173\u11AF",
      "\u1100\u1161\u110B\u1175\u1103\u1173",
      "\u1100\u1161\u110B\u1175\u11B8",
      "\u1100\u1161\u110C\u1161\u11BC",
      "\u1100\u1161\u110C\u1165\u11BC",
      "\u1100\u1161\u110C\u1169\u11A8",
      "\u1100\u1161\u110C\u116E\u11A8",
      "\u1100\u1161\u11A8\u110B\u1169",
      "\u1100\u1161\u11A8\u110C\u1161",
      "\u1100\u1161\u11AB\u1100\u1167\u11A8",
      "\u1100\u1161\u11AB\u1107\u116E",
      "\u1100\u1161\u11AB\u1109\u1165\u11B8",
      "\u1100\u1161\u11AB\u110C\u1161\u11BC",
      "\u1100\u1161\u11AB\u110C\u1165\u11B8",
      "\u1100\u1161\u11AB\u1111\u1161\u11AB",
      "\u1100\u1161\u11AF\u1103\u1173\u11BC",
      "\u1100\u1161\u11AF\u1107\u1175",
      "\u1100\u1161\u11AF\u1109\u1162\u11A8",
      "\u1100\u1161\u11AF\u110C\u1173\u11BC",
      "\u1100\u1161\u11B7\u1100\u1161\u11A8",
      "\u1100\u1161\u11B7\u1100\u1175",
      "\u1100\u1161\u11B7\u1109\u1169",
      "\u1100\u1161\u11B7\u1109\u116E\u1109\u1165\u11BC",
      "\u1100\u1161\u11B7\u110C\u1161",
      "\u1100\u1161\u11B7\u110C\u1165\u11BC",
      "\u1100\u1161\u11B8\u110C\u1161\u1100\u1175",
      "\u1100\u1161\u11BC\u1102\u1161\u11B7",
      "\u1100\u1161\u11BC\u1103\u1161\u11BC",
      "\u1100\u1161\u11BC\u1103\u1169",
      "\u1100\u1161\u11BC\u1105\u1167\u11A8\u1112\u1175",
      "\u1100\u1161\u11BC\u1107\u1167\u11AB",
      "\u1100\u1161\u11BC\u1107\u116E\u11A8",
      "\u1100\u1161\u11BC\u1109\u1161",
      "\u1100\u1161\u11BC\u1109\u116E\u1105\u1163\u11BC",
      "\u1100\u1161\u11BC\u110B\u1161\u110C\u1175",
      "\u1100\u1161\u11BC\u110B\u116F\u11AB\u1103\u1169",
      "\u1100\u1161\u11BC\u110B\u1174",
      "\u1100\u1161\u11BC\u110C\u1166",
      "\u1100\u1161\u11BC\u110C\u1169",
      "\u1100\u1161\u11C0\u110B\u1175",
      "\u1100\u1162\u1100\u116E\u1105\u1175",
      "\u1100\u1162\u1102\u1161\u1105\u1175",
      "\u1100\u1162\u1107\u1161\u11BC",
      "\u1100\u1162\u1107\u1167\u11AF",
      "\u1100\u1162\u1109\u1165\u11AB",
      "\u1100\u1162\u1109\u1165\u11BC",
      "\u1100\u1162\u110B\u1175\u11AB",
      "\u1100\u1162\u11A8\u1100\u116A\u11AB\u110C\u1165\u11A8",
      "\u1100\u1165\u1109\u1175\u11AF",
      "\u1100\u1165\u110B\u1162\u11A8",
      "\u1100\u1165\u110B\u116E\u11AF",
      "\u1100\u1165\u110C\u1175\u11BA",
      "\u1100\u1165\u1111\u116E\u11B7",
      "\u1100\u1165\u11A8\u110C\u1165\u11BC",
      "\u1100\u1165\u11AB\u1100\u1161\u11BC",
      "\u1100\u1165\u11AB\u1106\u116E\u11AF",
      "\u1100\u1165\u11AB\u1109\u1165\u11AF",
      "\u1100\u1165\u11AB\u110C\u1169",
      "\u1100\u1165\u11AB\u110E\u116E\u11A8",
      "\u1100\u1165\u11AF\u110B\u1173\u11B7",
      "\u1100\u1165\u11B7\u1109\u1161",
      "\u1100\u1165\u11B7\u1110\u1169",
      "\u1100\u1166\u1109\u1175\u1111\u1161\u11AB",
      "\u1100\u1166\u110B\u1175\u11B7",
      "\u1100\u1167\u110B\u116E\u11AF",
      "\u1100\u1167\u11AB\u1112\u1162",
      "\u1100\u1167\u11AF\u1100\u116A",
      "\u1100\u1167\u11AF\u1100\u116E\u11A8",
      "\u1100\u1167\u11AF\u1105\u1169\u11AB",
      "\u1100\u1167\u11AF\u1109\u1165\u11A8",
      "\u1100\u1167\u11AF\u1109\u1173\u11BC",
      "\u1100\u1167\u11AF\u1109\u1175\u11B7",
      "\u1100\u1167\u11AF\u110C\u1165\u11BC",
      "\u1100\u1167\u11AF\u1112\u1169\u11AB",
      "\u1100\u1167\u11BC\u1100\u1168",
      "\u1100\u1167\u11BC\u1100\u1169",
      "\u1100\u1167\u11BC\u1100\u1175",
      "\u1100\u1167\u11BC\u1105\u1167\u11A8",
      "\u1100\u1167\u11BC\u1107\u1169\u11A8\u1100\u116E\u11BC",
      "\u1100\u1167\u11BC\u1107\u1175",
      "\u1100\u1167\u11BC\u1109\u1161\u11BC\u1103\u1169",
      "\u1100\u1167\u11BC\u110B\u1167\u11BC",
      "\u1100\u1167\u11BC\u110B\u116E",
      "\u1100\u1167\u11BC\u110C\u1162\u11BC",
      "\u1100\u1167\u11BC\u110C\u1166",
      "\u1100\u1167\u11BC\u110C\u116E",
      "\u1100\u1167\u11BC\u110E\u1161\u11AF",
      "\u1100\u1167\u11BC\u110E\u1175",
      "\u1100\u1167\u11BC\u1112\u1163\u11BC",
      "\u1100\u1167\u11BC\u1112\u1165\u11B7",
      "\u1100\u1168\u1100\u1169\u11A8",
      "\u1100\u1168\u1103\u1161\u11AB",
      "\u1100\u1168\u1105\u1161\u11AB",
      "\u1100\u1168\u1109\u1161\u11AB",
      "\u1100\u1168\u1109\u1169\u11A8",
      "\u1100\u1168\u110B\u1163\u11A8",
      "\u1100\u1168\u110C\u1165\u11AF",
      "\u1100\u1168\u110E\u1173\u11BC",
      "\u1100\u1168\u1112\u116C\u11A8",
      "\u1100\u1169\u1100\u1162\u11A8",
      "\u1100\u1169\u1100\u116E\u1105\u1167",
      "\u1100\u1169\u1100\u116E\u11BC",
      "\u1100\u1169\u1100\u1173\u11B8",
      "\u1100\u1169\u1103\u1173\u11BC\u1112\u1161\u11A8\u1109\u1162\u11BC",
      "\u1100\u1169\u1106\u116E\u1109\u1175\u11AB",
      "\u1100\u1169\u1106\u1175\u11AB",
      "\u1100\u1169\u110B\u1163\u11BC\u110B\u1175",
      "\u1100\u1169\u110C\u1161\u11BC",
      "\u1100\u1169\u110C\u1165\u11AB",
      "\u1100\u1169\u110C\u1175\u11B8",
      "\u1100\u1169\u110E\u116E\u11BA\u1100\u1161\u1105\u116E",
      "\u1100\u1169\u1110\u1169\u11BC",
      "\u1100\u1169\u1112\u1163\u11BC",
      "\u1100\u1169\u11A8\u1109\u1175\u11A8",
      "\u1100\u1169\u11AF\u1106\u1169\u11A8",
      "\u1100\u1169\u11AF\u110D\u1161\u1100\u1175",
      "\u1100\u1169\u11AF\u1111\u1173",
      "\u1100\u1169\u11BC\u1100\u1161\u11AB",
      "\u1100\u1169\u11BC\u1100\u1162",
      "\u1100\u1169\u11BC\u1100\u1167\u11A8",
      "\u1100\u1169\u11BC\u1100\u116E\u11AB",
      "\u1100\u1169\u11BC\u1100\u1173\u11B8",
      "\u1100\u1169\u11BC\u1100\u1175",
      "\u1100\u1169\u11BC\u1103\u1169\u11BC",
      "\u1100\u1169\u11BC\u1106\u116E\u110B\u116F\u11AB",
      "\u1100\u1169\u11BC\u1107\u116E",
      "\u1100\u1169\u11BC\u1109\u1161",
      "\u1100\u1169\u11BC\u1109\u1175\u11A8",
      "\u1100\u1169\u11BC\u110B\u1165\u11B8",
      "\u1100\u1169\u11BC\u110B\u1167\u11AB",
      "\u1100\u1169\u11BC\u110B\u116F\u11AB",
      "\u1100\u1169\u11BC\u110C\u1161\u11BC",
      "\u1100\u1169\u11BC\u110D\u1161",
      "\u1100\u1169\u11BC\u110E\u1162\u11A8",
      "\u1100\u1169\u11BC\u1110\u1169\u11BC",
      "\u1100\u1169\u11BC\u1111\u1169",
      "\u1100\u1169\u11BC\u1112\u1161\u11BC",
      "\u1100\u1169\u11BC\u1112\u1172\u110B\u1175\u11AF",
      "\u1100\u116A\u1106\u1169\u11A8",
      "\u1100\u116A\u110B\u1175\u11AF",
      "\u1100\u116A\u110C\u1161\u11BC",
      "\u1100\u116A\u110C\u1165\u11BC",
      "\u1100\u116A\u1112\u1161\u11A8",
      "\u1100\u116A\u11AB\u1100\u1162\u11A8",
      "\u1100\u116A\u11AB\u1100\u1168",
      "\u1100\u116A\u11AB\u1100\u116A\u11BC",
      "\u1100\u116A\u11AB\u1102\u1167\u11B7",
      "\u1100\u116A\u11AB\u1105\u1161\u11B7",
      "\u1100\u116A\u11AB\u1105\u1167\u11AB",
      "\u1100\u116A\u11AB\u1105\u1175",
      "\u1100\u116A\u11AB\u1109\u1173\u11B8",
      "\u1100\u116A\u11AB\u1109\u1175\u11B7",
      "\u1100\u116A\u11AB\u110C\u1165\u11B7",
      "\u1100\u116A\u11AB\u110E\u1161\u11AF",
      "\u1100\u116A\u11BC\u1100\u1167\u11BC",
      "\u1100\u116A\u11BC\u1100\u1169",
      "\u1100\u116A\u11BC\u110C\u1161\u11BC",
      "\u1100\u116A\u11BC\u110C\u116E",
      "\u1100\u116C\u1105\u1169\u110B\u116E\u11B7",
      "\u1100\u116C\u11BC\u110C\u1161\u11BC\u1112\u1175",
      "\u1100\u116D\u1100\u116A\u1109\u1165",
      "\u1100\u116D\u1106\u116E\u11AB",
      "\u1100\u116D\u1107\u1169\u11A8",
      "\u1100\u116D\u1109\u1175\u11AF",
      "\u1100\u116D\u110B\u1163\u11BC",
      "\u1100\u116D\u110B\u1172\u11A8",
      "\u1100\u116D\u110C\u1161\u11BC",
      "\u1100\u116D\u110C\u1175\u11A8",
      "\u1100\u116D\u1110\u1169\u11BC",
      "\u1100\u116D\u1112\u116A\u11AB",
      "\u1100\u116D\u1112\u116E\u11AB",
      "\u1100\u116E\u1100\u1167\u11BC",
      "\u1100\u116E\u1105\u1173\u11B7",
      "\u1100\u116E\u1106\u1165\u11BC",
      "\u1100\u116E\u1107\u1167\u11AF",
      "\u1100\u116E\u1107\u116E\u11AB",
      "\u1100\u116E\u1109\u1165\u11A8",
      "\u1100\u116E\u1109\u1165\u11BC",
      "\u1100\u116E\u1109\u1169\u11A8",
      "\u1100\u116E\u110B\u1167\u11A8",
      "\u1100\u116E\u110B\u1175\u11B8",
      "\u1100\u116E\u110E\u1165\u11BC",
      "\u1100\u116E\u110E\u1166\u110C\u1165\u11A8",
      "\u1100\u116E\u11A8\u1100\u1161",
      "\u1100\u116E\u11A8\u1100\u1175",
      "\u1100\u116E\u11A8\u1102\u1162",
      "\u1100\u116E\u11A8\u1105\u1175\u11B8",
      "\u1100\u116E\u11A8\u1106\u116E\u11AF",
      "\u1100\u116E\u11A8\u1106\u1175\u11AB",
      "\u1100\u116E\u11A8\u1109\u116E",
      "\u1100\u116E\u11A8\u110B\u1165",
      "\u1100\u116E\u11A8\u110B\u116A\u11BC",
      "\u1100\u116E\u11A8\u110C\u1165\u11A8",
      "\u1100\u116E\u11A8\u110C\u1166",
      "\u1100\u116E\u11A8\u1112\u116C",
      "\u1100\u116E\u11AB\u1103\u1162",
      "\u1100\u116E\u11AB\u1109\u1161",
      "\u1100\u116E\u11AB\u110B\u1175\u11AB",
      "\u1100\u116E\u11BC\u1100\u1173\u11A8\u110C\u1165\u11A8",
      "\u1100\u116F\u11AB\u1105\u1175",
      "\u1100\u116F\u11AB\u110B\u1171",
      "\u1100\u116F\u11AB\u1110\u116E",
      "\u1100\u1171\u1100\u116E\u11A8",
      "\u1100\u1171\u1109\u1175\u11AB",
      "\u1100\u1172\u110C\u1165\u11BC",
      "\u1100\u1172\u110E\u1175\u11A8",
      "\u1100\u1172\u11AB\u1112\u1167\u11BC",
      "\u1100\u1173\u1102\u1161\u11AF",
      "\u1100\u1173\u1102\u1163\u11BC",
      "\u1100\u1173\u1102\u1173\u11AF",
      "\u1100\u1173\u1105\u1165\u1102\u1161",
      "\u1100\u1173\u1105\u116E\u11B8",
      "\u1100\u1173\u1105\u1173\u11BA",
      "\u1100\u1173\u1105\u1175\u11B7",
      "\u1100\u1173\u110C\u1166\u1109\u1165\u110B\u1163",
      "\u1100\u1173\u1110\u1169\u1105\u1169\u11A8",
      "\u1100\u1173\u11A8\u1107\u1169\u11A8",
      "\u1100\u1173\u11A8\u1112\u1175",
      "\u1100\u1173\u11AB\u1100\u1165",
      "\u1100\u1173\u11AB\u1100\u116D",
      "\u1100\u1173\u11AB\u1105\u1162",
      "\u1100\u1173\u11AB\u1105\u1169",
      "\u1100\u1173\u11AB\u1106\u116E",
      "\u1100\u1173\u11AB\u1107\u1169\u11AB",
      "\u1100\u1173\u11AB\u110B\u116F\u11AB",
      "\u1100\u1173\u11AB\u110B\u1172\u11A8",
      "\u1100\u1173\u11AB\u110E\u1165",
      "\u1100\u1173\u11AF\u110A\u1175",
      "\u1100\u1173\u11AF\u110C\u1161",
      "\u1100\u1173\u11B7\u1100\u1161\u11BC\u1109\u1161\u11AB",
      "\u1100\u1173\u11B7\u1100\u1169",
      "\u1100\u1173\u11B7\u1102\u1167\u11AB",
      "\u1100\u1173\u11B7\u1106\u1166\u1103\u1161\u11AF",
      "\u1100\u1173\u11B7\u110B\u1162\u11A8",
      "\u1100\u1173\u11B7\u110B\u1167\u11AB",
      "\u1100\u1173\u11B7\u110B\u116D\u110B\u1175\u11AF",
      "\u1100\u1173\u11B7\u110C\u1175",
      "\u1100\u1173\u11BC\u110C\u1165\u11BC\u110C\u1165\u11A8",
      "\u1100\u1175\u1100\u1161\u11AB",
      "\u1100\u1175\u1100\u116A\u11AB",
      "\u1100\u1175\u1102\u1167\u11B7",
      "\u1100\u1175\u1102\u1173\u11BC",
      "\u1100\u1175\u1103\u1169\u11A8\u1100\u116D",
      "\u1100\u1175\u1103\u116E\u11BC",
      "\u1100\u1175\u1105\u1169\u11A8",
      "\u1100\u1175\u1105\u1173\u11B7",
      "\u1100\u1175\u1107\u1165\u11B8",
      "\u1100\u1175\u1107\u1169\u11AB",
      "\u1100\u1175\u1107\u116E\u11AB",
      "\u1100\u1175\u1108\u1173\u11B7",
      "\u1100\u1175\u1109\u116E\u11A8\u1109\u1161",
      "\u1100\u1175\u1109\u116E\u11AF",
      "\u1100\u1175\u110B\u1165\u11A8",
      "\u1100\u1175\u110B\u1165\u11B8",
      "\u1100\u1175\u110B\u1169\u11AB",
      "\u1100\u1175\u110B\u116E\u11AB",
      "\u1100\u1175\u110B\u116F\u11AB",
      "\u1100\u1175\u110C\u1165\u11A8",
      "\u1100\u1175\u110C\u116E\u11AB",
      "\u1100\u1175\u110E\u1175\u11B7",
      "\u1100\u1175\u1112\u1169\u11AB",
      "\u1100\u1175\u1112\u116C\u11A8",
      "\u1100\u1175\u11AB\u1100\u1173\u11B8",
      "\u1100\u1175\u11AB\u110C\u1161\u11BC",
      "\u1100\u1175\u11AF\u110B\u1175",
      "\u1100\u1175\u11B7\u1107\u1161\u11B8",
      "\u1100\u1175\u11B7\u110E\u1175",
      "\u1100\u1175\u11B7\u1111\u1169\u1100\u1169\u11BC\u1112\u1161\u11BC",
      "\u1101\u1161\u11A8\u1103\u116E\u1100\u1175",
      "\u1101\u1161\u11B7\u1108\u1161\u11A8",
      "\u1101\u1162\u1103\u1161\u11AF\u110B\u1173\u11B7",
      "\u1101\u1162\u1109\u1169\u1100\u1173\u11B7",
      "\u1101\u1165\u11B8\u110C\u1175\u11AF",
      "\u1101\u1169\u11A8\u1103\u1162\u1100\u1175",
      "\u1101\u1169\u11BE\u110B\u1175\u11C1",
      "\u1102\u1161\u1103\u1173\u11AF\u110B\u1175",
      "\u1102\u1161\u1105\u1161\u11AB\u1112\u1175",
      "\u1102\u1161\u1106\u1165\u110C\u1175",
      "\u1102\u1161\u1106\u116E\u11AF",
      "\u1102\u1161\u110E\u1175\u11B7\u1107\u1161\u11AB",
      "\u1102\u1161\u1112\u1173\u11AF",
      "\u1102\u1161\u11A8\u110B\u1167\u11B8",
      "\u1102\u1161\u11AB\u1107\u1161\u11BC",
      "\u1102\u1161\u11AF\u1100\u1162",
      "\u1102\u1161\u11AF\u110A\u1175",
      "\u1102\u1161\u11AF\u110D\u1161",
      "\u1102\u1161\u11B7\u1102\u1167",
      "\u1102\u1161\u11B7\u1103\u1162\u1106\u116E\u11AB",
      "\u1102\u1161\u11B7\u1106\u1162",
      "\u1102\u1161\u11B7\u1109\u1161\u11AB",
      "\u1102\u1161\u11B7\u110C\u1161",
      "\u1102\u1161\u11B7\u1111\u1167\u11AB",
      "\u1102\u1161\u11B7\u1112\u1161\u11A8\u1109\u1162\u11BC",
      "\u1102\u1161\u11BC\u1107\u1175",
      "\u1102\u1161\u11C0\u1106\u1161\u11AF",
      "\u1102\u1162\u1102\u1167\u11AB",
      "\u1102\u1162\u110B\u116D\u11BC",
      "\u1102\u1162\u110B\u1175\u11AF",
      "\u1102\u1162\u11B7\u1107\u1175",
      "\u1102\u1162\u11B7\u1109\u1162",
      "\u1102\u1162\u11BA\u1106\u116E\u11AF",
      "\u1102\u1162\u11BC\u1103\u1169\u11BC",
      "\u1102\u1162\u11BC\u1106\u1167\u11AB",
      "\u1102\u1162\u11BC\u1107\u1161\u11BC",
      "\u1102\u1162\u11BC\u110C\u1161\u11BC\u1100\u1169",
      "\u1102\u1166\u11A8\u1110\u1161\u110B\u1175",
      "\u1102\u1166\u11BA\u110D\u1162",
      "\u1102\u1169\u1103\u1169\u11BC",
      "\u1102\u1169\u1105\u1161\u11AB\u1109\u1162\u11A8",
      "\u1102\u1169\u1105\u1167\u11A8",
      "\u1102\u1169\u110B\u1175\u11AB",
      "\u1102\u1169\u11A8\u110B\u1173\u11B7",
      "\u1102\u1169\u11A8\u110E\u1161",
      "\u1102\u1169\u11A8\u1112\u116A",
      "\u1102\u1169\u11AB\u1105\u1175",
      "\u1102\u1169\u11AB\u1106\u116E\u11AB",
      "\u1102\u1169\u11AB\u110C\u1162\u11BC",
      "\u1102\u1169\u11AF\u110B\u1175",
      "\u1102\u1169\u11BC\u1100\u116E",
      "\u1102\u1169\u11BC\u1103\u1161\u11B7",
      "\u1102\u1169\u11BC\u1106\u1175\u11AB",
      "\u1102\u1169\u11BC\u1107\u116E",
      "\u1102\u1169\u11BC\u110B\u1165\u11B8",
      "\u1102\u1169\u11BC\u110C\u1161\u11BC",
      "\u1102\u1169\u11BC\u110E\u1169\u11AB",
      "\u1102\u1169\u11C1\u110B\u1175",
      "\u1102\u116E\u11AB\u1103\u1169\u11BC\u110C\u1161",
      "\u1102\u116E\u11AB\u1106\u116E\u11AF",
      "\u1102\u116E\u11AB\u110A\u1165\u11B8",
      "\u1102\u1172\u110B\u116D\u11A8",
      "\u1102\u1173\u1101\u1175\u11B7",
      "\u1102\u1173\u11A8\u1103\u1162",
      "\u1102\u1173\u11BC\u1103\u1169\u11BC\u110C\u1165\u11A8",
      "\u1102\u1173\u11BC\u1105\u1167\u11A8",
      "\u1103\u1161\u1107\u1161\u11BC",
      "\u1103\u1161\u110B\u1163\u11BC\u1109\u1165\u11BC",
      "\u1103\u1161\u110B\u1173\u11B7",
      "\u1103\u1161\u110B\u1175\u110B\u1165\u1110\u1173",
      "\u1103\u1161\u1112\u1162\u11BC",
      "\u1103\u1161\u11AB\u1100\u1168",
      "\u1103\u1161\u11AB\u1100\u1169\u11AF",
      "\u1103\u1161\u11AB\u1103\u1169\u11A8",
      "\u1103\u1161\u11AB\u1106\u1161\u11BA",
      "\u1103\u1161\u11AB\u1109\u116E\u11AB",
      "\u1103\u1161\u11AB\u110B\u1165",
      "\u1103\u1161\u11AB\u110B\u1171",
      "\u1103\u1161\u11AB\u110C\u1165\u11B7",
      "\u1103\u1161\u11AB\u110E\u1166",
      "\u1103\u1161\u11AB\u110E\u116E",
      "\u1103\u1161\u11AB\u1111\u1167\u11AB",
      "\u1103\u1161\u11AB\u1111\u116E\u11BC",
      "\u1103\u1161\u11AF\u1100\u1163\u11AF",
      "\u1103\u1161\u11AF\u1105\u1165",
      "\u1103\u1161\u11AF\u1105\u1167\u11A8",
      "\u1103\u1161\u11AF\u1105\u1175",
      "\u1103\u1161\u11B0\u1100\u1169\u1100\u1175",
      "\u1103\u1161\u11B7\u1103\u1161\u11BC",
      "\u1103\u1161\u11B7\u1107\u1162",
      "\u1103\u1161\u11B7\u110B\u116D",
      "\u1103\u1161\u11B7\u110B\u1175\u11B7",
      "\u1103\u1161\u11B8\u1107\u1167\u11AB",
      "\u1103\u1161\u11B8\u110C\u1161\u11BC",
      "\u1103\u1161\u11BC\u1100\u1173\u11AB",
      "\u1103\u1161\u11BC\u1107\u116E\u11AB\u1100\u1161\u11AB",
      "\u1103\u1161\u11BC\u110B\u1167\u11AB\u1112\u1175",
      "\u1103\u1161\u11BC\u110C\u1161\u11BC",
      "\u1103\u1162\u1100\u1172\u1106\u1169",
      "\u1103\u1162\u1102\u1161\u11BD",
      "\u1103\u1162\u1103\u1161\u11AB\u1112\u1175",
      "\u1103\u1162\u1103\u1161\u11B8",
      "\u1103\u1162\u1103\u1169\u1109\u1175",
      "\u1103\u1162\u1105\u1163\u11A8",
      "\u1103\u1162\u1105\u1163\u11BC",
      "\u1103\u1162\u1105\u1172\u11A8",
      "\u1103\u1162\u1106\u116E\u11AB",
      "\u1103\u1162\u1107\u116E\u1107\u116E\u11AB",
      "\u1103\u1162\u1109\u1175\u11AB",
      "\u1103\u1162\u110B\u1173\u11BC",
      "\u1103\u1162\u110C\u1161\u11BC",
      "\u1103\u1162\u110C\u1165\u11AB",
      "\u1103\u1162\u110C\u1165\u11B8",
      "\u1103\u1162\u110C\u116E\u11BC",
      "\u1103\u1162\u110E\u1162\u11A8",
      "\u1103\u1162\u110E\u116E\u11AF",
      "\u1103\u1162\u110E\u116E\u11BC",
      "\u1103\u1162\u1110\u1169\u11BC\u1105\u1167\u11BC",
      "\u1103\u1162\u1112\u1161\u11A8",
      "\u1103\u1162\u1112\u1161\u11AB\u1106\u1175\u11AB\u1100\u116E\u11A8",
      "\u1103\u1162\u1112\u1161\u11B8\u1109\u1175\u11AF",
      "\u1103\u1162\u1112\u1167\u11BC",
      "\u1103\u1165\u11BC\u110B\u1165\u1105\u1175",
      "\u1103\u1166\u110B\u1175\u1110\u1173",
      "\u1103\u1169\u1103\u1162\u110E\u1166",
      "\u1103\u1169\u1103\u1165\u11A8",
      "\u1103\u1169\u1103\u116E\u11A8",
      "\u1103\u1169\u1106\u1161\u11BC",
      "\u1103\u1169\u1109\u1165\u1100\u116A\u11AB",
      "\u1103\u1169\u1109\u1175\u11B7",
      "\u1103\u1169\u110B\u116E\u11B7",
      "\u1103\u1169\u110B\u1175\u11B8",
      "\u1103\u1169\u110C\u1161\u1100\u1175",
      "\u1103\u1169\u110C\u1165\u1112\u1175",
      "\u1103\u1169\u110C\u1165\u11AB",
      "\u1103\u1169\u110C\u116E\u11BC",
      "\u1103\u1169\u110E\u1161\u11A8",
      "\u1103\u1169\u11A8\u1100\u1161\u11B7",
      "\u1103\u1169\u11A8\u1105\u1175\u11B8",
      "\u1103\u1169\u11A8\u1109\u1165",
      "\u1103\u1169\u11A8\u110B\u1175\u11AF",
      "\u1103\u1169\u11A8\u110E\u1161\u11BC\u110C\u1165\u11A8",
      "\u1103\u1169\u11BC\u1112\u116A\u110E\u1162\u11A8",
      "\u1103\u1171\u11BA\u1106\u1169\u1109\u1173\u11B8",
      "\u1103\u1171\u11BA\u1109\u1161\u11AB",
      "\u1104\u1161\u11AF\u110B\u1161\u110B\u1175",
      "\u1106\u1161\u1102\u116E\u1105\u1161",
      "\u1106\u1161\u1102\u1173\u11AF",
      "\u1106\u1161\u1103\u1161\u11BC",
      "\u1106\u1161\u1105\u1161\u1110\u1169\u11AB",
      "\u1106\u1161\u1105\u1167\u11AB",
      "\u1106\u1161\u1106\u116E\u1105\u1175",
      "\u1106\u1161\u1109\u1161\u110C\u1175",
      "\u1106\u1161\u110B\u1163\u11A8",
      "\u1106\u1161\u110B\u116D\u1102\u1166\u110C\u1173",
      "\u1106\u1161\u110B\u1173\u11AF",
      "\u1106\u1161\u110B\u1173\u11B7",
      "\u1106\u1161\u110B\u1175\u110F\u1173",
      "\u1106\u1161\u110C\u116E\u11BC",
      "\u1106\u1161\u110C\u1175\u1106\u1161\u11A8",
      "\u1106\u1161\u110E\u1161\u11AB\u1100\u1161\u110C\u1175",
      "\u1106\u1161\u110E\u1161\u11AF",
      "\u1106\u1161\u1112\u1173\u11AB",
      "\u1106\u1161\u11A8\u1100\u1165\u11AF\u1105\u1175",
      "\u1106\u1161\u11A8\u1102\u1162",
      "\u1106\u1161\u11A8\u1109\u1161\u11BC",
      "\u1106\u1161\u11AB\u1102\u1161\u11B7",
      "\u1106\u1161\u11AB\u1103\u116E",
      "\u1106\u1161\u11AB\u1109\u1166",
      "\u1106\u1161\u11AB\u110B\u1163\u11A8",
      "\u1106\u1161\u11AB\u110B\u1175\u11AF",
      "\u1106\u1161\u11AB\u110C\u1165\u11B7",
      "\u1106\u1161\u11AB\u110C\u1169\u11A8",
      "\u1106\u1161\u11AB\u1112\u116A",
      "\u1106\u1161\u11AD\u110B\u1175",
      "\u1106\u1161\u11AF\u1100\u1175",
      "\u1106\u1161\u11AF\u110A\u1173\u11B7",
      "\u1106\u1161\u11AF\u1110\u116E",
      "\u1106\u1161\u11B7\u1103\u1162\u1105\u1169",
      "\u1106\u1161\u11BC\u110B\u116F\u11AB\u1100\u1167\u11BC",
      "\u1106\u1162\u1102\u1167\u11AB",
      "\u1106\u1162\u1103\u1161\u11AF",
      "\u1106\u1162\u1105\u1167\u11A8",
      "\u1106\u1162\u1107\u1165\u11AB",
      "\u1106\u1162\u1109\u1173\u110F\u1165\u11B7",
      "\u1106\u1162\u110B\u1175\u11AF",
      "\u1106\u1162\u110C\u1161\u11BC",
      "\u1106\u1162\u11A8\u110C\u116E",
      "\u1106\u1165\u11A8\u110B\u1175",
      "\u1106\u1165\u11AB\u110C\u1165",
      "\u1106\u1165\u11AB\u110C\u1175",
      "\u1106\u1165\u11AF\u1105\u1175",
      "\u1106\u1166\u110B\u1175\u11AF",
      "\u1106\u1167\u1102\u1173\u1105\u1175",
      "\u1106\u1167\u110E\u1175\u11AF",
      "\u1106\u1167\u11AB\u1103\u1161\u11B7",
      "\u1106\u1167\u11AF\u110E\u1175",
      "\u1106\u1167\u11BC\u1103\u1161\u11AB",
      "\u1106\u1167\u11BC\u1105\u1167\u11BC",
      "\u1106\u1167\u11BC\u110B\u1168",
      "\u1106\u1167\u11BC\u110B\u1174",
      "\u1106\u1167\u11BC\u110C\u1165\u11AF",
      "\u1106\u1167\u11BC\u110E\u1175\u11BC",
      "\u1106\u1167\u11BC\u1112\u1161\u11B7",
      "\u1106\u1169\u1100\u1173\u11B7",
      "\u1106\u1169\u1102\u1175\u1110\u1165",
      "\u1106\u1169\u1103\u1166\u11AF",
      "\u1106\u1169\u1103\u1173\u11AB",
      "\u1106\u1169\u1107\u1165\u11B7",
      "\u1106\u1169\u1109\u1173\u11B8",
      "\u1106\u1169\u110B\u1163\u11BC",
      "\u1106\u1169\u110B\u1175\u11B7",
      "\u1106\u1169\u110C\u1169\u1105\u1175",
      "\u1106\u1169\u110C\u1175\u11B8",
      "\u1106\u1169\u1110\u116E\u11BC\u110B\u1175",
      "\u1106\u1169\u11A8\u1100\u1165\u11AF\u110B\u1175",
      "\u1106\u1169\u11A8\u1105\u1169\u11A8",
      "\u1106\u1169\u11A8\u1109\u1161",
      "\u1106\u1169\u11A8\u1109\u1169\u1105\u1175",
      "\u1106\u1169\u11A8\u1109\u116E\u11B7",
      "\u1106\u1169\u11A8\u110C\u1165\u11A8",
      "\u1106\u1169\u11A8\u1111\u116D",
      "\u1106\u1169\u11AF\u1105\u1162",
      "\u1106\u1169\u11B7\u1106\u1162",
      "\u1106\u1169\u11B7\u1106\u116E\u1100\u1166",
      "\u1106\u1169\u11B7\u1109\u1161\u11AF",
      "\u1106\u1169\u11B7\u1109\u1169\u11A8",
      "\u1106\u1169\u11B7\u110C\u1175\u11BA",
      "\u1106\u1169\u11B7\u1110\u1169\u11BC",
      "\u1106\u1169\u11B8\u1109\u1175",
      "\u1106\u116E\u1100\u116A\u11AB\u1109\u1175\u11B7",
      "\u1106\u116E\u1100\u116E\u11BC\u1112\u116A",
      "\u1106\u116E\u1103\u1165\u110B\u1171",
      "\u1106\u116E\u1103\u1165\u11B7",
      "\u1106\u116E\u1105\u1173\u11C1",
      "\u1106\u116E\u1109\u1173\u11AB",
      "\u1106\u116E\u110B\u1165\u11BA",
      "\u1106\u116E\u110B\u1167\u11A8",
      "\u1106\u116E\u110B\u116D\u11BC",
      "\u1106\u116E\u110C\u1169\u1100\u1165\u11AB",
      "\u1106\u116E\u110C\u1175\u1100\u1162",
      "\u1106\u116E\u110E\u1165\u11A8",
      "\u1106\u116E\u11AB\u1100\u116E",
      "\u1106\u116E\u11AB\u1103\u1173\u11A8",
      "\u1106\u116E\u11AB\u1107\u1165\u11B8",
      "\u1106\u116E\u11AB\u1109\u1165",
      "\u1106\u116E\u11AB\u110C\u1166",
      "\u1106\u116E\u11AB\u1112\u1161\u11A8",
      "\u1106\u116E\u11AB\u1112\u116A",
      "\u1106\u116E\u11AF\u1100\u1161",
      "\u1106\u116E\u11AF\u1100\u1165\u11AB",
      "\u1106\u116E\u11AF\u1100\u1167\u11AF",
      "\u1106\u116E\u11AF\u1100\u1169\u1100\u1175",
      "\u1106\u116E\u11AF\u1105\u1169\u11AB",
      "\u1106\u116E\u11AF\u1105\u1175\u1112\u1161\u11A8",
      "\u1106\u116E\u11AF\u110B\u1173\u11B7",
      "\u1106\u116E\u11AF\u110C\u1175\u11AF",
      "\u1106\u116E\u11AF\u110E\u1166",
      "\u1106\u1175\u1100\u116E\u11A8",
      "\u1106\u1175\u1103\u1175\u110B\u1165",
      "\u1106\u1175\u1109\u1161\u110B\u1175\u11AF",
      "\u1106\u1175\u1109\u116E\u11AF",
      "\u1106\u1175\u110B\u1167\u11A8",
      "\u1106\u1175\u110B\u116D\u11BC\u1109\u1175\u11AF",
      "\u1106\u1175\u110B\u116E\u11B7",
      "\u1106\u1175\u110B\u1175\u11AB",
      "\u1106\u1175\u1110\u1175\u11BC",
      "\u1106\u1175\u1112\u1169\u11AB",
      "\u1106\u1175\u11AB\u1100\u1161\u11AB",
      "\u1106\u1175\u11AB\u110C\u1169\u11A8",
      "\u1106\u1175\u11AB\u110C\u116E",
      "\u1106\u1175\u11AE\u110B\u1173\u11B7",
      "\u1106\u1175\u11AF\u1100\u1161\u1105\u116E",
      "\u1106\u1175\u11AF\u1105\u1175\u1106\u1175\u1110\u1165",
      "\u1106\u1175\u11C0\u1107\u1161\u1103\u1161\u11A8",
      "\u1107\u1161\u1100\u1161\u110C\u1175",
      "\u1107\u1161\u1100\u116E\u1102\u1175",
      "\u1107\u1161\u1102\u1161\u1102\u1161",
      "\u1107\u1161\u1102\u1173\u11AF",
      "\u1107\u1161\u1103\u1161\u11A8",
      "\u1107\u1161\u1103\u1161\u11BA\u1100\u1161",
      "\u1107\u1161\u1105\u1161\u11B7",
      "\u1107\u1161\u110B\u1175\u1105\u1165\u1109\u1173",
      "\u1107\u1161\u1110\u1161\u11BC",
      "\u1107\u1161\u11A8\u1106\u116E\u11AF\u1100\u116A\u11AB",
      "\u1107\u1161\u11A8\u1109\u1161",
      "\u1107\u1161\u11A8\u1109\u116E",
      "\u1107\u1161\u11AB\u1103\u1162",
      "\u1107\u1161\u11AB\u1103\u1173\u1109\u1175",
      "\u1107\u1161\u11AB\u1106\u1161\u11AF",
      "\u1107\u1161\u11AB\u1107\u1161\u11AF",
      "\u1107\u1161\u11AB\u1109\u1165\u11BC",
      "\u1107\u1161\u11AB\u110B\u1173\u11BC",
      "\u1107\u1161\u11AB\u110C\u1161\u11BC",
      "\u1107\u1161\u11AB\u110C\u116E\u11A8",
      "\u1107\u1161\u11AB\u110C\u1175",
      "\u1107\u1161\u11AB\u110E\u1161\u11AB",
      "\u1107\u1161\u11AE\u110E\u1175\u11B7",
      "\u1107\u1161\u11AF\u1100\u1161\u1105\u1161\u11A8",
      "\u1107\u1161\u11AF\u1100\u1165\u11AF\u110B\u1173\u11B7",
      "\u1107\u1161\u11AF\u1100\u1167\u11AB",
      "\u1107\u1161\u11AF\u1103\u1161\u11AF",
      "\u1107\u1161\u11AF\u1105\u1166",
      "\u1107\u1161\u11AF\u1106\u1169\u11A8",
      "\u1107\u1161\u11AF\u1107\u1161\u1103\u1161\u11A8",
      "\u1107\u1161\u11AF\u1109\u1162\u11BC",
      "\u1107\u1161\u11AF\u110B\u1173\u11B7",
      "\u1107\u1161\u11AF\u110C\u1161\u1100\u116E\u11A8",
      "\u1107\u1161\u11AF\u110C\u1165\u11AB",
      "\u1107\u1161\u11AF\u1110\u1169\u11B8",
      "\u1107\u1161\u11AF\u1111\u116D",
      "\u1107\u1161\u11B7\u1112\u1161\u1102\u1173\u11AF",
      "\u1107\u1161\u11B8\u1100\u1173\u1105\u1173\u11BA",
      "\u1107\u1161\u11B8\u1106\u1161\u11BA",
      "\u1107\u1161\u11B8\u1109\u1161\u11BC",
      "\u1107\u1161\u11B8\u1109\u1169\u11C0",
      "\u1107\u1161\u11BC\u1100\u1173\u11B7",
      "\u1107\u1161\u11BC\u1106\u1167\u11AB",
      "\u1107\u1161\u11BC\u1106\u116E\u11AB",
      "\u1107\u1161\u11BC\u1107\u1161\u1103\u1161\u11A8",
      "\u1107\u1161\u11BC\u1107\u1165\u11B8",
      "\u1107\u1161\u11BC\u1109\u1169\u11BC",
      "\u1107\u1161\u11BC\u1109\u1175\u11A8",
      "\u1107\u1161\u11BC\u110B\u1161\u11AB",
      "\u1107\u1161\u11BC\u110B\u116E\u11AF",
      "\u1107\u1161\u11BC\u110C\u1175",
      "\u1107\u1161\u11BC\u1112\u1161\u11A8",
      "\u1107\u1161\u11BC\u1112\u1162",
      "\u1107\u1161\u11BC\u1112\u1163\u11BC",
      "\u1107\u1162\u1100\u1167\u11BC",
      "\u1107\u1162\u1101\u1169\u11B8",
      "\u1107\u1162\u1103\u1161\u11AF",
      "\u1107\u1162\u1103\u1173\u1106\u1175\u11AB\u1110\u1165\u11AB",
      "\u1107\u1162\u11A8\u1103\u116E\u1109\u1161\u11AB",
      "\u1107\u1162\u11A8\u1109\u1162\u11A8",
      "\u1107\u1162\u11A8\u1109\u1165\u11BC",
      "\u1107\u1162\u11A8\u110B\u1175\u11AB",
      "\u1107\u1162\u11A8\u110C\u1166",
      "\u1107\u1162\u11A8\u1112\u116A\u110C\u1165\u11B7",
      "\u1107\u1165\u1105\u1173\u11BA",
      "\u1107\u1165\u1109\u1165\u11BA",
      "\u1107\u1165\u1110\u1173\u11AB",
      "\u1107\u1165\u11AB\u1100\u1162",
      "\u1107\u1165\u11AB\u110B\u1167\u11A8",
      "\u1107\u1165\u11AB\u110C\u1175",
      "\u1107\u1165\u11AB\u1112\u1169",
      "\u1107\u1165\u11AF\u1100\u1173\u11B7",
      "\u1107\u1165\u11AF\u1105\u1166",
      "\u1107\u1165\u11AF\u110A\u1165",
      "\u1107\u1165\u11B7\u110B\u1171",
      "\u1107\u1165\u11B7\u110B\u1175\u11AB",
      "\u1107\u1165\u11B7\u110C\u116C",
      "\u1107\u1165\u11B8\u1105\u1172\u11AF",
      "\u1107\u1165\u11B8\u110B\u116F\u11AB",
      "\u1107\u1165\u11B8\u110C\u1165\u11A8",
      "\u1107\u1165\u11B8\u110E\u1175\u11A8",
      "\u1107\u1166\u110B\u1175\u110C\u1175\u11BC",
      "\u1107\u1166\u11AF\u1110\u1173",
      "\u1107\u1167\u11AB\u1100\u1167\u11BC",
      "\u1107\u1167\u11AB\u1103\u1169\u11BC",
      "\u1107\u1167\u11AB\u1106\u1167\u11BC",
      "\u1107\u1167\u11AB\u1109\u1175\u11AB",
      "\u1107\u1167\u11AB\u1112\u1169\u1109\u1161",
      "\u1107\u1167\u11AB\u1112\u116A",
      "\u1107\u1167\u11AF\u1103\u1169",
      "\u1107\u1167\u11AF\u1106\u1167\u11BC",
      "\u1107\u1167\u11AF\u110B\u1175\u11AF",
      "\u1107\u1167\u11BC\u1109\u1175\u11AF",
      "\u1107\u1167\u11BC\u110B\u1161\u1105\u1175",
      "\u1107\u1167\u11BC\u110B\u116F\u11AB",
      "\u1107\u1169\u1100\u116A\u11AB",
      "\u1107\u1169\u1102\u1165\u1109\u1173",
      "\u1107\u1169\u1105\u1161\u1109\u1162\u11A8",
      "\u1107\u1169\u1105\u1161\u11B7",
      "\u1107\u1169\u1105\u1173\u11B7",
      "\u1107\u1169\u1109\u1161\u11BC",
      "\u1107\u1169\u110B\u1161\u11AB",
      "\u1107\u1169\u110C\u1161\u1100\u1175",
      "\u1107\u1169\u110C\u1161\u11BC",
      "\u1107\u1169\u110C\u1165\u11AB",
      "\u1107\u1169\u110C\u1169\u11AB",
      "\u1107\u1169\u1110\u1169\u11BC",
      "\u1107\u1169\u1111\u1167\u11AB\u110C\u1165\u11A8",
      "\u1107\u1169\u1112\u1165\u11B7",
      "\u1107\u1169\u11A8\u1103\u1169",
      "\u1107\u1169\u11A8\u1109\u1161",
      "\u1107\u1169\u11A8\u1109\u116E\u11BC\u110B\u1161",
      "\u1107\u1169\u11A8\u1109\u1173\u11B8",
      "\u1107\u1169\u11A9\u110B\u1173\u11B7",
      "\u1107\u1169\u11AB\u1100\u1167\u11A8\u110C\u1165\u11A8",
      "\u1107\u1169\u11AB\u1105\u1162",
      "\u1107\u1169\u11AB\u1107\u116E",
      "\u1107\u1169\u11AB\u1109\u1161",
      "\u1107\u1169\u11AB\u1109\u1165\u11BC",
      "\u1107\u1169\u11AB\u110B\u1175\u11AB",
      "\u1107\u1169\u11AB\u110C\u1175\u11AF",
      "\u1107\u1169\u11AF\u1111\u1166\u11AB",
      "\u1107\u1169\u11BC\u1109\u1161",
      "\u1107\u1169\u11BC\u110C\u1175",
      "\u1107\u1169\u11BC\u1110\u116E",
      "\u1107\u116E\u1100\u1173\u11AB",
      "\u1107\u116E\u1101\u1173\u1105\u1165\u110B\u116E\u11B7",
      "\u1107\u116E\u1103\u1161\u11B7",
      "\u1107\u116E\u1103\u1169\u11BC\u1109\u1161\u11AB",
      "\u1107\u116E\u1106\u116E\u11AB",
      "\u1107\u116E\u1107\u116E\u11AB",
      "\u1107\u116E\u1109\u1161\u11AB",
      "\u1107\u116E\u1109\u1161\u11BC",
      "\u1107\u116E\u110B\u1165\u11BF",
      "\u1107\u116E\u110B\u1175\u11AB",
      "\u1107\u116E\u110C\u1161\u11A8\u110B\u116D\u11BC",
      "\u1107\u116E\u110C\u1161\u11BC",
      "\u1107\u116E\u110C\u1165\u11BC",
      "\u1107\u116E\u110C\u1169\u11A8",
      "\u1107\u116E\u110C\u1175\u1105\u1165\u11AB\u1112\u1175",
      "\u1107\u116E\u110E\u1175\u11AB",
      "\u1107\u116E\u1110\u1161\u11A8",
      "\u1107\u116E\u1111\u116E\u11B7",
      "\u1107\u116E\u1112\u116C\u110C\u1161\u11BC",
      "\u1107\u116E\u11A8\u1107\u116E",
      "\u1107\u116E\u11A8\u1112\u1161\u11AB",
      "\u1107\u116E\u11AB\u1102\u1169",
      "\u1107\u116E\u11AB\u1105\u1163\u11BC",
      "\u1107\u116E\u11AB\u1105\u1175",
      "\u1107\u116E\u11AB\u1106\u1167\u11BC",
      "\u1107\u116E\u11AB\u1109\u1165\u11A8",
      "\u1107\u116E\u11AB\u110B\u1163",
      "\u1107\u116E\u11AB\u110B\u1171\u1100\u1175",
      "\u1107\u116E\u11AB\u1111\u1175\u11AF",
      "\u1107\u116E\u11AB\u1112\u1169\u11BC\u1109\u1162\u11A8",
      "\u1107\u116E\u11AF\u1100\u1169\u1100\u1175",
      "\u1107\u116E\u11AF\u1100\u116A",
      "\u1107\u116E\u11AF\u1100\u116D",
      "\u1107\u116E\u11AF\u1101\u1169\u11BE",
      "\u1107\u116E\u11AF\u1106\u1161\u11AB",
      "\u1107\u116E\u11AF\u1107\u1165\u11B8",
      "\u1107\u116E\u11AF\u1107\u1175\u11BE",
      "\u1107\u116E\u11AF\u110B\u1161\u11AB",
      "\u1107\u116E\u11AF\u110B\u1175\u110B\u1175\u11A8",
      "\u1107\u116E\u11AF\u1112\u1162\u11BC",
      "\u1107\u1173\u1105\u1162\u11AB\u1103\u1173",
      "\u1107\u1175\u1100\u1173\u11A8",
      "\u1107\u1175\u1102\u1161\u11AB",
      "\u1107\u1175\u1102\u1175\u11AF",
      "\u1107\u1175\u1103\u116E\u11AF\u1100\u1175",
      "\u1107\u1175\u1103\u1175\u110B\u1169",
      "\u1107\u1175\u1105\u1169\u1109\u1169",
      "\u1107\u1175\u1106\u1161\u11AB",
      "\u1107\u1175\u1106\u1167\u11BC",
      "\u1107\u1175\u1106\u1175\u11AF",
      "\u1107\u1175\u1107\u1161\u1105\u1161\u11B7",
      "\u1107\u1175\u1107\u1175\u11B7\u1107\u1161\u11B8",
      "\u1107\u1175\u1109\u1161\u11BC",
      "\u1107\u1175\u110B\u116D\u11BC",
      "\u1107\u1175\u110B\u1172\u11AF",
      "\u1107\u1175\u110C\u116E\u11BC",
      "\u1107\u1175\u1110\u1161\u1106\u1175\u11AB",
      "\u1107\u1175\u1111\u1161\u11AB",
      "\u1107\u1175\u11AF\u1103\u1175\u11BC",
      "\u1107\u1175\u11BA\u1106\u116E\u11AF",
      "\u1107\u1175\u11BA\u1107\u1161\u11BC\u110B\u116E\u11AF",
      "\u1107\u1175\u11BA\u110C\u116E\u11AF\u1100\u1175",
      "\u1107\u1175\u11BE\u1101\u1161\u11AF",
      "\u1108\u1161\u11AF\u1100\u1161\u11AB\u1109\u1162\u11A8",
      "\u1108\u1161\u11AF\u1105\u1162",
      "\u1108\u1161\u11AF\u1105\u1175",
      "\u1109\u1161\u1100\u1165\u11AB",
      "\u1109\u1161\u1100\u1168\u110C\u1165\u11AF",
      "\u1109\u1161\u1102\u1161\u110B\u1175",
      "\u1109\u1161\u1102\u1163\u11BC",
      "\u1109\u1161\u1105\u1161\u11B7",
      "\u1109\u1161\u1105\u1161\u11BC",
      "\u1109\u1161\u1105\u1175\u11B8",
      "\u1109\u1161\u1106\u1169\u1102\u1175\u11B7",
      "\u1109\u1161\u1106\u116E\u11AF",
      "\u1109\u1161\u1107\u1161\u11BC",
      "\u1109\u1161\u1109\u1161\u11BC",
      "\u1109\u1161\u1109\u1162\u11BC\u1112\u116A\u11AF",
      "\u1109\u1161\u1109\u1165\u11AF",
      "\u1109\u1161\u1109\u1173\u11B7",
      "\u1109\u1161\u1109\u1175\u11AF",
      "\u1109\u1161\u110B\u1165\u11B8",
      "\u1109\u1161\u110B\u116D\u11BC",
      "\u1109\u1161\u110B\u116F\u11AF",
      "\u1109\u1161\u110C\u1161\u11BC",
      "\u1109\u1161\u110C\u1165\u11AB",
      "\u1109\u1161\u110C\u1175\u11AB",
      "\u1109\u1161\u110E\u1169\u11AB",
      "\u1109\u1161\u110E\u116E\u11AB\u1100\u1175",
      "\u1109\u1161\u1110\u1161\u11BC",
      "\u1109\u1161\u1110\u116E\u1105\u1175",
      "\u1109\u1161\u1112\u1173\u11AF",
      "\u1109\u1161\u11AB\u1100\u1175\u11AF",
      "\u1109\u1161\u11AB\u1107\u116E\u110B\u1175\u11AB\u1100\u116A",
      "\u1109\u1161\u11AB\u110B\u1165\u11B8",
      "\u1109\u1161\u11AB\u110E\u1162\u11A8",
      "\u1109\u1161\u11AF\u1105\u1175\u11B7",
      "\u1109\u1161\u11AF\u110B\u1175\u11AB",
      "\u1109\u1161\u11AF\u110D\u1161\u11A8",
      "\u1109\u1161\u11B7\u1100\u1168\u1110\u1161\u11BC",
      "\u1109\u1161\u11B7\u1100\u116E\u11A8",
      "\u1109\u1161\u11B7\u1109\u1175\u11B8",
      "\u1109\u1161\u11B7\u110B\u116F\u11AF",
      "\u1109\u1161\u11B7\u110E\u1169\u11AB",
      "\u1109\u1161\u11BC\u1100\u116A\u11AB",
      "\u1109\u1161\u11BC\u1100\u1173\u11B7",
      "\u1109\u1161\u11BC\u1103\u1162",
      "\u1109\u1161\u11BC\u1105\u1172",
      "\u1109\u1161\u11BC\u1107\u1161\u11AB\u1100\u1175",
      "\u1109\u1161\u11BC\u1109\u1161\u11BC",
      "\u1109\u1161\u11BC\u1109\u1175\u11A8",
      "\u1109\u1161\u11BC\u110B\u1165\u11B8",
      "\u1109\u1161\u11BC\u110B\u1175\u11AB",
      "\u1109\u1161\u11BC\u110C\u1161",
      "\u1109\u1161\u11BC\u110C\u1165\u11B7",
      "\u1109\u1161\u11BC\u110E\u1165",
      "\u1109\u1161\u11BC\u110E\u116E",
      "\u1109\u1161\u11BC\u1110\u1162",
      "\u1109\u1161\u11BC\u1111\u116D",
      "\u1109\u1161\u11BC\u1111\u116E\u11B7",
      "\u1109\u1161\u11BC\u1112\u116A\u11BC",
      "\u1109\u1162\u1107\u1167\u11A8",
      "\u1109\u1162\u11A8\u1101\u1161\u11AF",
      "\u1109\u1162\u11A8\u110B\u1167\u11AB\u1111\u1175\u11AF",
      "\u1109\u1162\u11BC\u1100\u1161\u11A8",
      "\u1109\u1162\u11BC\u1106\u1167\u11BC",
      "\u1109\u1162\u11BC\u1106\u116E\u11AF",
      "\u1109\u1162\u11BC\u1107\u1161\u11BC\u1109\u1169\u11BC",
      "\u1109\u1162\u11BC\u1109\u1161\u11AB",
      "\u1109\u1162\u11BC\u1109\u1165\u11AB",
      "\u1109\u1162\u11BC\u1109\u1175\u11AB",
      "\u1109\u1162\u11BC\u110B\u1175\u11AF",
      "\u1109\u1162\u11BC\u1112\u116A\u11AF",
      "\u1109\u1165\u1105\u1161\u11B8",
      "\u1109\u1165\u1105\u1173\u11AB",
      "\u1109\u1165\u1106\u1167\u11BC",
      "\u1109\u1165\u1106\u1175\u11AB",
      "\u1109\u1165\u1107\u1175\u1109\u1173",
      "\u1109\u1165\u110B\u1163\u11BC",
      "\u1109\u1165\u110B\u116E\u11AF",
      "\u1109\u1165\u110C\u1165\u11A8",
      "\u1109\u1165\u110C\u1165\u11B7",
      "\u1109\u1165\u110D\u1169\u11A8",
      "\u1109\u1165\u110F\u1173\u11AF",
      "\u1109\u1165\u11A8\u1109\u1161",
      "\u1109\u1165\u11A8\u110B\u1172",
      "\u1109\u1165\u11AB\u1100\u1165",
      "\u1109\u1165\u11AB\u1106\u116E\u11AF",
      "\u1109\u1165\u11AB\u1107\u1162",
      "\u1109\u1165\u11AB\u1109\u1162\u11BC",
      "\u1109\u1165\u11AB\u1109\u116E",
      "\u1109\u1165\u11AB\u110B\u116F\u11AB",
      "\u1109\u1165\u11AB\u110C\u1161\u11BC",
      "\u1109\u1165\u11AB\u110C\u1165\u11AB",
      "\u1109\u1165\u11AB\u1110\u1162\u11A8",
      "\u1109\u1165\u11AB\u1111\u116E\u11BC\u1100\u1175",
      "\u1109\u1165\u11AF\u1100\u1165\u110C\u1175",
      "\u1109\u1165\u11AF\u1102\u1161\u11AF",
      "\u1109\u1165\u11AF\u1105\u1165\u11BC\u1110\u1161\u11BC",
      "\u1109\u1165\u11AF\u1106\u1167\u11BC",
      "\u1109\u1165\u11AF\u1106\u116E\u11AB",
      "\u1109\u1165\u11AF\u1109\u1161",
      "\u1109\u1165\u11AF\u110B\u1161\u11A8\u1109\u1161\u11AB",
      "\u1109\u1165\u11AF\u110E\u1175",
      "\u1109\u1165\u11AF\u1110\u1161\u11BC",
      "\u1109\u1165\u11B8\u110A\u1175",
      "\u1109\u1165\u11BC\u1100\u1169\u11BC",
      "\u1109\u1165\u11BC\u1103\u1161\u11BC",
      "\u1109\u1165\u11BC\u1106\u1167\u11BC",
      "\u1109\u1165\u11BC\u1107\u1167\u11AF",
      "\u1109\u1165\u11BC\u110B\u1175\u11AB",
      "\u1109\u1165\u11BC\u110C\u1161\u11BC",
      "\u1109\u1165\u11BC\u110C\u1165\u11A8",
      "\u1109\u1165\u11BC\u110C\u1175\u11AF",
      "\u1109\u1165\u11BC\u1112\u1161\u11B7",
      "\u1109\u1166\u1100\u1173\u11B7",
      "\u1109\u1166\u1106\u1175\u1102\u1161",
      "\u1109\u1166\u1109\u1161\u11BC",
      "\u1109\u1166\u110B\u116F\u11AF",
      "\u1109\u1166\u110C\u1169\u11BC\u1103\u1162\u110B\u116A\u11BC",
      "\u1109\u1166\u1110\u1161\u11A8",
      "\u1109\u1166\u11AB\u1110\u1165",
      "\u1109\u1166\u11AB\u1110\u1175\u1106\u1175\u1110\u1165",
      "\u1109\u1166\u11BA\u110D\u1162",
      "\u1109\u1169\u1100\u1172\u1106\u1169",
      "\u1109\u1169\u1100\u1173\u11A8\u110C\u1165\u11A8",
      "\u1109\u1169\u1100\u1173\u11B7",
      "\u1109\u1169\u1102\u1161\u1100\u1175",
      "\u1109\u1169\u1102\u1167\u11AB",
      "\u1109\u1169\u1103\u1173\u11A8",
      "\u1109\u1169\u1106\u1161\u11BC",
      "\u1109\u1169\u1106\u116E\u11AB",
      "\u1109\u1169\u1109\u1165\u11AF",
      "\u1109\u1169\u1109\u1169\u11A8",
      "\u1109\u1169\u110B\u1161\u1100\u116A",
      "\u1109\u1169\u110B\u116D\u11BC",
      "\u1109\u1169\u110B\u116F\u11AB",
      "\u1109\u1169\u110B\u1173\u11B7",
      "\u1109\u1169\u110C\u116E\u11BC\u1112\u1175",
      "\u1109\u1169\u110C\u1175\u1111\u116E\u11B7",
      "\u1109\u1169\u110C\u1175\u11AF",
      "\u1109\u1169\u1111\u116E\u11BC",
      "\u1109\u1169\u1112\u1167\u11BC",
      "\u1109\u1169\u11A8\u1103\u1161\u11B7",
      "\u1109\u1169\u11A8\u1103\u1169",
      "\u1109\u1169\u11A8\u110B\u1169\u11BA",
      "\u1109\u1169\u11AB\u1100\u1161\u1105\u1161\u11A8",
      "\u1109\u1169\u11AB\u1100\u1175\u11AF",
      "\u1109\u1169\u11AB\u1102\u1167",
      "\u1109\u1169\u11AB\u1102\u1175\u11B7",
      "\u1109\u1169\u11AB\u1103\u1173\u11BC",
      "\u1109\u1169\u11AB\u1106\u1169\u11A8",
      "\u1109\u1169\u11AB\u1108\u1167\u11A8",
      "\u1109\u1169\u11AB\u1109\u1175\u11AF",
      "\u1109\u1169\u11AB\u110C\u1175\u11AF",
      "\u1109\u1169\u11AB\u1110\u1169\u11B8",
      "\u1109\u1169\u11AB\u1112\u1162",
      "\u1109\u1169\u11AF\u110C\u1175\u11A8\u1112\u1175",
      "\u1109\u1169\u11B7\u110A\u1175",
      "\u1109\u1169\u11BC\u110B\u1161\u110C\u1175",
      "\u1109\u1169\u11BC\u110B\u1175",
      "\u1109\u1169\u11BC\u1111\u1167\u11AB",
      "\u1109\u116C\u1100\u1169\u1100\u1175",
      "\u1109\u116D\u1111\u1175\u11BC",
      "\u1109\u116E\u1100\u1165\u11AB",
      "\u1109\u116E\u1102\u1167\u11AB",
      "\u1109\u116E\u1103\u1161\u11AB",
      "\u1109\u116E\u1103\u1169\u11BA\u1106\u116E\u11AF",
      "\u1109\u116E\u1103\u1169\u11BC\u110C\u1165\u11A8",
      "\u1109\u116E\u1106\u1167\u11AB",
      "\u1109\u116E\u1106\u1167\u11BC",
      "\u1109\u116E\u1107\u1161\u11A8",
      "\u1109\u116E\u1109\u1161\u11BC",
      "\u1109\u116E\u1109\u1165\u11A8",
      "\u1109\u116E\u1109\u116E\u11AF",
      "\u1109\u116E\u1109\u1175\u1105\u1169",
      "\u1109\u116E\u110B\u1165\u11B8",
      "\u1109\u116E\u110B\u1167\u11B7",
      "\u1109\u116E\u110B\u1167\u11BC",
      "\u1109\u116E\u110B\u1175\u11B8",
      "\u1109\u116E\u110C\u116E\u11AB",
      "\u1109\u116E\u110C\u1175\u11B8",
      "\u1109\u116E\u110E\u116E\u11AF",
      "\u1109\u116E\u110F\u1165\u11BA",
      "\u1109\u116E\u1111\u1175\u11AF",
      "\u1109\u116E\u1112\u1161\u11A8",
      "\u1109\u116E\u1112\u1165\u11B7\u1109\u1162\u11BC",
      "\u1109\u116E\u1112\u116A\u1100\u1175",
      "\u1109\u116E\u11A8\u1102\u1167",
      "\u1109\u116E\u11A8\u1109\u1169",
      "\u1109\u116E\u11A8\u110C\u1166",
      "\u1109\u116E\u11AB\u1100\u1161\u11AB",
      "\u1109\u116E\u11AB\u1109\u1165",
      "\u1109\u116E\u11AB\u1109\u116E",
      "\u1109\u116E\u11AB\u1109\u1175\u11A8\u1100\u1161\u11AB",
      "\u1109\u116E\u11AB\u110B\u1171",
      "\u1109\u116E\u11AE\u1100\u1161\u1105\u1161\u11A8",
      "\u1109\u116E\u11AF\u1107\u1167\u11BC",
      "\u1109\u116E\u11AF\u110C\u1175\u11B8",
      "\u1109\u116E\u11BA\u110C\u1161",
      "\u1109\u1173\u1102\u1175\u11B7",
      "\u1109\u1173\u1106\u116E\u11AF",
      "\u1109\u1173\u1109\u1173\u1105\u1169",
      "\u1109\u1173\u1109\u1173\u11BC",
      "\u1109\u1173\u110B\u1170\u1110\u1165",
      "\u1109\u1173\u110B\u1171\u110E\u1175",
      "\u1109\u1173\u110F\u1166\u110B\u1175\u1110\u1173",
      "\u1109\u1173\u1110\u1172\u1103\u1175\u110B\u1169",
      "\u1109\u1173\u1110\u1173\u1105\u1166\u1109\u1173",
      "\u1109\u1173\u1111\u1169\u110E\u1173",
      "\u1109\u1173\u11AF\u110D\u1165\u11A8",
      "\u1109\u1173\u11AF\u1111\u1173\u11B7",
      "\u1109\u1173\u11B8\u1100\u116A\u11AB",
      "\u1109\u1173\u11B8\u1100\u1175",
      "\u1109\u1173\u11BC\u1100\u1162\u11A8",
      "\u1109\u1173\u11BC\u1105\u1175",
      "\u1109\u1173\u11BC\u1107\u116E",
      "\u1109\u1173\u11BC\u110B\u116D\u11BC\u110E\u1161",
      "\u1109\u1173\u11BC\u110C\u1175\u11AB",
      "\u1109\u1175\u1100\u1161\u11A8",
      "\u1109\u1175\u1100\u1161\u11AB",
      "\u1109\u1175\u1100\u1169\u11AF",
      "\u1109\u1175\u1100\u1173\u11B7\u110E\u1175",
      "\u1109\u1175\u1102\u1161\u1105\u1175\u110B\u1169",
      "\u1109\u1175\u1103\u1162\u11A8",
      "\u1109\u1175\u1105\u1175\u110C\u1173",
      "\u1109\u1175\u1106\u1166\u11AB\u1110\u1173",
      "\u1109\u1175\u1106\u1175\u11AB",
      "\u1109\u1175\u1107\u116E\u1106\u1169",
      "\u1109\u1175\u1109\u1165\u11AB",
      "\u1109\u1175\u1109\u1165\u11AF",
      "\u1109\u1175\u1109\u1173\u1110\u1166\u11B7",
      "\u1109\u1175\u110B\u1161\u1107\u1165\u110C\u1175",
      "\u1109\u1175\u110B\u1165\u1106\u1165\u1102\u1175",
      "\u1109\u1175\u110B\u116F\u11AF",
      "\u1109\u1175\u110B\u1175\u11AB",
      "\u1109\u1175\u110B\u1175\u11AF",
      "\u1109\u1175\u110C\u1161\u11A8",
      "\u1109\u1175\u110C\u1161\u11BC",
      "\u1109\u1175\u110C\u1165\u11AF",
      "\u1109\u1175\u110C\u1165\u11B7",
      "\u1109\u1175\u110C\u116E\u11BC",
      "\u1109\u1175\u110C\u1173\u11AB",
      "\u1109\u1175\u110C\u1175\u11B8",
      "\u1109\u1175\u110E\u1165\u11BC",
      "\u1109\u1175\u1112\u1161\u11B8",
      "\u1109\u1175\u1112\u1165\u11B7",
      "\u1109\u1175\u11A8\u1100\u116E",
      "\u1109\u1175\u11A8\u1100\u1175",
      "\u1109\u1175\u11A8\u1103\u1161\u11BC",
      "\u1109\u1175\u11A8\u1105\u1163\u11BC",
      "\u1109\u1175\u11A8\u1105\u116D\u1111\u116E\u11B7",
      "\u1109\u1175\u11A8\u1106\u116E\u11AF",
      "\u1109\u1175\u11A8\u1108\u1161\u11BC",
      "\u1109\u1175\u11A8\u1109\u1161",
      "\u1109\u1175\u11A8\u1109\u1162\u11BC\u1112\u116A\u11AF",
      "\u1109\u1175\u11A8\u110E\u1169",
      "\u1109\u1175\u11A8\u1110\u1161\u11A8",
      "\u1109\u1175\u11A8\u1111\u116E\u11B7",
      "\u1109\u1175\u11AB\u1100\u1169",
      "\u1109\u1175\u11AB\u1100\u1172",
      "\u1109\u1175\u11AB\u1102\u1167\u11B7",
      "\u1109\u1175\u11AB\u1106\u116E\u11AB",
      "\u1109\u1175\u11AB\u1107\u1161\u11AF",
      "\u1109\u1175\u11AB\u1107\u1175",
      "\u1109\u1175\u11AB\u1109\u1161",
      "\u1109\u1175\u11AB\u1109\u1166",
      "\u1109\u1175\u11AB\u110B\u116D\u11BC",
      "\u1109\u1175\u11AB\u110C\u1166\u1111\u116E\u11B7",
      "\u1109\u1175\u11AB\u110E\u1165\u11BC",
      "\u1109\u1175\u11AB\u110E\u1166",
      "\u1109\u1175\u11AB\u1112\u116A",
      "\u1109\u1175\u11AF\u1100\u1161\u11B7",
      "\u1109\u1175\u11AF\u1102\u1162",
      "\u1109\u1175\u11AF\u1105\u1167\u11A8",
      "\u1109\u1175\u11AF\u1105\u1168",
      "\u1109\u1175\u11AF\u1106\u1161\u11BC",
      "\u1109\u1175\u11AF\u1109\u116E",
      "\u1109\u1175\u11AF\u1109\u1173\u11B8",
      "\u1109\u1175\u11AF\u1109\u1175",
      "\u1109\u1175\u11AF\u110C\u1161\u11BC",
      "\u1109\u1175\u11AF\u110C\u1165\u11BC",
      "\u1109\u1175\u11AF\u110C\u1175\u11AF\u110C\u1165\u11A8",
      "\u1109\u1175\u11AF\u110E\u1165\u11AB",
      "\u1109\u1175\u11AF\u110E\u1166",
      "\u1109\u1175\u11AF\u110F\u1165\u11BA",
      "\u1109\u1175\u11AF\u1110\u1162",
      "\u1109\u1175\u11AF\u1111\u1162",
      "\u1109\u1175\u11AF\u1112\u1165\u11B7",
      "\u1109\u1175\u11AF\u1112\u1167\u11AB",
      "\u1109\u1175\u11B7\u1105\u1175",
      "\u1109\u1175\u11B7\u1107\u116E\u1105\u1173\u11B7",
      "\u1109\u1175\u11B7\u1109\u1161",
      "\u1109\u1175\u11B7\u110C\u1161\u11BC",
      "\u1109\u1175\u11B7\u110C\u1165\u11BC",
      "\u1109\u1175\u11B7\u1111\u1161\u11AB",
      "\u110A\u1161\u11BC\u1103\u116E\u11BC\u110B\u1175",
      "\u110A\u1175\u1105\u1173\u11B7",
      "\u110A\u1175\u110B\u1161\u11BA",
      "\u110B\u1161\u1100\u1161\u110A\u1175",
      "\u110B\u1161\u1102\u1161\u110B\u116E\u11AB\u1109\u1165",
      "\u110B\u1161\u1103\u1173\u1102\u1175\u11B7",
      "\u110B\u1161\u1103\u1173\u11AF",
      "\u110B\u1161\u1109\u1171\u110B\u116E\u11B7",
      "\u110B\u1161\u1109\u1173\u1111\u1161\u11AF\u1110\u1173",
      "\u110B\u1161\u1109\u1175\u110B\u1161",
      "\u110B\u1161\u110B\u116E\u11AF\u1105\u1165",
      "\u110B\u1161\u110C\u1165\u110A\u1175",
      "\u110B\u1161\u110C\u116E\u11B7\u1106\u1161",
      "\u110B\u1161\u110C\u1175\u11A8",
      "\u110B\u1161\u110E\u1175\u11B7",
      "\u110B\u1161\u1111\u1161\u1110\u1173",
      "\u110B\u1161\u1111\u1173\u1105\u1175\u110F\u1161",
      "\u110B\u1161\u1111\u1173\u11B7",
      "\u110B\u1161\u1112\u1169\u11B8",
      "\u110B\u1161\u1112\u1173\u11AB",
      "\u110B\u1161\u11A8\u1100\u1175",
      "\u110B\u1161\u11A8\u1106\u1169\u11BC",
      "\u110B\u1161\u11A8\u1109\u116E",
      "\u110B\u1161\u11AB\u1100\u1162",
      "\u110B\u1161\u11AB\u1100\u1167\u11BC",
      "\u110B\u1161\u11AB\u1100\u116A",
      "\u110B\u1161\u11AB\u1102\u1162",
      "\u110B\u1161\u11AB\u1102\u1167\u11BC",
      "\u110B\u1161\u11AB\u1103\u1169\u11BC",
      "\u110B\u1161\u11AB\u1107\u1161\u11BC",
      "\u110B\u1161\u11AB\u1107\u116E",
      "\u110B\u1161\u11AB\u110C\u116E",
      "\u110B\u1161\u11AF\u1105\u116E\u1106\u1175\u1102\u1172\u11B7",
      "\u110B\u1161\u11AF\u110F\u1169\u110B\u1169\u11AF",
      "\u110B\u1161\u11B7\u1109\u1175",
      "\u110B\u1161\u11B7\u110F\u1165\u11BA",
      "\u110B\u1161\u11B8\u1105\u1167\u11A8",
      "\u110B\u1161\u11C1\u1102\u1161\u11AF",
      "\u110B\u1161\u11C1\u1106\u116E\u11AB",
      "\u110B\u1162\u110B\u1175\u11AB",
      "\u110B\u1162\u110C\u1165\u11BC",
      "\u110B\u1162\u11A8\u1109\u116E",
      "\u110B\u1162\u11AF\u1107\u1165\u11B7",
      "\u110B\u1163\u1100\u1161\u11AB",
      "\u110B\u1163\u1103\u1161\u11AB",
      "\u110B\u1163\u110B\u1169\u11BC",
      "\u110B\u1163\u11A8\u1100\u1161\u11AB",
      "\u110B\u1163\u11A8\u1100\u116E\u11A8",
      "\u110B\u1163\u11A8\u1109\u1169\u11A8",
      "\u110B\u1163\u11A8\u1109\u116E",
      "\u110B\u1163\u11A8\u110C\u1165\u11B7",
      "\u110B\u1163\u11A8\u1111\u116E\u11B7",
      "\u110B\u1163\u11A8\u1112\u1169\u11AB\u1102\u1167",
      "\u110B\u1163\u11BC\u1102\u1167\u11B7",
      "\u110B\u1163\u11BC\u1105\u1167\u11A8",
      "\u110B\u1163\u11BC\u1106\u1161\u11AF",
      "\u110B\u1163\u11BC\u1107\u1162\u110E\u116E",
      "\u110B\u1163\u11BC\u110C\u116E",
      "\u110B\u1163\u11BC\u1111\u1161",
      "\u110B\u1165\u1103\u116E\u11B7",
      "\u110B\u1165\u1105\u1167\u110B\u116E\u11B7",
      "\u110B\u1165\u1105\u1173\u11AB",
      "\u110B\u1165\u110C\u1166\u11BA\u1107\u1161\u11B7",
      "\u110B\u1165\u110D\u1162\u11BB\u1103\u1173\u11AB",
      "\u110B\u1165\u110D\u1165\u1103\u1161\u1100\u1161",
      "\u110B\u1165\u110D\u1165\u11AB\u110C\u1175",
      "\u110B\u1165\u11AB\u1102\u1175",
      "\u110B\u1165\u11AB\u1103\u1165\u11A8",
      "\u110B\u1165\u11AB\u1105\u1169\u11AB",
      "\u110B\u1165\u11AB\u110B\u1165",
      "\u110B\u1165\u11AF\u1100\u116E\u11AF",
      "\u110B\u1165\u11AF\u1105\u1173\u11AB",
      "\u110B\u1165\u11AF\u110B\u1173\u11B7",
      "\u110B\u1165\u11AF\u1111\u1175\u11BA",
      "\u110B\u1165\u11B7\u1106\u1161",
      "\u110B\u1165\u11B8\u1106\u116E",
      "\u110B\u1165\u11B8\u110C\u1169\u11BC",
      "\u110B\u1165\u11B8\u110E\u1166",
      "\u110B\u1165\u11BC\u1103\u1165\u11BC\u110B\u1175",
      "\u110B\u1165\u11BC\u1106\u1161\u11BC",
      "\u110B\u1165\u11BC\u1110\u1165\u1105\u1175",
      "\u110B\u1165\u11BD\u1100\u1173\u110C\u1166",
      "\u110B\u1166\u1102\u1165\u110C\u1175",
      "\u110B\u1166\u110B\u1165\u110F\u1165\u11AB",
      "\u110B\u1166\u11AB\u110C\u1175\u11AB",
      "\u110B\u1167\u1100\u1165\u11AB",
      "\u110B\u1167\u1100\u1169\u1109\u1162\u11BC",
      "\u110B\u1167\u1100\u116A\u11AB",
      "\u110B\u1167\u1100\u116E\u11AB",
      "\u110B\u1167\u1100\u116F\u11AB",
      "\u110B\u1167\u1103\u1162\u1109\u1162\u11BC",
      "\u110B\u1167\u1103\u1165\u11B2",
      "\u110B\u1167\u1103\u1169\u11BC\u1109\u1162\u11BC",
      "\u110B\u1167\u1103\u1173\u11AB",
      "\u110B\u1167\u1105\u1169\u11AB",
      "\u110B\u1167\u1105\u1173\u11B7",
      "\u110B\u1167\u1109\u1165\u11BA",
      "\u110B\u1167\u1109\u1165\u11BC",
      "\u110B\u1167\u110B\u116A\u11BC",
      "\u110B\u1167\u110B\u1175\u11AB",
      "\u110B\u1167\u110C\u1165\u11AB\u1112\u1175",
      "\u110B\u1167\u110C\u1175\u11A8\u110B\u116F\u11AB",
      "\u110B\u1167\u1112\u1161\u11A8\u1109\u1162\u11BC",
      "\u110B\u1167\u1112\u1162\u11BC",
      "\u110B\u1167\u11A8\u1109\u1161",
      "\u110B\u1167\u11A8\u1109\u1175",
      "\u110B\u1167\u11A8\u1112\u1161\u11AF",
      "\u110B\u1167\u11AB\u1100\u1167\u11AF",
      "\u110B\u1167\u11AB\u1100\u116E",
      "\u110B\u1167\u11AB\u1100\u1173\u11A8",
      "\u110B\u1167\u11AB\u1100\u1175",
      "\u110B\u1167\u11AB\u1105\u1161\u11A8",
      "\u110B\u1167\u11AB\u1109\u1165\u11AF",
      "\u110B\u1167\u11AB\u1109\u1166",
      "\u110B\u1167\u11AB\u1109\u1169\u11A8",
      "\u110B\u1167\u11AB\u1109\u1173\u11B8",
      "\u110B\u1167\u11AB\u110B\u1162",
      "\u110B\u1167\u11AB\u110B\u1168\u110B\u1175\u11AB",
      "\u110B\u1167\u11AB\u110B\u1175\u11AB",
      "\u110B\u1167\u11AB\u110C\u1161\u11BC",
      "\u110B\u1167\u11AB\u110C\u116E",
      "\u110B\u1167\u11AB\u110E\u116E\u11AF",
      "\u110B\u1167\u11AB\u1111\u1175\u11AF",
      "\u110B\u1167\u11AB\u1112\u1161\u11B8",
      "\u110B\u1167\u11AB\u1112\u1172",
      "\u110B\u1167\u11AF\u1100\u1175",
      "\u110B\u1167\u11AF\u1106\u1162",
      "\u110B\u1167\u11AF\u1109\u116C",
      "\u110B\u1167\u11AF\u1109\u1175\u11B7\u1112\u1175",
      "\u110B\u1167\u11AF\u110C\u1165\u11BC",
      "\u110B\u1167\u11AF\u110E\u1161",
      "\u110B\u1167\u11AF\u1112\u1173\u11AF",
      "\u110B\u1167\u11B7\u1105\u1167",
      "\u110B\u1167\u11B8\u1109\u1165",
      "\u110B\u1167\u11BC\u1100\u116E\u11A8",
      "\u110B\u1167\u11BC\u1102\u1161\u11B7",
      "\u110B\u1167\u11BC\u1109\u1161\u11BC",
      "\u110B\u1167\u11BC\u110B\u1163\u11BC",
      "\u110B\u1167\u11BC\u110B\u1167\u11A8",
      "\u110B\u1167\u11BC\u110B\u116E\u11BC",
      "\u110B\u1167\u11BC\u110B\u116F\u11AB\u1112\u1175",
      "\u110B\u1167\u11BC\u1112\u1161",
      "\u110B\u1167\u11BC\u1112\u1163\u11BC",
      "\u110B\u1167\u11BC\u1112\u1169\u11AB",
      "\u110B\u1167\u11BC\u1112\u116A",
      "\u110B\u1167\u11C1\u1100\u116E\u1105\u1175",
      "\u110B\u1167\u11C1\u1107\u1161\u11BC",
      "\u110B\u1167\u11C1\u110C\u1175\u11B8",
      "\u110B\u1168\u1100\u1161\u11B7",
      "\u110B\u1168\u1100\u1173\u11B7",
      "\u110B\u1168\u1107\u1161\u11BC",
      "\u110B\u1168\u1109\u1161\u11AB",
      "\u110B\u1168\u1109\u1161\u11BC",
      "\u110B\u1168\u1109\u1165\u11AB",
      "\u110B\u1168\u1109\u116E\u11AF",
      "\u110B\u1168\u1109\u1173\u11B8",
      "\u110B\u1168\u1109\u1175\u11A8\u110C\u1161\u11BC",
      "\u110B\u1168\u110B\u1163\u11A8",
      "\u110B\u1168\u110C\u1165\u11AB",
      "\u110B\u1168\u110C\u1165\u11AF",
      "\u110B\u1168\u110C\u1165\u11BC",
      "\u110B\u1168\u110F\u1165\u11AB\u1103\u1162",
      "\u110B\u1168\u11BA\u1102\u1161\u11AF",
      "\u110B\u1169\u1102\u1173\u11AF",
      "\u110B\u1169\u1105\u1161\u11A8",
      "\u110B\u1169\u1105\u1162\u11BA\u1103\u1169\u11BC\u110B\u1161\u11AB",
      "\u110B\u1169\u1105\u1166\u11AB\u110C\u1175",
      "\u110B\u1169\u1105\u1169\u110C\u1175",
      "\u110B\u1169\u1105\u1173\u11AB\u1107\u1161\u11AF",
      "\u110B\u1169\u1107\u1173\u11AB",
      "\u110B\u1169\u1109\u1175\u11B8",
      "\u110B\u1169\u110B\u1167\u11B7",
      "\u110B\u1169\u110B\u116F\u11AF",
      "\u110B\u1169\u110C\u1165\u11AB",
      "\u110B\u1169\u110C\u1175\u11A8",
      "\u110B\u1169\u110C\u1175\u11BC\u110B\u1165",
      "\u110B\u1169\u1111\u1166\u1105\u1161",
      "\u110B\u1169\u1111\u1175\u1109\u1173\u1110\u1166\u11AF",
      "\u110B\u1169\u1112\u1175\u1105\u1167",
      "\u110B\u1169\u11A8\u1109\u1161\u11BC",
      "\u110B\u1169\u11A8\u1109\u116E\u1109\u116E",
      "\u110B\u1169\u11AB\u1100\u1161\u11BD",
      "\u110B\u1169\u11AB\u1105\u1161\u110B\u1175\u11AB",
      "\u110B\u1169\u11AB\u1106\u1169\u11B7",
      "\u110B\u1169\u11AB\u110C\u1169\u11BC\u110B\u1175\u11AF",
      "\u110B\u1169\u11AB\u1110\u1169\u11BC",
      "\u110B\u1169\u11AF\u1100\u1161\u110B\u1173\u11AF",
      "\u110B\u1169\u11AF\u1105\u1175\u11B7\u1111\u1175\u11A8",
      "\u110B\u1169\u11AF\u1112\u1162",
      "\u110B\u1169\u11BA\u110E\u1161\u1105\u1175\u11B7",
      "\u110B\u116A\u110B\u1175\u1109\u1167\u110E\u1173",
      "\u110B\u116A\u110B\u1175\u11AB",
      "\u110B\u116A\u11AB\u1109\u1165\u11BC",
      "\u110B\u116A\u11AB\u110C\u1165\u11AB",
      "\u110B\u116A\u11BC\u1107\u1175",
      "\u110B\u116A\u11BC\u110C\u1161",
      "\u110B\u116B\u1102\u1163\u1112\u1161\u1106\u1167\u11AB",
      "\u110B\u116B\u11AB\u110C\u1175",
      "\u110B\u116C\u1100\u1161\u11BA\u110C\u1175\u11B8",
      "\u110B\u116C\u1100\u116E\u11A8",
      "\u110B\u116C\u1105\u1169\u110B\u116E\u11B7",
      "\u110B\u116C\u1109\u1161\u11B7\u110E\u1169\u11AB",
      "\u110B\u116C\u110E\u116E\u11AF",
      "\u110B\u116C\u110E\u1175\u11B7",
      "\u110B\u116C\u1112\u1161\u11AF\u1106\u1165\u1102\u1175",
      "\u110B\u116C\u11AB\u1107\u1161\u11AF",
      "\u110B\u116C\u11AB\u1109\u1169\u11AB",
      "\u110B\u116C\u11AB\u110D\u1169\u11A8",
      "\u110B\u116D\u1100\u1173\u11B7",
      "\u110B\u116D\u110B\u1175\u11AF",
      "\u110B\u116D\u110C\u1173\u11B7",
      "\u110B\u116D\u110E\u1165\u11BC",
      "\u110B\u116D\u11BC\u1100\u1175",
      "\u110B\u116D\u11BC\u1109\u1165",
      "\u110B\u116D\u11BC\u110B\u1165",
      "\u110B\u116E\u1109\u1161\u11AB",
      "\u110B\u116E\u1109\u1165\u11AB",
      "\u110B\u116E\u1109\u1173\u11BC",
      "\u110B\u116E\u110B\u1167\u11AB\u1112\u1175",
      "\u110B\u116E\u110C\u1165\u11BC",
      "\u110B\u116E\u110E\u1166\u1100\u116E\u11A8",
      "\u110B\u116E\u1111\u1167\u11AB",
      "\u110B\u116E\u11AB\u1103\u1169\u11BC",
      "\u110B\u116E\u11AB\u1106\u1167\u11BC",
      "\u110B\u116E\u11AB\u1107\u1161\u11AB",
      "\u110B\u116E\u11AB\u110C\u1165\u11AB",
      "\u110B\u116E\u11AB\u1112\u1162\u11BC",
      "\u110B\u116E\u11AF\u1109\u1161\u11AB",
      "\u110B\u116E\u11AF\u110B\u1173\u11B7",
      "\u110B\u116E\u11B7\u110C\u1175\u11A8\u110B\u1175\u11B7",
      "\u110B\u116E\u11BA\u110B\u1165\u1105\u1173\u11AB",
      "\u110B\u116E\u11BA\u110B\u1173\u11B7",
      "\u110B\u116F\u1102\u1161\u11A8",
      "\u110B\u116F\u11AB\u1100\u1169",
      "\u110B\u116F\u11AB\u1105\u1162",
      "\u110B\u116F\u11AB\u1109\u1165",
      "\u110B\u116F\u11AB\u1109\u116E\u11BC\u110B\u1175",
      "\u110B\u116F\u11AB\u110B\u1175\u11AB",
      "\u110B\u116F\u11AB\u110C\u1161\u11BC",
      "\u110B\u116F\u11AB\u1111\u1175\u1109\u1173",
      "\u110B\u116F\u11AF\u1100\u1173\u11B8",
      "\u110B\u116F\u11AF\u1103\u1173\u110F\u1165\u11B8",
      "\u110B\u116F\u11AF\u1109\u1166",
      "\u110B\u116F\u11AF\u110B\u116D\u110B\u1175\u11AF",
      "\u110B\u1170\u110B\u1175\u1110\u1165",
      "\u110B\u1171\u1107\u1161\u11AB",
      "\u110B\u1171\u1107\u1165\u11B8",
      "\u110B\u1171\u1109\u1165\u11BC",
      "\u110B\u1171\u110B\u116F\u11AB",
      "\u110B\u1171\u1112\u1165\u11B7",
      "\u110B\u1171\u1112\u1167\u11B8",
      "\u110B\u1171\u11BA\u1109\u1161\u1105\u1161\u11B7",
      "\u110B\u1172\u1102\u1161\u11AB\u1112\u1175",
      "\u110B\u1172\u1105\u1165\u11B8",
      "\u110B\u1172\u1106\u1167\u11BC",
      "\u110B\u1172\u1106\u116E\u11AF",
      "\u110B\u1172\u1109\u1161\u11AB",
      "\u110B\u1172\u110C\u1165\u11A8",
      "\u110B\u1172\u110E\u1175\u110B\u116F\u11AB",
      "\u110B\u1172\u1112\u1161\u11A8",
      "\u110B\u1172\u1112\u1162\u11BC",
      "\u110B\u1172\u1112\u1167\u11BC",
      "\u110B\u1172\u11A8\u1100\u116E\u11AB",
      "\u110B\u1172\u11A8\u1109\u1161\u11BC",
      "\u110B\u1172\u11A8\u1109\u1175\u11B8",
      "\u110B\u1172\u11A8\u110E\u1166",
      "\u110B\u1173\u11AB\u1112\u1162\u11BC",
      "\u110B\u1173\u11B7\u1105\u1167\u11A8",
      "\u110B\u1173\u11B7\u1105\u116D",
      "\u110B\u1173\u11B7\u1107\u1161\u11AB",
      "\u110B\u1173\u11B7\u1109\u1165\u11BC",
      "\u110B\u1173\u11B7\u1109\u1175\u11A8",
      "\u110B\u1173\u11B7\u110B\u1161\u11A8",
      "\u110B\u1173\u11B7\u110C\u116E",
      "\u110B\u1174\u1100\u1167\u11AB",
      "\u110B\u1174\u1102\u1169\u11AB",
      "\u110B\u1174\u1106\u116E\u11AB",
      "\u110B\u1174\u1107\u1169\u11A8",
      "\u110B\u1174\u1109\u1175\u11A8",
      "\u110B\u1174\u1109\u1175\u11B7",
      "\u110B\u1174\u110B\u116C\u1105\u1169",
      "\u110B\u1174\u110B\u116D\u11A8",
      "\u110B\u1174\u110B\u116F\u11AB",
      "\u110B\u1174\u1112\u1161\u11A8",
      "\u110B\u1175\u1100\u1165\u11BA",
      "\u110B\u1175\u1100\u1169\u11BA",
      "\u110B\u1175\u1102\u1167\u11B7",
      "\u110B\u1175\u1102\u1169\u11B7",
      "\u110B\u1175\u1103\u1161\u11AF",
      "\u110B\u1175\u1103\u1162\u1105\u1169",
      "\u110B\u1175\u1103\u1169\u11BC",
      "\u110B\u1175\u1105\u1165\u11C2\u1100\u1166",
      "\u110B\u1175\u1105\u1167\u11A8\u1109\u1165",
      "\u110B\u1175\u1105\u1169\u11AB\u110C\u1165\u11A8",
      "\u110B\u1175\u1105\u1173\u11B7",
      "\u110B\u1175\u1106\u1175\u11AB",
      "\u110B\u1175\u1107\u1161\u11AF\u1109\u1169",
      "\u110B\u1175\u1107\u1167\u11AF",
      "\u110B\u1175\u1107\u116E\u11AF",
      "\u110B\u1175\u1108\u1161\u11AF",
      "\u110B\u1175\u1109\u1161\u11BC",
      "\u110B\u1175\u1109\u1165\u11BC",
      "\u110B\u1175\u1109\u1173\u11AF",
      "\u110B\u1175\u110B\u1163\u1100\u1175",
      "\u110B\u1175\u110B\u116D\u11BC",
      "\u110B\u1175\u110B\u116E\u11BA",
      "\u110B\u1175\u110B\u116F\u11AF",
      "\u110B\u1175\u110B\u1173\u11A8\u1100\u1169",
      "\u110B\u1175\u110B\u1175\u11A8",
      "\u110B\u1175\u110C\u1165\u11AB",
      "\u110B\u1175\u110C\u116E\u11BC",
      "\u110B\u1175\u1110\u1173\u11AE\u1102\u1161\u11AF",
      "\u110B\u1175\u1110\u1173\u11AF",
      "\u110B\u1175\u1112\u1169\u11AB",
      "\u110B\u1175\u11AB\u1100\u1161\u11AB",
      "\u110B\u1175\u11AB\u1100\u1167\u11A8",
      "\u110B\u1175\u11AB\u1100\u1169\u11BC",
      "\u110B\u1175\u11AB\u1100\u116E",
      "\u110B\u1175\u11AB\u1100\u1173\u11AB",
      "\u110B\u1175\u11AB\u1100\u1175",
      "\u110B\u1175\u11AB\u1103\u1169",
      "\u110B\u1175\u11AB\u1105\u1172",
      "\u110B\u1175\u11AB\u1106\u116E\u11AF",
      "\u110B\u1175\u11AB\u1109\u1162\u11BC",
      "\u110B\u1175\u11AB\u1109\u116B",
      "\u110B\u1175\u11AB\u110B\u1167\u11AB",
      "\u110B\u1175\u11AB\u110B\u116F\u11AB",
      "\u110B\u1175\u11AB\u110C\u1162",
      "\u110B\u1175\u11AB\u110C\u1169\u11BC",
      "\u110B\u1175\u11AB\u110E\u1165\u11AB",
      "\u110B\u1175\u11AB\u110E\u1166",
      "\u110B\u1175\u11AB\u1110\u1165\u1102\u1166\u11BA",
      "\u110B\u1175\u11AB\u1112\u1161",
      "\u110B\u1175\u11AB\u1112\u1167\u11BC",
      "\u110B\u1175\u11AF\u1100\u1169\u11B8",
      "\u110B\u1175\u11AF\u1100\u1175",
      "\u110B\u1175\u11AF\u1103\u1161\u11AB",
      "\u110B\u1175\u11AF\u1103\u1162",
      "\u110B\u1175\u11AF\u1103\u1173\u11BC",
      "\u110B\u1175\u11AF\u1107\u1161\u11AB",
      "\u110B\u1175\u11AF\u1107\u1169\u11AB",
      "\u110B\u1175\u11AF\u1107\u116E",
      "\u110B\u1175\u11AF\u1109\u1161\u11BC",
      "\u110B\u1175\u11AF\u1109\u1162\u11BC",
      "\u110B\u1175\u11AF\u1109\u1169\u11AB",
      "\u110B\u1175\u11AF\u110B\u116D\u110B\u1175\u11AF",
      "\u110B\u1175\u11AF\u110B\u116F\u11AF",
      "\u110B\u1175\u11AF\u110C\u1165\u11BC",
      "\u110B\u1175\u11AF\u110C\u1169\u11BC",
      "\u110B\u1175\u11AF\u110C\u116E\u110B\u1175\u11AF",
      "\u110B\u1175\u11AF\u110D\u1175\u11A8",
      "\u110B\u1175\u11AF\u110E\u1166",
      "\u110B\u1175\u11AF\u110E\u1175",
      "\u110B\u1175\u11AF\u1112\u1162\u11BC",
      "\u110B\u1175\u11AF\u1112\u116C\u110B\u116D\u11BC",
      "\u110B\u1175\u11B7\u1100\u1173\u11B7",
      "\u110B\u1175\u11B7\u1106\u116E",
      "\u110B\u1175\u11B8\u1103\u1162",
      "\u110B\u1175\u11B8\u1105\u1167\u11A8",
      "\u110B\u1175\u11B8\u1106\u1161\u11BA",
      "\u110B\u1175\u11B8\u1109\u1161",
      "\u110B\u1175\u11B8\u1109\u116E\u11AF",
      "\u110B\u1175\u11B8\u1109\u1175",
      "\u110B\u1175\u11B8\u110B\u116F\u11AB",
      "\u110B\u1175\u11B8\u110C\u1161\u11BC",
      "\u110B\u1175\u11B8\u1112\u1161\u11A8",
      "\u110C\u1161\u1100\u1161\u110B\u116D\u11BC",
      "\u110C\u1161\u1100\u1167\u11A8",
      "\u110C\u1161\u1100\u1173\u11A8",
      "\u110C\u1161\u1103\u1169\u11BC",
      "\u110C\u1161\u1105\u1161\u11BC",
      "\u110C\u1161\u1107\u116E\u1109\u1175\u11B7",
      "\u110C\u1161\u1109\u1175\u11A8",
      "\u110C\u1161\u1109\u1175\u11AB",
      "\u110C\u1161\u110B\u1167\u11AB",
      "\u110C\u1161\u110B\u116F\u11AB",
      "\u110C\u1161\u110B\u1172\u11AF",
      "\u110C\u1161\u110C\u1165\u11AB\u1100\u1165",
      "\u110C\u1161\u110C\u1165\u11BC",
      "\u110C\u1161\u110C\u1169\u11AB\u1109\u1175\u11B7",
      "\u110C\u1161\u1111\u1161\u11AB",
      "\u110C\u1161\u11A8\u1100\u1161",
      "\u110C\u1161\u11A8\u1102\u1167\u11AB",
      "\u110C\u1161\u11A8\u1109\u1165\u11BC",
      "\u110C\u1161\u11A8\u110B\u1165\u11B8",
      "\u110C\u1161\u11A8\u110B\u116D\u11BC",
      "\u110C\u1161\u11A8\u110B\u1173\u11AB\u1104\u1161\u11AF",
      "\u110C\u1161\u11A8\u1111\u116E\u11B7",
      "\u110C\u1161\u11AB\u1103\u1175",
      "\u110C\u1161\u11AB\u1104\u1173\u11A8",
      "\u110C\u1161\u11AB\u110E\u1175",
      "\u110C\u1161\u11AF\u1106\u1169\u11BA",
      "\u110C\u1161\u11B7\u1101\u1161\u11AB",
      "\u110C\u1161\u11B7\u1109\u116E\u1112\u1161\u11B7",
      "\u110C\u1161\u11B7\u1109\u1175",
      "\u110C\u1161\u11B7\u110B\u1169\u11BA",
      "\u110C\u1161\u11B7\u110C\u1161\u1105\u1175",
      "\u110C\u1161\u11B8\u110C\u1175",
      "\u110C\u1161\u11BC\u1100\u116A\u11AB",
      "\u110C\u1161\u11BC\u1100\u116E\u11AB",
      "\u110C\u1161\u11BC\u1100\u1175\u1100\u1161\u11AB",
      "\u110C\u1161\u11BC\u1105\u1162",
      "\u110C\u1161\u11BC\u1105\u1168",
      "\u110C\u1161\u11BC\u1105\u1173",
      "\u110C\u1161\u11BC\u1106\u1161",
      "\u110C\u1161\u11BC\u1106\u1167\u11AB",
      "\u110C\u1161\u11BC\u1106\u1169",
      "\u110C\u1161\u11BC\u1106\u1175",
      "\u110C\u1161\u11BC\u1107\u1175",
      "\u110C\u1161\u11BC\u1109\u1161",
      "\u110C\u1161\u11BC\u1109\u1169",
      "\u110C\u1161\u11BC\u1109\u1175\u11A8",
      "\u110C\u1161\u11BC\u110B\u1162\u110B\u1175\u11AB",
      "\u110C\u1161\u11BC\u110B\u1175\u11AB",
      "\u110C\u1161\u11BC\u110C\u1165\u11B7",
      "\u110C\u1161\u11BC\u110E\u1161",
      "\u110C\u1161\u11BC\u1112\u1161\u11A8\u1100\u1173\u11B7",
      "\u110C\u1162\u1102\u1173\u11BC",
      "\u110C\u1162\u1108\u1161\u11AF\u1105\u1175",
      "\u110C\u1162\u1109\u1161\u11AB",
      "\u110C\u1162\u1109\u1162\u11BC",
      "\u110C\u1162\u110C\u1161\u11A8\u1102\u1167\u11AB",
      "\u110C\u1162\u110C\u1165\u11BC",
      "\u110C\u1162\u110E\u1162\u1100\u1175",
      "\u110C\u1162\u1111\u1161\u11AB",
      "\u110C\u1162\u1112\u1161\u11A8",
      "\u110C\u1162\u1112\u116A\u11AF\u110B\u116D\u11BC",
      "\u110C\u1165\u1100\u1165\u11BA",
      "\u110C\u1165\u1100\u1169\u1105\u1175",
      "\u110C\u1165\u1100\u1169\u11BA",
      "\u110C\u1165\u1102\u1167\u11A8",
      "\u110C\u1165\u1105\u1165\u11AB",
      "\u110C\u1165\u1105\u1165\u11C2\u1100\u1166",
      "\u110C\u1165\u1107\u1165\u11AB",
      "\u110C\u1165\u110B\u116E\u11AF",
      "\u110C\u1165\u110C\u1165\u11AF\u1105\u1169",
      "\u110C\u1165\u110E\u116E\u11A8",
      "\u110C\u1165\u11A8\u1100\u1173\u11A8",
      "\u110C\u1165\u11A8\u1103\u1161\u11BC\u1112\u1175",
      "\u110C\u1165\u11A8\u1109\u1165\u11BC",
      "\u110C\u1165\u11A8\u110B\u116D\u11BC",
      "\u110C\u1165\u11A8\u110B\u1173\u11BC",
      "\u110C\u1165\u11AB\u1100\u1162",
      "\u110C\u1165\u11AB\u1100\u1169\u11BC",
      "\u110C\u1165\u11AB\u1100\u1175",
      "\u110C\u1165\u11AB\u1103\u1161\u11AF",
      "\u110C\u1165\u11AB\u1105\u1161\u1103\u1169",
      "\u110C\u1165\u11AB\u1106\u1161\u11BC",
      "\u110C\u1165\u11AB\u1106\u116E\u11AB",
      "\u110C\u1165\u11AB\u1107\u1161\u11AB",
      "\u110C\u1165\u11AB\u1107\u116E",
      "\u110C\u1165\u11AB\u1109\u1166",
      "\u110C\u1165\u11AB\u1109\u1175",
      "\u110C\u1165\u11AB\u110B\u116D\u11BC",
      "\u110C\u1165\u11AB\u110C\u1161",
      "\u110C\u1165\u11AB\u110C\u1162\u11BC",
      "\u110C\u1165\u11AB\u110C\u116E",
      "\u110C\u1165\u11AB\u110E\u1165\u11AF",
      "\u110C\u1165\u11AB\u110E\u1166",
      "\u110C\u1165\u11AB\u1110\u1169\u11BC",
      "\u110C\u1165\u11AB\u1112\u1167",
      "\u110C\u1165\u11AB\u1112\u116E",
      "\u110C\u1165\u11AF\u1103\u1162",
      "\u110C\u1165\u11AF\u1106\u1161\u11BC",
      "\u110C\u1165\u11AF\u1107\u1161\u11AB",
      "\u110C\u1165\u11AF\u110B\u1163\u11A8",
      "\u110C\u1165\u11AF\u110E\u1161",
      "\u110C\u1165\u11B7\u1100\u1165\u11B7",
      "\u110C\u1165\u11B7\u1109\u116E",
      "\u110C\u1165\u11B7\u1109\u1175\u11B7",
      "\u110C\u1165\u11B7\u110B\u116F\u11AB",
      "\u110C\u1165\u11B7\u110C\u1165\u11B7",
      "\u110C\u1165\u11B7\u110E\u1161",
      "\u110C\u1165\u11B8\u1100\u1173\u11AB",
      "\u110C\u1165\u11B8\u1109\u1175",
      "\u110C\u1165\u11B8\u110E\u1169\u11A8",
      "\u110C\u1165\u11BA\u1100\u1161\u1105\u1161\u11A8",
      "\u110C\u1165\u11BC\u1100\u1165\u110C\u1161\u11BC",
      "\u110C\u1165\u11BC\u1103\u1169",
      "\u110C\u1165\u11BC\u1105\u1172\u110C\u1161\u11BC",
      "\u110C\u1165\u11BC\u1105\u1175",
      "\u110C\u1165\u11BC\u1106\u1161\u11AF",
      "\u110C\u1165\u11BC\u1106\u1167\u11AB",
      "\u110C\u1165\u11BC\u1106\u116E\u11AB",
      "\u110C\u1165\u11BC\u1107\u1161\u11AB\u1103\u1162",
      "\u110C\u1165\u11BC\u1107\u1169",
      "\u110C\u1165\u11BC\u1107\u116E",
      "\u110C\u1165\u11BC\u1107\u1175",
      "\u110C\u1165\u11BC\u1109\u1161\u11BC",
      "\u110C\u1165\u11BC\u1109\u1165\u11BC",
      "\u110C\u1165\u11BC\u110B\u1169",
      "\u110C\u1165\u11BC\u110B\u116F\u11AB",
      "\u110C\u1165\u11BC\u110C\u1161\u11BC",
      "\u110C\u1165\u11BC\u110C\u1175",
      "\u110C\u1165\u11BC\u110E\u1175",
      "\u110C\u1165\u11BC\u1112\u116A\u11A8\u1112\u1175",
      "\u110C\u1166\u1100\u1169\u11BC",
      "\u110C\u1166\u1100\u116A\u110C\u1165\u11B7",
      "\u110C\u1166\u1103\u1162\u1105\u1169",
      "\u110C\u1166\u1106\u1169\u11A8",
      "\u110C\u1166\u1107\u1161\u11AF",
      "\u110C\u1166\u1107\u1165\u11B8",
      "\u110C\u1166\u1109\u1161\u11BA\u1102\u1161\u11AF",
      "\u110C\u1166\u110B\u1161\u11AB",
      "\u110C\u1166\u110B\u1175\u11AF",
      "\u110C\u1166\u110C\u1161\u11A8",
      "\u110C\u1166\u110C\u116E\u1103\u1169",
      "\u110C\u1166\u110E\u116E\u11AF",
      "\u110C\u1166\u1111\u116E\u11B7",
      "\u110C\u1166\u1112\u1161\u11AB",
      "\u110C\u1169\u1100\u1161\u11A8",
      "\u110C\u1169\u1100\u1165\u11AB",
      "\u110C\u1169\u1100\u1173\u11B7",
      "\u110C\u1169\u1100\u1175\u11BC",
      "\u110C\u1169\u1106\u1167\u11BC",
      "\u110C\u1169\u1106\u1175\u1105\u116D",
      "\u110C\u1169\u1109\u1161\u11BC",
      "\u110C\u1169\u1109\u1165\u11AB",
      "\u110C\u1169\u110B\u116D\u11BC\u1112\u1175",
      "\u110C\u1169\u110C\u1165\u11AF",
      "\u110C\u1169\u110C\u1165\u11BC",
      "\u110C\u1169\u110C\u1175\u11A8",
      "\u110C\u1169\u11AB\u1103\u1162\u11BA\u1106\u1161\u11AF",
      "\u110C\u1169\u11AB\u110C\u1162",
      "\u110C\u1169\u11AF\u110B\u1165\u11B8",
      "\u110C\u1169\u11AF\u110B\u1173\u11B7",
      "\u110C\u1169\u11BC\u1100\u116D",
      "\u110C\u1169\u11BC\u1105\u1169",
      "\u110C\u1169\u11BC\u1105\u1172",
      "\u110C\u1169\u11BC\u1109\u1169\u1105\u1175",
      "\u110C\u1169\u11BC\u110B\u1165\u11B8\u110B\u116F\u11AB",
      "\u110C\u1169\u11BC\u110C\u1169\u11BC",
      "\u110C\u1169\u11BC\u1112\u1161\u11B8",
      "\u110C\u116A\u1109\u1165\u11A8",
      "\u110C\u116C\u110B\u1175\u11AB",
      "\u110C\u116E\u1100\u116A\u11AB\u110C\u1165\u11A8",
      "\u110C\u116E\u1105\u1173\u11B7",
      "\u110C\u116E\u1106\u1161\u11AF",
      "\u110C\u116E\u1106\u1165\u1102\u1175",
      "\u110C\u116E\u1106\u1165\u11A8",
      "\u110C\u116E\u1106\u116E\u11AB",
      "\u110C\u116E\u1106\u1175\u11AB",
      "\u110C\u116E\u1107\u1161\u11BC",
      "\u110C\u116E\u1107\u1167\u11AB",
      "\u110C\u116E\u1109\u1175\u11A8",
      "\u110C\u116E\u110B\u1175\u11AB",
      "\u110C\u116E\u110B\u1175\u11AF",
      "\u110C\u116E\u110C\u1161\u11BC",
      "\u110C\u116E\u110C\u1165\u11AB\u110C\u1161",
      "\u110C\u116E\u1110\u1162\u11A8",
      "\u110C\u116E\u11AB\u1107\u1175",
      "\u110C\u116E\u11AF\u1100\u1165\u1105\u1175",
      "\u110C\u116E\u11AF\u1100\u1175",
      "\u110C\u116E\u11AF\u1106\u116E\u1102\u1174",
      "\u110C\u116E\u11BC\u1100\u1161\u11AB",
      "\u110C\u116E\u11BC\u1100\u1168\u1107\u1161\u11BC\u1109\u1169\u11BC",
      "\u110C\u116E\u11BC\u1100\u116E\u11A8",
      "\u110C\u116E\u11BC\u1102\u1167\u11AB",
      "\u110C\u116E\u11BC\u1103\u1161\u11AB",
      "\u110C\u116E\u11BC\u1103\u1169\u11A8",
      "\u110C\u116E\u11BC\u1107\u1161\u11AB",
      "\u110C\u116E\u11BC\u1107\u116E",
      "\u110C\u116E\u11BC\u1109\u1166",
      "\u110C\u116E\u11BC\u1109\u1169\u1100\u1175\u110B\u1165\u11B8",
      "\u110C\u116E\u11BC\u1109\u116E\u11AB",
      "\u110C\u116E\u11BC\u110B\u1161\u11BC",
      "\u110C\u116E\u11BC\u110B\u116D",
      "\u110C\u116E\u11BC\u1112\u1161\u11A8\u1100\u116D",
      "\u110C\u1173\u11A8\u1109\u1165\u11A8",
      "\u110C\u1173\u11A8\u1109\u1175",
      "\u110C\u1173\u11AF\u1100\u1165\u110B\u116E\u11B7",
      "\u110C\u1173\u11BC\u1100\u1161",
      "\u110C\u1173\u11BC\u1100\u1165",
      "\u110C\u1173\u11BC\u1100\u116F\u11AB",
      "\u110C\u1173\u11BC\u1109\u1161\u11BC",
      "\u110C\u1173\u11BC\u1109\u1166",
      "\u110C\u1175\u1100\u1161\u11A8",
      "\u110C\u1175\u1100\u1161\u11B8",
      "\u110C\u1175\u1100\u1167\u11BC",
      "\u110C\u1175\u1100\u1173\u11A8\u1112\u1175",
      "\u110C\u1175\u1100\u1173\u11B7",
      "\u110C\u1175\u1100\u1173\u11B8",
      "\u110C\u1175\u1102\u1173\u11BC",
      "\u110C\u1175\u1105\u1173\u11B7\u1100\u1175\u11AF",
      "\u110C\u1175\u1105\u1175\u1109\u1161\u11AB",
      "\u110C\u1175\u1107\u1161\u11BC",
      "\u110C\u1175\u1107\u116E\u11BC",
      "\u110C\u1175\u1109\u1175\u11A8",
      "\u110C\u1175\u110B\u1167\u11A8",
      "\u110C\u1175\u110B\u116E\u1100\u1162",
      "\u110C\u1175\u110B\u116F\u11AB",
      "\u110C\u1175\u110C\u1165\u11A8",
      "\u110C\u1175\u110C\u1165\u11B7",
      "\u110C\u1175\u110C\u1175\u11AB",
      "\u110C\u1175\u110E\u116E\u11AF",
      "\u110C\u1175\u11A8\u1109\u1165\u11AB",
      "\u110C\u1175\u11A8\u110B\u1165\u11B8",
      "\u110C\u1175\u11A8\u110B\u116F\u11AB",
      "\u110C\u1175\u11A8\u110C\u1161\u11BC",
      "\u110C\u1175\u11AB\u1100\u1173\u11B8",
      "\u110C\u1175\u11AB\u1103\u1169\u11BC",
      "\u110C\u1175\u11AB\u1105\u1169",
      "\u110C\u1175\u11AB\u1105\u116D",
      "\u110C\u1175\u11AB\u1105\u1175",
      "\u110C\u1175\u11AB\u110D\u1161",
      "\u110C\u1175\u11AB\u110E\u1161\u11AF",
      "\u110C\u1175\u11AB\u110E\u116E\u11AF",
      "\u110C\u1175\u11AB\u1110\u1169\u11BC",
      "\u110C\u1175\u11AB\u1112\u1162\u11BC",
      "\u110C\u1175\u11AF\u1106\u116E\u11AB",
      "\u110C\u1175\u11AF\u1107\u1167\u11BC",
      "\u110C\u1175\u11AF\u1109\u1165",
      "\u110C\u1175\u11B7\u110C\u1161\u11A8",
      "\u110C\u1175\u11B8\u1103\u1161\u11AB",
      "\u110C\u1175\u11B8\u110B\u1161\u11AB",
      "\u110C\u1175\u11B8\u110C\u116E\u11BC",
      "\u110D\u1161\u110C\u1173\u11BC",
      "\u110D\u1175\u1101\u1165\u1100\u1175",
      "\u110E\u1161\u1102\u1161\u11B7",
      "\u110E\u1161\u1105\u1161\u1105\u1175",
      "\u110E\u1161\u1105\u1163\u11BC",
      "\u110E\u1161\u1105\u1175\u11B7",
      "\u110E\u1161\u1107\u1167\u11AF",
      "\u110E\u1161\u1109\u1165\u11AB",
      "\u110E\u1161\u110E\u1173\u11B7",
      "\u110E\u1161\u11A8\u1100\u1161\u11A8",
      "\u110E\u1161\u11AB\u1106\u116E\u11AF",
      "\u110E\u1161\u11AB\u1109\u1165\u11BC",
      "\u110E\u1161\u11B7\u1100\u1161",
      "\u110E\u1161\u11B7\u1100\u1175\u1105\u1173\u11B7",
      "\u110E\u1161\u11B7\u1109\u1162",
      "\u110E\u1161\u11B7\u1109\u1165\u11A8",
      "\u110E\u1161\u11B7\u110B\u1167",
      "\u110E\u1161\u11B7\u110B\u116C",
      "\u110E\u1161\u11B7\u110C\u1169",
      "\u110E\u1161\u11BA\u110C\u1161\u11AB",
      "\u110E\u1161\u11BC\u1100\u1161",
      "\u110E\u1161\u11BC\u1100\u1169",
      "\u110E\u1161\u11BC\u1100\u116E",
      "\u110E\u1161\u11BC\u1106\u116E\u11AB",
      "\u110E\u1161\u11BC\u1107\u1161\u11A9",
      "\u110E\u1161\u11BC\u110C\u1161\u11A8",
      "\u110E\u1161\u11BC\u110C\u1169",
      "\u110E\u1162\u1102\u1165\u11AF",
      "\u110E\u1162\u110C\u1165\u11B7",
      "\u110E\u1162\u11A8\u1100\u1161\u1107\u1161\u11BC",
      "\u110E\u1162\u11A8\u1107\u1161\u11BC",
      "\u110E\u1162\u11A8\u1109\u1161\u11BC",
      "\u110E\u1162\u11A8\u110B\u1175\u11B7",
      "\u110E\u1162\u11B7\u1111\u1175\u110B\u1165\u11AB",
      "\u110E\u1165\u1107\u1165\u11AF",
      "\u110E\u1165\u110B\u1173\u11B7",
      "\u110E\u1165\u11AB\u1100\u116E\u11A8",
      "\u110E\u1165\u11AB\u1103\u116E\u11BC",
      "\u110E\u1165\u11AB\u110C\u1161\u11BC",
      "\u110E\u1165\u11AB\u110C\u1162",
      "\u110E\u1165\u11AB\u110E\u1165\u11AB\u1112\u1175",
      "\u110E\u1165\u11AF\u1103\u1169",
      "\u110E\u1165\u11AF\u110C\u1165\u1112\u1175",
      "\u110E\u1165\u11AF\u1112\u1161\u11A8",
      "\u110E\u1165\u11BA\u1102\u1161\u11AF",
      "\u110E\u1165\u11BA\u110D\u1162",
      "\u110E\u1165\u11BC\u1102\u1167\u11AB",
      "\u110E\u1165\u11BC\u1107\u1161\u110C\u1175",
      "\u110E\u1165\u11BC\u1109\u1169",
      "\u110E\u1165\u11BC\u110E\u116E\u11AB",
      "\u110E\u1166\u1100\u1168",
      "\u110E\u1166\u1105\u1167\u11A8",
      "\u110E\u1166\u110B\u1169\u11AB",
      "\u110E\u1166\u110B\u1172\u11A8",
      "\u110E\u1166\u110C\u116E\u11BC",
      "\u110E\u1166\u1112\u1165\u11B7",
      "\u110E\u1169\u1103\u1173\u11BC\u1112\u1161\u11A8\u1109\u1162\u11BC",
      "\u110E\u1169\u1107\u1161\u11AB",
      "\u110E\u1169\u1107\u1161\u11B8",
      "\u110E\u1169\u1109\u1161\u11BC\u1112\u116A",
      "\u110E\u1169\u1109\u116E\u11AB",
      "\u110E\u1169\u110B\u1167\u1105\u1173\u11B7",
      "\u110E\u1169\u110B\u116F\u11AB",
      "\u110E\u1169\u110C\u1165\u1102\u1167\u11A8",
      "\u110E\u1169\u110C\u1165\u11B7",
      "\u110E\u1169\u110E\u1165\u11BC",
      "\u110E\u1169\u110F\u1169\u11AF\u1105\u1175\u11BA",
      "\u110E\u1169\u11BA\u1107\u116E\u11AF",
      "\u110E\u1169\u11BC\u1100\u1161\u11A8",
      "\u110E\u1169\u11BC\u1105\u1175",
      "\u110E\u1169\u11BC\u110C\u1161\u11BC",
      "\u110E\u116A\u11AF\u110B\u1167\u11BC",
      "\u110E\u116C\u1100\u1173\u11AB",
      "\u110E\u116C\u1109\u1161\u11BC",
      "\u110E\u116C\u1109\u1165\u11AB",
      "\u110E\u116C\u1109\u1175\u11AB",
      "\u110E\u116C\u110B\u1161\u11A8",
      "\u110E\u116C\u110C\u1169\u11BC",
      "\u110E\u116E\u1109\u1165\u11A8",
      "\u110E\u116E\u110B\u1165\u11A8",
      "\u110E\u116E\u110C\u1175\u11AB",
      "\u110E\u116E\u110E\u1165\u11AB",
      "\u110E\u116E\u110E\u1173\u11A8",
      "\u110E\u116E\u11A8\u1100\u116E",
      "\u110E\u116E\u11A8\u1109\u1169",
      "\u110E\u116E\u11A8\u110C\u1166",
      "\u110E\u116E\u11A8\u1112\u1161",
      "\u110E\u116E\u11AF\u1100\u1173\u11AB",
      "\u110E\u116E\u11AF\u1107\u1161\u11AF",
      "\u110E\u116E\u11AF\u1109\u1161\u11AB",
      "\u110E\u116E\u11AF\u1109\u1175\u11AB",
      "\u110E\u116E\u11AF\u110B\u1167\u11AB",
      "\u110E\u116E\u11AF\u110B\u1175\u11B8",
      "\u110E\u116E\u11AF\u110C\u1161\u11BC",
      "\u110E\u116E\u11AF\u1111\u1161\u11AB",
      "\u110E\u116E\u11BC\u1100\u1167\u11A8",
      "\u110E\u116E\u11BC\u1100\u1169",
      "\u110E\u116E\u11BC\u1103\u1169\u11AF",
      "\u110E\u116E\u11BC\u1107\u116E\u11AB\u1112\u1175",
      "\u110E\u116E\u11BC\u110E\u1165\u11BC\u1103\u1169",
      "\u110E\u1171\u110B\u1165\u11B8",
      "\u110E\u1171\u110C\u1175\u11A8",
      "\u110E\u1171\u1112\u1163\u11BC",
      "\u110E\u1175\u110B\u1163\u11A8",
      "\u110E\u1175\u11AB\u1100\u116E",
      "\u110E\u1175\u11AB\u110E\u1165\u11A8",
      "\u110E\u1175\u11AF\u1109\u1175\u11B8",
      "\u110E\u1175\u11AF\u110B\u116F\u11AF",
      "\u110E\u1175\u11AF\u1111\u1161\u11AB",
      "\u110E\u1175\u11B7\u1103\u1162",
      "\u110E\u1175\u11B7\u1106\u116E\u11A8",
      "\u110E\u1175\u11B7\u1109\u1175\u11AF",
      "\u110E\u1175\u11BA\u1109\u1169\u11AF",
      "\u110E\u1175\u11BC\u110E\u1161\u11AB",
      "\u110F\u1161\u1106\u1166\u1105\u1161",
      "\u110F\u1161\u110B\u116E\u11AB\u1110\u1165",
      "\u110F\u1161\u11AF\u1100\u116E\u11A8\u1109\u116E",
      "\u110F\u1162\u1105\u1175\u11A8\u1110\u1165",
      "\u110F\u1162\u11B7\u1111\u1165\u1109\u1173",
      "\u110F\u1162\u11B7\u1111\u1166\u110B\u1175\u11AB",
      "\u110F\u1165\u1110\u1173\u11AB",
      "\u110F\u1165\u11AB\u1103\u1175\u1109\u1167\u11AB",
      "\u110F\u1165\u11AF\u1105\u1165",
      "\u110F\u1165\u11B7\u1111\u1172\u1110\u1165",
      "\u110F\u1169\u1101\u1175\u1105\u1175",
      "\u110F\u1169\u1106\u1175\u1103\u1175",
      "\u110F\u1169\u11AB\u1109\u1165\u1110\u1173",
      "\u110F\u1169\u11AF\u1105\u1161",
      "\u110F\u1169\u11B7\u1111\u1173\u11AF\u1105\u1166\u11A8\u1109\u1173",
      "\u110F\u1169\u11BC\u1102\u1161\u1106\u116E\u11AF",
      "\u110F\u116B\u1100\u1161\u11B7",
      "\u110F\u116E\u1103\u1166\u1110\u1161",
      "\u110F\u1173\u1105\u1175\u11B7",
      "\u110F\u1173\u11AB\u1100\u1175\u11AF",
      "\u110F\u1173\u11AB\u1104\u1161\u11AF",
      "\u110F\u1173\u11AB\u1109\u1169\u1105\u1175",
      "\u110F\u1173\u11AB\u110B\u1161\u1103\u1173\u11AF",
      "\u110F\u1173\u11AB\u110B\u1165\u1106\u1165\u1102\u1175",
      "\u110F\u1173\u11AB\u110B\u1175\u11AF",
      "\u110F\u1173\u11AB\u110C\u1165\u11AF",
      "\u110F\u1173\u11AF\u1105\u1162\u1109\u1175\u11A8",
      "\u110F\u1173\u11AF\u1105\u1165\u11B8",
      "\u110F\u1175\u11AF\u1105\u1169",
      "\u1110\u1161\u110B\u1175\u11B8",
      "\u1110\u1161\u110C\u1161\u1100\u1175",
      "\u1110\u1161\u11A8\u1100\u116E",
      "\u1110\u1161\u11A8\u110C\u1161",
      "\u1110\u1161\u11AB\u1109\u1162\u11BC",
      "\u1110\u1162\u1100\u116F\u11AB\u1103\u1169",
      "\u1110\u1162\u110B\u1163\u11BC",
      "\u1110\u1162\u1111\u116E\u11BC",
      "\u1110\u1162\u11A8\u1109\u1175",
      "\u1110\u1162\u11AF\u1105\u1165\u11AB\u1110\u1173",
      "\u1110\u1165\u1102\u1165\u11AF",
      "\u1110\u1165\u1106\u1175\u1102\u1165\u11AF",
      "\u1110\u1166\u1102\u1175\u1109\u1173",
      "\u1110\u1166\u1109\u1173\u1110\u1173",
      "\u1110\u1166\u110B\u1175\u1107\u1173\u11AF",
      "\u1110\u1166\u11AF\u1105\u1166\u1107\u1175\u110C\u1165\u11AB",
      "\u1110\u1169\u1105\u1169\u11AB",
      "\u1110\u1169\u1106\u1161\u1110\u1169",
      "\u1110\u1169\u110B\u116D\u110B\u1175\u11AF",
      "\u1110\u1169\u11BC\u1100\u1168",
      "\u1110\u1169\u11BC\u1100\u116A",
      "\u1110\u1169\u11BC\u1105\u1169",
      "\u1110\u1169\u11BC\u1109\u1175\u11AB",
      "\u1110\u1169\u11BC\u110B\u1167\u11A8",
      "\u1110\u1169\u11BC\u110B\u1175\u11AF",
      "\u1110\u1169\u11BC\u110C\u1161\u11BC",
      "\u1110\u1169\u11BC\u110C\u1166",
      "\u1110\u1169\u11BC\u110C\u1173\u11BC",
      "\u1110\u1169\u11BC\u1112\u1161\u11B8",
      "\u1110\u1169\u11BC\u1112\u116A",
      "\u1110\u116C\u1100\u1173\u11AB",
      "\u1110\u116C\u110B\u116F\u11AB",
      "\u1110\u116C\u110C\u1175\u11A8\u1100\u1173\u11B7",
      "\u1110\u1171\u1100\u1175\u11B7",
      "\u1110\u1173\u1105\u1165\u11A8",
      "\u1110\u1173\u11A8\u1100\u1173\u11B8",
      "\u1110\u1173\u11A8\u1107\u1167\u11AF",
      "\u1110\u1173\u11A8\u1109\u1165\u11BC",
      "\u1110\u1173\u11A8\u1109\u116E",
      "\u1110\u1173\u11A8\u110C\u1175\u11BC",
      "\u1110\u1173\u11A8\u1112\u1175",
      "\u1110\u1173\u11AB\u1110\u1173\u11AB\u1112\u1175",
      "\u1110\u1175\u1109\u1167\u110E\u1173",
      "\u1111\u1161\u1105\u1161\u11AB\u1109\u1162\u11A8",
      "\u1111\u1161\u110B\u1175\u11AF",
      "\u1111\u1161\u110E\u116E\u11AF\u1109\u1169",
      "\u1111\u1161\u11AB\u1100\u1167\u11AF",
      "\u1111\u1161\u11AB\u1103\u1161\u11AB",
      "\u1111\u1161\u11AB\u1106\u1162",
      "\u1111\u1161\u11AB\u1109\u1161",
      "\u1111\u1161\u11AF\u1109\u1175\u11B8",
      "\u1111\u1161\u11AF\u110B\u116F\u11AF",
      "\u1111\u1161\u11B8\u1109\u1169\u11BC",
      "\u1111\u1162\u1109\u1167\u11AB",
      "\u1111\u1162\u11A8\u1109\u1173",
      "\u1111\u1162\u11A8\u1109\u1175\u1106\u1175\u11AF\u1105\u1175",
      "\u1111\u1162\u11AB\u1110\u1175",
      "\u1111\u1165\u1109\u1166\u11AB\u1110\u1173",
      "\u1111\u1166\u110B\u1175\u11AB\u1110\u1173",
      "\u1111\u1167\u11AB\u1100\u1167\u11AB",
      "\u1111\u1167\u11AB\u110B\u1174",
      "\u1111\u1167\u11AB\u110C\u1175",
      "\u1111\u1167\u11AB\u1112\u1175",
      "\u1111\u1167\u11BC\u1100\u1161",
      "\u1111\u1167\u11BC\u1100\u1172\u11AB",
      "\u1111\u1167\u11BC\u1109\u1162\u11BC",
      "\u1111\u1167\u11BC\u1109\u1169",
      "\u1111\u1167\u11BC\u110B\u1163\u11BC",
      "\u1111\u1167\u11BC\u110B\u1175\u11AF",
      "\u1111\u1167\u11BC\u1112\u116A",
      "\u1111\u1169\u1109\u1173\u1110\u1165",
      "\u1111\u1169\u110B\u1175\u11AB\u1110\u1173",
      "\u1111\u1169\u110C\u1161\u11BC",
      "\u1111\u1169\u1112\u1161\u11B7",
      "\u1111\u116D\u1106\u1167\u11AB",
      "\u1111\u116D\u110C\u1165\u11BC",
      "\u1111\u116D\u110C\u116E\u11AB",
      "\u1111\u116D\u1112\u1167\u11AB",
      "\u1111\u116E\u11B7\u1106\u1169\u11A8",
      "\u1111\u116E\u11B7\u110C\u1175\u11AF",
      "\u1111\u116E\u11BC\u1100\u1167\u11BC",
      "\u1111\u116E\u11BC\u1109\u1169\u11A8",
      "\u1111\u116E\u11BC\u1109\u1173\u11B8",
      "\u1111\u1173\u1105\u1161\u11BC\u1109\u1173",
      "\u1111\u1173\u1105\u1175\u11AB\u1110\u1165",
      "\u1111\u1173\u11AF\u1105\u1161\u1109\u1173\u1110\u1175\u11A8",
      "\u1111\u1175\u1100\u1169\u11AB",
      "\u1111\u1175\u1106\u1161\u11BC",
      "\u1111\u1175\u110B\u1161\u1102\u1169",
      "\u1111\u1175\u11AF\u1105\u1173\u11B7",
      "\u1111\u1175\u11AF\u1109\u116E",
      "\u1111\u1175\u11AF\u110B\u116D",
      "\u1111\u1175\u11AF\u110C\u1161",
      "\u1111\u1175\u11AF\u1110\u1169\u11BC",
      "\u1111\u1175\u11BC\u1100\u1168",
      "\u1112\u1161\u1102\u1173\u1102\u1175\u11B7",
      "\u1112\u1161\u1102\u1173\u11AF",
      "\u1112\u1161\u1103\u1173\u110B\u1170\u110B\u1165",
      "\u1112\u1161\u1105\u116E\u11BA\u1107\u1161\u11B7",
      "\u1112\u1161\u1107\u1161\u11AB\u1100\u1175",
      "\u1112\u1161\u1109\u116E\u11A8\u110C\u1175\u11B8",
      "\u1112\u1161\u1109\u116E\u11AB",
      "\u1112\u1161\u110B\u1167\u1110\u1173\u11AB",
      "\u1112\u1161\u110C\u1175\u1106\u1161\u11AB",
      "\u1112\u1161\u110E\u1165\u11AB",
      "\u1112\u1161\u1111\u116E\u11B7",
      "\u1112\u1161\u1111\u1175\u11AF",
      "\u1112\u1161\u11A8\u1100\u116A",
      "\u1112\u1161\u11A8\u1100\u116D",
      "\u1112\u1161\u11A8\u1100\u1173\u11B8",
      "\u1112\u1161\u11A8\u1100\u1175",
      "\u1112\u1161\u11A8\u1102\u1167\u11AB",
      "\u1112\u1161\u11A8\u1105\u1167\u11A8",
      "\u1112\u1161\u11A8\u1107\u1165\u11AB",
      "\u1112\u1161\u11A8\u1107\u116E\u1106\u1169",
      "\u1112\u1161\u11A8\u1107\u1175",
      "\u1112\u1161\u11A8\u1109\u1162\u11BC",
      "\u1112\u1161\u11A8\u1109\u116E\u11AF",
      "\u1112\u1161\u11A8\u1109\u1173\u11B8",
      "\u1112\u1161\u11A8\u110B\u116D\u11BC\u1111\u116E\u11B7",
      "\u1112\u1161\u11A8\u110B\u116F\u11AB",
      "\u1112\u1161\u11A8\u110B\u1171",
      "\u1112\u1161\u11A8\u110C\u1161",
      "\u1112\u1161\u11A8\u110C\u1165\u11B7",
      "\u1112\u1161\u11AB\u1100\u1168",
      "\u1112\u1161\u11AB\u1100\u1173\u11AF",
      "\u1112\u1161\u11AB\u1101\u1165\u1107\u1165\u11AB\u110B\u1166",
      "\u1112\u1161\u11AB\u1102\u1161\u11BD",
      "\u1112\u1161\u11AB\u1102\u116E\u11AB",
      "\u1112\u1161\u11AB\u1103\u1169\u11BC\u110B\u1161\u11AB",
      "\u1112\u1161\u11AB\u1104\u1162",
      "\u1112\u1161\u11AB\u1105\u1161\u1109\u1161\u11AB",
      "\u1112\u1161\u11AB\u1106\u1161\u1103\u1175",
      "\u1112\u1161\u11AB\u1106\u116E\u11AB",
      "\u1112\u1161\u11AB\u1107\u1165\u11AB",
      "\u1112\u1161\u11AB\u1107\u1169\u11A8",
      "\u1112\u1161\u11AB\u1109\u1175\u11A8",
      "\u1112\u1161\u11AB\u110B\u1167\u1105\u1173\u11B7",
      "\u1112\u1161\u11AB\u110D\u1169\u11A8",
      "\u1112\u1161\u11AF\u1106\u1165\u1102\u1175",
      "\u1112\u1161\u11AF\u110B\u1161\u1107\u1165\u110C\u1175",
      "\u1112\u1161\u11AF\u110B\u1175\u11AB",
      "\u1112\u1161\u11B7\u1101\u1166",
      "\u1112\u1161\u11B7\u1107\u116E\u1105\u1169",
      "\u1112\u1161\u11B8\u1100\u1167\u11A8",
      "\u1112\u1161\u11B8\u1105\u1175\u110C\u1165\u11A8",
      "\u1112\u1161\u11BC\u1100\u1169\u11BC",
      "\u1112\u1161\u11BC\u1100\u116E",
      "\u1112\u1161\u11BC\u1109\u1161\u11BC",
      "\u1112\u1161\u11BC\u110B\u1174",
      "\u1112\u1162\u1100\u1167\u11AF",
      "\u1112\u1162\u1100\u116E\u11AB",
      "\u1112\u1162\u1103\u1161\u11B8",
      "\u1112\u1162\u1103\u1161\u11BC",
      "\u1112\u1162\u1106\u116E\u11AF",
      "\u1112\u1162\u1109\u1165\u11A8",
      "\u1112\u1162\u1109\u1165\u11AF",
      "\u1112\u1162\u1109\u116E\u110B\u116D\u11A8\u110C\u1161\u11BC",
      "\u1112\u1162\u110B\u1161\u11AB",
      "\u1112\u1162\u11A8\u1109\u1175\u11B7",
      "\u1112\u1162\u11AB\u1103\u1173\u1107\u1162\u11A8",
      "\u1112\u1162\u11B7\u1107\u1165\u1100\u1165",
      "\u1112\u1162\u11BA\u1107\u1167\u11C0",
      "\u1112\u1162\u11BA\u1109\u1161\u11AF",
      "\u1112\u1162\u11BC\u1103\u1169\u11BC",
      "\u1112\u1162\u11BC\u1107\u1169\u11A8",
      "\u1112\u1162\u11BC\u1109\u1161",
      "\u1112\u1162\u11BC\u110B\u116E\u11AB",
      "\u1112\u1162\u11BC\u110B\u1171",
      "\u1112\u1163\u11BC\u1100\u1175",
      "\u1112\u1163\u11BC\u1109\u1161\u11BC",
      "\u1112\u1163\u11BC\u1109\u116E",
      "\u1112\u1165\u1105\u1161\u11A8",
      "\u1112\u1165\u110B\u116D\u11BC",
      "\u1112\u1166\u11AF\u1100\u1175",
      "\u1112\u1167\u11AB\u1100\u116A\u11AB",
      "\u1112\u1167\u11AB\u1100\u1173\u11B7",
      "\u1112\u1167\u11AB\u1103\u1162",
      "\u1112\u1167\u11AB\u1109\u1161\u11BC",
      "\u1112\u1167\u11AB\u1109\u1175\u11AF",
      "\u1112\u1167\u11AB\u110C\u1161\u11BC",
      "\u1112\u1167\u11AB\u110C\u1162",
      "\u1112\u1167\u11AB\u110C\u1175",
      "\u1112\u1167\u11AF\u110B\u1162\u11A8",
      "\u1112\u1167\u11B8\u1105\u1167\u11A8",
      "\u1112\u1167\u11BC\u1107\u116E",
      "\u1112\u1167\u11BC\u1109\u1161",
      "\u1112\u1167\u11BC\u1109\u116E",
      "\u1112\u1167\u11BC\u1109\u1175\u11A8",
      "\u1112\u1167\u11BC\u110C\u1166",
      "\u1112\u1167\u11BC\u1110\u1162",
      "\u1112\u1167\u11BC\u1111\u1167\u11AB",
      "\u1112\u1168\u1110\u1162\u11A8",
      "\u1112\u1169\u1100\u1175\u1109\u1175\u11B7",
      "\u1112\u1169\u1102\u1161\u11B7",
      "\u1112\u1169\u1105\u1161\u11BC\u110B\u1175",
      "\u1112\u1169\u1107\u1161\u11A8",
      "\u1112\u1169\u1110\u1166\u11AF",
      "\u1112\u1169\u1112\u1173\u11B8",
      "\u1112\u1169\u11A8\u1109\u1175",
      "\u1112\u1169\u11AF\u1105\u1169",
      "\u1112\u1169\u11B7\u1111\u1166\u110B\u1175\u110C\u1175",
      "\u1112\u1169\u11BC\u1107\u1169",
      "\u1112\u1169\u11BC\u1109\u116E",
      "\u1112\u1169\u11BC\u110E\u1161",
      "\u1112\u116A\u1106\u1167\u11AB",
      "\u1112\u116A\u1107\u116E\u11AB",
      "\u1112\u116A\u1109\u1161\u11AF",
      "\u1112\u116A\u110B\u116D\u110B\u1175\u11AF",
      "\u1112\u116A\u110C\u1161\u11BC",
      "\u1112\u116A\u1112\u1161\u11A8",
      "\u1112\u116A\u11A8\u1107\u1169",
      "\u1112\u116A\u11A8\u110B\u1175\u11AB",
      "\u1112\u116A\u11A8\u110C\u1161\u11BC",
      "\u1112\u116A\u11A8\u110C\u1165\u11BC",
      "\u1112\u116A\u11AB\u1100\u1161\u11B8",
      "\u1112\u116A\u11AB\u1100\u1167\u11BC",
      "\u1112\u116A\u11AB\u110B\u1167\u11BC",
      "\u1112\u116A\u11AB\u110B\u1172\u11AF",
      "\u1112\u116A\u11AB\u110C\u1161",
      "\u1112\u116A\u11AF\u1100\u1175",
      "\u1112\u116A\u11AF\u1103\u1169\u11BC",
      "\u1112\u116A\u11AF\u1107\u1161\u11AF\u1112\u1175",
      "\u1112\u116A\u11AF\u110B\u116D\u11BC",
      "\u1112\u116A\u11AF\u110D\u1161\u11A8",
      "\u1112\u116C\u1100\u1167\u11AB",
      "\u1112\u116C\u1100\u116A\u11AB",
      "\u1112\u116C\u1107\u1169\u11A8",
      "\u1112\u116C\u1109\u1162\u11A8",
      "\u1112\u116C\u110B\u116F\u11AB",
      "\u1112\u116C\u110C\u1161\u11BC",
      "\u1112\u116C\u110C\u1165\u11AB",
      "\u1112\u116C\u11BA\u1109\u116E",
      "\u1112\u116C\u11BC\u1103\u1161\u11AB\u1107\u1169\u1103\u1169",
      "\u1112\u116D\u110B\u1172\u11AF\u110C\u1165\u11A8",
      "\u1112\u116E\u1107\u1161\u11AB",
      "\u1112\u116E\u110E\u116E\u11BA\u1100\u1161\u1105\u116E",
      "\u1112\u116E\u11AB\u1105\u1167\u11AB",
      "\u1112\u116F\u11AF\u110A\u1175\u11AB",
      "\u1112\u1172\u1109\u1175\u11A8",
      "\u1112\u1172\u110B\u1175\u11AF",
      "\u1112\u1172\u11BC\u1102\u1162",
      "\u1112\u1173\u1105\u1173\u11B7",
      "\u1112\u1173\u11A8\u1107\u1162\u11A8",
      "\u1112\u1173\u11A8\u110B\u1175\u11AB",
      "\u1112\u1173\u11AB\u110C\u1165\u11A8",
      "\u1112\u1173\u11AB\u1112\u1175",
      "\u1112\u1173\u11BC\u1106\u1175",
      "\u1112\u1173\u11BC\u1107\u116E\u11AB",
      "\u1112\u1174\u1100\u1169\u11A8",
      "\u1112\u1174\u1106\u1161\u11BC",
      "\u1112\u1174\u1109\u1162\u11BC",
      "\u1112\u1174\u11AB\u1109\u1162\u11A8",
      "\u1112\u1175\u11B7\u1101\u1165\u11BA"
    ];
  }
});

// node_modules/bip39/src/wordlists/french.json
var require_french = __commonJS({
  "node_modules/bip39/src/wordlists/french.json"(exports2, module2) {
    module2.exports = [
      "abaisser",
      "abandon",
      "abdiquer",
      "abeille",
      "abolir",
      "aborder",
      "aboutir",
      "aboyer",
      "abrasif",
      "abreuver",
      "abriter",
      "abroger",
      "abrupt",
      "absence",
      "absolu",
      "absurde",
      "abusif",
      "abyssal",
      "acade\u0301mie",
      "acajou",
      "acarien",
      "accabler",
      "accepter",
      "acclamer",
      "accolade",
      "accroche",
      "accuser",
      "acerbe",
      "achat",
      "acheter",
      "aciduler",
      "acier",
      "acompte",
      "acque\u0301rir",
      "acronyme",
      "acteur",
      "actif",
      "actuel",
      "adepte",
      "ade\u0301quat",
      "adhe\u0301sif",
      "adjectif",
      "adjuger",
      "admettre",
      "admirer",
      "adopter",
      "adorer",
      "adoucir",
      "adresse",
      "adroit",
      "adulte",
      "adverbe",
      "ae\u0301rer",
      "ae\u0301ronef",
      "affaire",
      "affecter",
      "affiche",
      "affreux",
      "affubler",
      "agacer",
      "agencer",
      "agile",
      "agiter",
      "agrafer",
      "agre\u0301able",
      "agrume",
      "aider",
      "aiguille",
      "ailier",
      "aimable",
      "aisance",
      "ajouter",
      "ajuster",
      "alarmer",
      "alchimie",
      "alerte",
      "alge\u0300bre",
      "algue",
      "alie\u0301ner",
      "aliment",
      "alle\u0301ger",
      "alliage",
      "allouer",
      "allumer",
      "alourdir",
      "alpaga",
      "altesse",
      "alve\u0301ole",
      "amateur",
      "ambigu",
      "ambre",
      "ame\u0301nager",
      "amertume",
      "amidon",
      "amiral",
      "amorcer",
      "amour",
      "amovible",
      "amphibie",
      "ampleur",
      "amusant",
      "analyse",
      "anaphore",
      "anarchie",
      "anatomie",
      "ancien",
      "ane\u0301antir",
      "angle",
      "angoisse",
      "anguleux",
      "animal",
      "annexer",
      "annonce",
      "annuel",
      "anodin",
      "anomalie",
      "anonyme",
      "anormal",
      "antenne",
      "antidote",
      "anxieux",
      "apaiser",
      "ape\u0301ritif",
      "aplanir",
      "apologie",
      "appareil",
      "appeler",
      "apporter",
      "appuyer",
      "aquarium",
      "aqueduc",
      "arbitre",
      "arbuste",
      "ardeur",
      "ardoise",
      "argent",
      "arlequin",
      "armature",
      "armement",
      "armoire",
      "armure",
      "arpenter",
      "arracher",
      "arriver",
      "arroser",
      "arsenic",
      "arte\u0301riel",
      "article",
      "aspect",
      "asphalte",
      "aspirer",
      "assaut",
      "asservir",
      "assiette",
      "associer",
      "assurer",
      "asticot",
      "astre",
      "astuce",
      "atelier",
      "atome",
      "atrium",
      "atroce",
      "attaque",
      "attentif",
      "attirer",
      "attraper",
      "aubaine",
      "auberge",
      "audace",
      "audible",
      "augurer",
      "aurore",
      "automne",
      "autruche",
      "avaler",
      "avancer",
      "avarice",
      "avenir",
      "averse",
      "aveugle",
      "aviateur",
      "avide",
      "avion",
      "aviser",
      "avoine",
      "avouer",
      "avril",
      "axial",
      "axiome",
      "badge",
      "bafouer",
      "bagage",
      "baguette",
      "baignade",
      "balancer",
      "balcon",
      "baleine",
      "balisage",
      "bambin",
      "bancaire",
      "bandage",
      "banlieue",
      "bannie\u0300re",
      "banquier",
      "barbier",
      "baril",
      "baron",
      "barque",
      "barrage",
      "bassin",
      "bastion",
      "bataille",
      "bateau",
      "batterie",
      "baudrier",
      "bavarder",
      "belette",
      "be\u0301lier",
      "belote",
      "be\u0301ne\u0301fice",
      "berceau",
      "berger",
      "berline",
      "bermuda",
      "besace",
      "besogne",
      "be\u0301tail",
      "beurre",
      "biberon",
      "bicycle",
      "bidule",
      "bijou",
      "bilan",
      "bilingue",
      "billard",
      "binaire",
      "biologie",
      "biopsie",
      "biotype",
      "biscuit",
      "bison",
      "bistouri",
      "bitume",
      "bizarre",
      "blafard",
      "blague",
      "blanchir",
      "blessant",
      "blinder",
      "blond",
      "bloquer",
      "blouson",
      "bobard",
      "bobine",
      "boire",
      "boiser",
      "bolide",
      "bonbon",
      "bondir",
      "bonheur",
      "bonifier",
      "bonus",
      "bordure",
      "borne",
      "botte",
      "boucle",
      "boueux",
      "bougie",
      "boulon",
      "bouquin",
      "bourse",
      "boussole",
      "boutique",
      "boxeur",
      "branche",
      "brasier",
      "brave",
      "brebis",
      "bre\u0300che",
      "breuvage",
      "bricoler",
      "brigade",
      "brillant",
      "brioche",
      "brique",
      "brochure",
      "broder",
      "bronzer",
      "brousse",
      "broyeur",
      "brume",
      "brusque",
      "brutal",
      "bruyant",
      "buffle",
      "buisson",
      "bulletin",
      "bureau",
      "burin",
      "bustier",
      "butiner",
      "butoir",
      "buvable",
      "buvette",
      "cabanon",
      "cabine",
      "cachette",
      "cadeau",
      "cadre",
      "cafe\u0301ine",
      "caillou",
      "caisson",
      "calculer",
      "calepin",
      "calibre",
      "calmer",
      "calomnie",
      "calvaire",
      "camarade",
      "came\u0301ra",
      "camion",
      "campagne",
      "canal",
      "caneton",
      "canon",
      "cantine",
      "canular",
      "capable",
      "caporal",
      "caprice",
      "capsule",
      "capter",
      "capuche",
      "carabine",
      "carbone",
      "caresser",
      "caribou",
      "carnage",
      "carotte",
      "carreau",
      "carton",
      "cascade",
      "casier",
      "casque",
      "cassure",
      "causer",
      "caution",
      "cavalier",
      "caverne",
      "caviar",
      "ce\u0301dille",
      "ceinture",
      "ce\u0301leste",
      "cellule",
      "cendrier",
      "censurer",
      "central",
      "cercle",
      "ce\u0301re\u0301bral",
      "cerise",
      "cerner",
      "cerveau",
      "cesser",
      "chagrin",
      "chaise",
      "chaleur",
      "chambre",
      "chance",
      "chapitre",
      "charbon",
      "chasseur",
      "chaton",
      "chausson",
      "chavirer",
      "chemise",
      "chenille",
      "che\u0301quier",
      "chercher",
      "cheval",
      "chien",
      "chiffre",
      "chignon",
      "chime\u0300re",
      "chiot",
      "chlorure",
      "chocolat",
      "choisir",
      "chose",
      "chouette",
      "chrome",
      "chute",
      "cigare",
      "cigogne",
      "cimenter",
      "cine\u0301ma",
      "cintrer",
      "circuler",
      "cirer",
      "cirque",
      "citerne",
      "citoyen",
      "citron",
      "civil",
      "clairon",
      "clameur",
      "claquer",
      "classe",
      "clavier",
      "client",
      "cligner",
      "climat",
      "clivage",
      "cloche",
      "clonage",
      "cloporte",
      "cobalt",
      "cobra",
      "cocasse",
      "cocotier",
      "coder",
      "codifier",
      "coffre",
      "cogner",
      "cohe\u0301sion",
      "coiffer",
      "coincer",
      "cole\u0300re",
      "colibri",
      "colline",
      "colmater",
      "colonel",
      "combat",
      "come\u0301die",
      "commande",
      "compact",
      "concert",
      "conduire",
      "confier",
      "congeler",
      "connoter",
      "consonne",
      "contact",
      "convexe",
      "copain",
      "copie",
      "corail",
      "corbeau",
      "cordage",
      "corniche",
      "corpus",
      "correct",
      "corte\u0300ge",
      "cosmique",
      "costume",
      "coton",
      "coude",
      "coupure",
      "courage",
      "couteau",
      "couvrir",
      "coyote",
      "crabe",
      "crainte",
      "cravate",
      "crayon",
      "cre\u0301ature",
      "cre\u0301diter",
      "cre\u0301meux",
      "creuser",
      "crevette",
      "cribler",
      "crier",
      "cristal",
      "crite\u0300re",
      "croire",
      "croquer",
      "crotale",
      "crucial",
      "cruel",
      "crypter",
      "cubique",
      "cueillir",
      "cuille\u0300re",
      "cuisine",
      "cuivre",
      "culminer",
      "cultiver",
      "cumuler",
      "cupide",
      "curatif",
      "curseur",
      "cyanure",
      "cycle",
      "cylindre",
      "cynique",
      "daigner",
      "damier",
      "danger",
      "danseur",
      "dauphin",
      "de\u0301battre",
      "de\u0301biter",
      "de\u0301border",
      "de\u0301brider",
      "de\u0301butant",
      "de\u0301caler",
      "de\u0301cembre",
      "de\u0301chirer",
      "de\u0301cider",
      "de\u0301clarer",
      "de\u0301corer",
      "de\u0301crire",
      "de\u0301cupler",
      "de\u0301dale",
      "de\u0301ductif",
      "de\u0301esse",
      "de\u0301fensif",
      "de\u0301filer",
      "de\u0301frayer",
      "de\u0301gager",
      "de\u0301givrer",
      "de\u0301glutir",
      "de\u0301grafer",
      "de\u0301jeuner",
      "de\u0301lice",
      "de\u0301loger",
      "demander",
      "demeurer",
      "de\u0301molir",
      "de\u0301nicher",
      "de\u0301nouer",
      "dentelle",
      "de\u0301nuder",
      "de\u0301part",
      "de\u0301penser",
      "de\u0301phaser",
      "de\u0301placer",
      "de\u0301poser",
      "de\u0301ranger",
      "de\u0301rober",
      "de\u0301sastre",
      "descente",
      "de\u0301sert",
      "de\u0301signer",
      "de\u0301sobe\u0301ir",
      "dessiner",
      "destrier",
      "de\u0301tacher",
      "de\u0301tester",
      "de\u0301tourer",
      "de\u0301tresse",
      "devancer",
      "devenir",
      "deviner",
      "devoir",
      "diable",
      "dialogue",
      "diamant",
      "dicter",
      "diffe\u0301rer",
      "dige\u0301rer",
      "digital",
      "digne",
      "diluer",
      "dimanche",
      "diminuer",
      "dioxyde",
      "directif",
      "diriger",
      "discuter",
      "disposer",
      "dissiper",
      "distance",
      "divertir",
      "diviser",
      "docile",
      "docteur",
      "dogme",
      "doigt",
      "domaine",
      "domicile",
      "dompter",
      "donateur",
      "donjon",
      "donner",
      "dopamine",
      "dortoir",
      "dorure",
      "dosage",
      "doseur",
      "dossier",
      "dotation",
      "douanier",
      "double",
      "douceur",
      "douter",
      "doyen",
      "dragon",
      "draper",
      "dresser",
      "dribbler",
      "droiture",
      "duperie",
      "duplexe",
      "durable",
      "durcir",
      "dynastie",
      "e\u0301blouir",
      "e\u0301carter",
      "e\u0301charpe",
      "e\u0301chelle",
      "e\u0301clairer",
      "e\u0301clipse",
      "e\u0301clore",
      "e\u0301cluse",
      "e\u0301cole",
      "e\u0301conomie",
      "e\u0301corce",
      "e\u0301couter",
      "e\u0301craser",
      "e\u0301cre\u0301mer",
      "e\u0301crivain",
      "e\u0301crou",
      "e\u0301cume",
      "e\u0301cureuil",
      "e\u0301difier",
      "e\u0301duquer",
      "effacer",
      "effectif",
      "effigie",
      "effort",
      "effrayer",
      "effusion",
      "e\u0301galiser",
      "e\u0301garer",
      "e\u0301jecter",
      "e\u0301laborer",
      "e\u0301largir",
      "e\u0301lectron",
      "e\u0301le\u0301gant",
      "e\u0301le\u0301phant",
      "e\u0301le\u0300ve",
      "e\u0301ligible",
      "e\u0301litisme",
      "e\u0301loge",
      "e\u0301lucider",
      "e\u0301luder",
      "emballer",
      "embellir",
      "embryon",
      "e\u0301meraude",
      "e\u0301mission",
      "emmener",
      "e\u0301motion",
      "e\u0301mouvoir",
      "empereur",
      "employer",
      "emporter",
      "emprise",
      "e\u0301mulsion",
      "encadrer",
      "enche\u0300re",
      "enclave",
      "encoche",
      "endiguer",
      "endosser",
      "endroit",
      "enduire",
      "e\u0301nergie",
      "enfance",
      "enfermer",
      "enfouir",
      "engager",
      "engin",
      "englober",
      "e\u0301nigme",
      "enjamber",
      "enjeu",
      "enlever",
      "ennemi",
      "ennuyeux",
      "enrichir",
      "enrobage",
      "enseigne",
      "entasser",
      "entendre",
      "entier",
      "entourer",
      "entraver",
      "e\u0301nume\u0301rer",
      "envahir",
      "enviable",
      "envoyer",
      "enzyme",
      "e\u0301olien",
      "e\u0301paissir",
      "e\u0301pargne",
      "e\u0301patant",
      "e\u0301paule",
      "e\u0301picerie",
      "e\u0301pide\u0301mie",
      "e\u0301pier",
      "e\u0301pilogue",
      "e\u0301pine",
      "e\u0301pisode",
      "e\u0301pitaphe",
      "e\u0301poque",
      "e\u0301preuve",
      "e\u0301prouver",
      "e\u0301puisant",
      "e\u0301querre",
      "e\u0301quipe",
      "e\u0301riger",
      "e\u0301rosion",
      "erreur",
      "e\u0301ruption",
      "escalier",
      "espadon",
      "espe\u0300ce",
      "espie\u0300gle",
      "espoir",
      "esprit",
      "esquiver",
      "essayer",
      "essence",
      "essieu",
      "essorer",
      "estime",
      "estomac",
      "estrade",
      "e\u0301tage\u0300re",
      "e\u0301taler",
      "e\u0301tanche",
      "e\u0301tatique",
      "e\u0301teindre",
      "e\u0301tendoir",
      "e\u0301ternel",
      "e\u0301thanol",
      "e\u0301thique",
      "ethnie",
      "e\u0301tirer",
      "e\u0301toffer",
      "e\u0301toile",
      "e\u0301tonnant",
      "e\u0301tourdir",
      "e\u0301trange",
      "e\u0301troit",
      "e\u0301tude",
      "euphorie",
      "e\u0301valuer",
      "e\u0301vasion",
      "e\u0301ventail",
      "e\u0301vidence",
      "e\u0301viter",
      "e\u0301volutif",
      "e\u0301voquer",
      "exact",
      "exage\u0301rer",
      "exaucer",
      "exceller",
      "excitant",
      "exclusif",
      "excuse",
      "exe\u0301cuter",
      "exemple",
      "exercer",
      "exhaler",
      "exhorter",
      "exigence",
      "exiler",
      "exister",
      "exotique",
      "expe\u0301dier",
      "explorer",
      "exposer",
      "exprimer",
      "exquis",
      "extensif",
      "extraire",
      "exulter",
      "fable",
      "fabuleux",
      "facette",
      "facile",
      "facture",
      "faiblir",
      "falaise",
      "fameux",
      "famille",
      "farceur",
      "farfelu",
      "farine",
      "farouche",
      "fasciner",
      "fatal",
      "fatigue",
      "faucon",
      "fautif",
      "faveur",
      "favori",
      "fe\u0301brile",
      "fe\u0301conder",
      "fe\u0301de\u0301rer",
      "fe\u0301lin",
      "femme",
      "fe\u0301mur",
      "fendoir",
      "fe\u0301odal",
      "fermer",
      "fe\u0301roce",
      "ferveur",
      "festival",
      "feuille",
      "feutre",
      "fe\u0301vrier",
      "fiasco",
      "ficeler",
      "fictif",
      "fide\u0300le",
      "figure",
      "filature",
      "filetage",
      "filie\u0300re",
      "filleul",
      "filmer",
      "filou",
      "filtrer",
      "financer",
      "finir",
      "fiole",
      "firme",
      "fissure",
      "fixer",
      "flairer",
      "flamme",
      "flasque",
      "flatteur",
      "fle\u0301au",
      "fle\u0300che",
      "fleur",
      "flexion",
      "flocon",
      "flore",
      "fluctuer",
      "fluide",
      "fluvial",
      "folie",
      "fonderie",
      "fongible",
      "fontaine",
      "forcer",
      "forgeron",
      "formuler",
      "fortune",
      "fossile",
      "foudre",
      "fouge\u0300re",
      "fouiller",
      "foulure",
      "fourmi",
      "fragile",
      "fraise",
      "franchir",
      "frapper",
      "frayeur",
      "fre\u0301gate",
      "freiner",
      "frelon",
      "fre\u0301mir",
      "fre\u0301ne\u0301sie",
      "fre\u0300re",
      "friable",
      "friction",
      "frisson",
      "frivole",
      "froid",
      "fromage",
      "frontal",
      "frotter",
      "fruit",
      "fugitif",
      "fuite",
      "fureur",
      "furieux",
      "furtif",
      "fusion",
      "futur",
      "gagner",
      "galaxie",
      "galerie",
      "gambader",
      "garantir",
      "gardien",
      "garnir",
      "garrigue",
      "gazelle",
      "gazon",
      "ge\u0301ant",
      "ge\u0301latine",
      "ge\u0301lule",
      "gendarme",
      "ge\u0301ne\u0301ral",
      "ge\u0301nie",
      "genou",
      "gentil",
      "ge\u0301ologie",
      "ge\u0301ome\u0300tre",
      "ge\u0301ranium",
      "germe",
      "gestuel",
      "geyser",
      "gibier",
      "gicler",
      "girafe",
      "givre",
      "glace",
      "glaive",
      "glisser",
      "globe",
      "gloire",
      "glorieux",
      "golfeur",
      "gomme",
      "gonfler",
      "gorge",
      "gorille",
      "goudron",
      "gouffre",
      "goulot",
      "goupille",
      "gourmand",
      "goutte",
      "graduel",
      "graffiti",
      "graine",
      "grand",
      "grappin",
      "gratuit",
      "gravir",
      "grenat",
      "griffure",
      "griller",
      "grimper",
      "grogner",
      "gronder",
      "grotte",
      "groupe",
      "gruger",
      "grutier",
      "gruye\u0300re",
      "gue\u0301pard",
      "guerrier",
      "guide",
      "guimauve",
      "guitare",
      "gustatif",
      "gymnaste",
      "gyrostat",
      "habitude",
      "hachoir",
      "halte",
      "hameau",
      "hangar",
      "hanneton",
      "haricot",
      "harmonie",
      "harpon",
      "hasard",
      "he\u0301lium",
      "he\u0301matome",
      "herbe",
      "he\u0301risson",
      "hermine",
      "he\u0301ron",
      "he\u0301siter",
      "heureux",
      "hiberner",
      "hibou",
      "hilarant",
      "histoire",
      "hiver",
      "homard",
      "hommage",
      "homoge\u0300ne",
      "honneur",
      "honorer",
      "honteux",
      "horde",
      "horizon",
      "horloge",
      "hormone",
      "horrible",
      "houleux",
      "housse",
      "hublot",
      "huileux",
      "humain",
      "humble",
      "humide",
      "humour",
      "hurler",
      "hydromel",
      "hygie\u0300ne",
      "hymne",
      "hypnose",
      "idylle",
      "ignorer",
      "iguane",
      "illicite",
      "illusion",
      "image",
      "imbiber",
      "imiter",
      "immense",
      "immobile",
      "immuable",
      "impact",
      "impe\u0301rial",
      "implorer",
      "imposer",
      "imprimer",
      "imputer",
      "incarner",
      "incendie",
      "incident",
      "incliner",
      "incolore",
      "indexer",
      "indice",
      "inductif",
      "ine\u0301dit",
      "ineptie",
      "inexact",
      "infini",
      "infliger",
      "informer",
      "infusion",
      "inge\u0301rer",
      "inhaler",
      "inhiber",
      "injecter",
      "injure",
      "innocent",
      "inoculer",
      "inonder",
      "inscrire",
      "insecte",
      "insigne",
      "insolite",
      "inspirer",
      "instinct",
      "insulter",
      "intact",
      "intense",
      "intime",
      "intrigue",
      "intuitif",
      "inutile",
      "invasion",
      "inventer",
      "inviter",
      "invoquer",
      "ironique",
      "irradier",
      "irre\u0301el",
      "irriter",
      "isoler",
      "ivoire",
      "ivresse",
      "jaguar",
      "jaillir",
      "jambe",
      "janvier",
      "jardin",
      "jauger",
      "jaune",
      "javelot",
      "jetable",
      "jeton",
      "jeudi",
      "jeunesse",
      "joindre",
      "joncher",
      "jongler",
      "joueur",
      "jouissif",
      "journal",
      "jovial",
      "joyau",
      "joyeux",
      "jubiler",
      "jugement",
      "junior",
      "jupon",
      "juriste",
      "justice",
      "juteux",
      "juve\u0301nile",
      "kayak",
      "kimono",
      "kiosque",
      "label",
      "labial",
      "labourer",
      "lace\u0301rer",
      "lactose",
      "lagune",
      "laine",
      "laisser",
      "laitier",
      "lambeau",
      "lamelle",
      "lampe",
      "lanceur",
      "langage",
      "lanterne",
      "lapin",
      "largeur",
      "larme",
      "laurier",
      "lavabo",
      "lavoir",
      "lecture",
      "le\u0301gal",
      "le\u0301ger",
      "le\u0301gume",
      "lessive",
      "lettre",
      "levier",
      "lexique",
      "le\u0301zard",
      "liasse",
      "libe\u0301rer",
      "libre",
      "licence",
      "licorne",
      "lie\u0300ge",
      "lie\u0300vre",
      "ligature",
      "ligoter",
      "ligue",
      "limer",
      "limite",
      "limonade",
      "limpide",
      "line\u0301aire",
      "lingot",
      "lionceau",
      "liquide",
      "lisie\u0300re",
      "lister",
      "lithium",
      "litige",
      "littoral",
      "livreur",
      "logique",
      "lointain",
      "loisir",
      "lombric",
      "loterie",
      "louer",
      "lourd",
      "loutre",
      "louve",
      "loyal",
      "lubie",
      "lucide",
      "lucratif",
      "lueur",
      "lugubre",
      "luisant",
      "lumie\u0300re",
      "lunaire",
      "lundi",
      "luron",
      "lutter",
      "luxueux",
      "machine",
      "magasin",
      "magenta",
      "magique",
      "maigre",
      "maillon",
      "maintien",
      "mairie",
      "maison",
      "majorer",
      "malaxer",
      "male\u0301fice",
      "malheur",
      "malice",
      "mallette",
      "mammouth",
      "mandater",
      "maniable",
      "manquant",
      "manteau",
      "manuel",
      "marathon",
      "marbre",
      "marchand",
      "mardi",
      "maritime",
      "marqueur",
      "marron",
      "marteler",
      "mascotte",
      "massif",
      "mate\u0301riel",
      "matie\u0300re",
      "matraque",
      "maudire",
      "maussade",
      "mauve",
      "maximal",
      "me\u0301chant",
      "me\u0301connu",
      "me\u0301daille",
      "me\u0301decin",
      "me\u0301diter",
      "me\u0301duse",
      "meilleur",
      "me\u0301lange",
      "me\u0301lodie",
      "membre",
      "me\u0301moire",
      "menacer",
      "mener",
      "menhir",
      "mensonge",
      "mentor",
      "mercredi",
      "me\u0301rite",
      "merle",
      "messager",
      "mesure",
      "me\u0301tal",
      "me\u0301te\u0301ore",
      "me\u0301thode",
      "me\u0301tier",
      "meuble",
      "miauler",
      "microbe",
      "miette",
      "mignon",
      "migrer",
      "milieu",
      "million",
      "mimique",
      "mince",
      "mine\u0301ral",
      "minimal",
      "minorer",
      "minute",
      "miracle",
      "miroiter",
      "missile",
      "mixte",
      "mobile",
      "moderne",
      "moelleux",
      "mondial",
      "moniteur",
      "monnaie",
      "monotone",
      "monstre",
      "montagne",
      "monument",
      "moqueur",
      "morceau",
      "morsure",
      "mortier",
      "moteur",
      "motif",
      "mouche",
      "moufle",
      "moulin",
      "mousson",
      "mouton",
      "mouvant",
      "multiple",
      "munition",
      "muraille",
      "mure\u0300ne",
      "murmure",
      "muscle",
      "muse\u0301um",
      "musicien",
      "mutation",
      "muter",
      "mutuel",
      "myriade",
      "myrtille",
      "myste\u0300re",
      "mythique",
      "nageur",
      "nappe",
      "narquois",
      "narrer",
      "natation",
      "nation",
      "nature",
      "naufrage",
      "nautique",
      "navire",
      "ne\u0301buleux",
      "nectar",
      "ne\u0301faste",
      "ne\u0301gation",
      "ne\u0301gliger",
      "ne\u0301gocier",
      "neige",
      "nerveux",
      "nettoyer",
      "neurone",
      "neutron",
      "neveu",
      "niche",
      "nickel",
      "nitrate",
      "niveau",
      "noble",
      "nocif",
      "nocturne",
      "noirceur",
      "noisette",
      "nomade",
      "nombreux",
      "nommer",
      "normatif",
      "notable",
      "notifier",
      "notoire",
      "nourrir",
      "nouveau",
      "novateur",
      "novembre",
      "novice",
      "nuage",
      "nuancer",
      "nuire",
      "nuisible",
      "nume\u0301ro",
      "nuptial",
      "nuque",
      "nutritif",
      "obe\u0301ir",
      "objectif",
      "obliger",
      "obscur",
      "observer",
      "obstacle",
      "obtenir",
      "obturer",
      "occasion",
      "occuper",
      "oce\u0301an",
      "octobre",
      "octroyer",
      "octupler",
      "oculaire",
      "odeur",
      "odorant",
      "offenser",
      "officier",
      "offrir",
      "ogive",
      "oiseau",
      "oisillon",
      "olfactif",
      "olivier",
      "ombrage",
      "omettre",
      "onctueux",
      "onduler",
      "one\u0301reux",
      "onirique",
      "opale",
      "opaque",
      "ope\u0301rer",
      "opinion",
      "opportun",
      "opprimer",
      "opter",
      "optique",
      "orageux",
      "orange",
      "orbite",
      "ordonner",
      "oreille",
      "organe",
      "orgueil",
      "orifice",
      "ornement",
      "orque",
      "ortie",
      "osciller",
      "osmose",
      "ossature",
      "otarie",
      "ouragan",
      "ourson",
      "outil",
      "outrager",
      "ouvrage",
      "ovation",
      "oxyde",
      "oxyge\u0300ne",
      "ozone",
      "paisible",
      "palace",
      "palmare\u0300s",
      "palourde",
      "palper",
      "panache",
      "panda",
      "pangolin",
      "paniquer",
      "panneau",
      "panorama",
      "pantalon",
      "papaye",
      "papier",
      "papoter",
      "papyrus",
      "paradoxe",
      "parcelle",
      "paresse",
      "parfumer",
      "parler",
      "parole",
      "parrain",
      "parsemer",
      "partager",
      "parure",
      "parvenir",
      "passion",
      "paste\u0300que",
      "paternel",
      "patience",
      "patron",
      "pavillon",
      "pavoiser",
      "payer",
      "paysage",
      "peigne",
      "peintre",
      "pelage",
      "pe\u0301lican",
      "pelle",
      "pelouse",
      "peluche",
      "pendule",
      "pe\u0301ne\u0301trer",
      "pe\u0301nible",
      "pensif",
      "pe\u0301nurie",
      "pe\u0301pite",
      "pe\u0301plum",
      "perdrix",
      "perforer",
      "pe\u0301riode",
      "permuter",
      "perplexe",
      "persil",
      "perte",
      "peser",
      "pe\u0301tale",
      "petit",
      "pe\u0301trir",
      "peuple",
      "pharaon",
      "phobie",
      "phoque",
      "photon",
      "phrase",
      "physique",
      "piano",
      "pictural",
      "pie\u0300ce",
      "pierre",
      "pieuvre",
      "pilote",
      "pinceau",
      "pipette",
      "piquer",
      "pirogue",
      "piscine",
      "piston",
      "pivoter",
      "pixel",
      "pizza",
      "placard",
      "plafond",
      "plaisir",
      "planer",
      "plaque",
      "plastron",
      "plateau",
      "pleurer",
      "plexus",
      "pliage",
      "plomb",
      "plonger",
      "pluie",
      "plumage",
      "pochette",
      "poe\u0301sie",
      "poe\u0300te",
      "pointe",
      "poirier",
      "poisson",
      "poivre",
      "polaire",
      "policier",
      "pollen",
      "polygone",
      "pommade",
      "pompier",
      "ponctuel",
      "ponde\u0301rer",
      "poney",
      "portique",
      "position",
      "posse\u0301der",
      "posture",
      "potager",
      "poteau",
      "potion",
      "pouce",
      "poulain",
      "poumon",
      "pourpre",
      "poussin",
      "pouvoir",
      "prairie",
      "pratique",
      "pre\u0301cieux",
      "pre\u0301dire",
      "pre\u0301fixe",
      "pre\u0301lude",
      "pre\u0301nom",
      "pre\u0301sence",
      "pre\u0301texte",
      "pre\u0301voir",
      "primitif",
      "prince",
      "prison",
      "priver",
      "proble\u0300me",
      "proce\u0301der",
      "prodige",
      "profond",
      "progre\u0300s",
      "proie",
      "projeter",
      "prologue",
      "promener",
      "propre",
      "prospe\u0300re",
      "prote\u0301ger",
      "prouesse",
      "proverbe",
      "prudence",
      "pruneau",
      "psychose",
      "public",
      "puceron",
      "puiser",
      "pulpe",
      "pulsar",
      "punaise",
      "punitif",
      "pupitre",
      "purifier",
      "puzzle",
      "pyramide",
      "quasar",
      "querelle",
      "question",
      "quie\u0301tude",
      "quitter",
      "quotient",
      "racine",
      "raconter",
      "radieux",
      "ragondin",
      "raideur",
      "raisin",
      "ralentir",
      "rallonge",
      "ramasser",
      "rapide",
      "rasage",
      "ratisser",
      "ravager",
      "ravin",
      "rayonner",
      "re\u0301actif",
      "re\u0301agir",
      "re\u0301aliser",
      "re\u0301animer",
      "recevoir",
      "re\u0301citer",
      "re\u0301clamer",
      "re\u0301colter",
      "recruter",
      "reculer",
      "recycler",
      "re\u0301diger",
      "redouter",
      "refaire",
      "re\u0301flexe",
      "re\u0301former",
      "refrain",
      "refuge",
      "re\u0301galien",
      "re\u0301gion",
      "re\u0301glage",
      "re\u0301gulier",
      "re\u0301ite\u0301rer",
      "rejeter",
      "rejouer",
      "relatif",
      "relever",
      "relief",
      "remarque",
      "reme\u0300de",
      "remise",
      "remonter",
      "remplir",
      "remuer",
      "renard",
      "renfort",
      "renifler",
      "renoncer",
      "rentrer",
      "renvoi",
      "replier",
      "reporter",
      "reprise",
      "reptile",
      "requin",
      "re\u0301serve",
      "re\u0301sineux",
      "re\u0301soudre",
      "respect",
      "rester",
      "re\u0301sultat",
      "re\u0301tablir",
      "retenir",
      "re\u0301ticule",
      "retomber",
      "retracer",
      "re\u0301union",
      "re\u0301ussir",
      "revanche",
      "revivre",
      "re\u0301volte",
      "re\u0301vulsif",
      "richesse",
      "rideau",
      "rieur",
      "rigide",
      "rigoler",
      "rincer",
      "riposter",
      "risible",
      "risque",
      "rituel",
      "rival",
      "rivie\u0300re",
      "rocheux",
      "romance",
      "rompre",
      "ronce",
      "rondin",
      "roseau",
      "rosier",
      "rotatif",
      "rotor",
      "rotule",
      "rouge",
      "rouille",
      "rouleau",
      "routine",
      "royaume",
      "ruban",
      "rubis",
      "ruche",
      "ruelle",
      "rugueux",
      "ruiner",
      "ruisseau",
      "ruser",
      "rustique",
      "rythme",
      "sabler",
      "saboter",
      "sabre",
      "sacoche",
      "safari",
      "sagesse",
      "saisir",
      "salade",
      "salive",
      "salon",
      "saluer",
      "samedi",
      "sanction",
      "sanglier",
      "sarcasme",
      "sardine",
      "saturer",
      "saugrenu",
      "saumon",
      "sauter",
      "sauvage",
      "savant",
      "savonner",
      "scalpel",
      "scandale",
      "sce\u0301le\u0301rat",
      "sce\u0301nario",
      "sceptre",
      "sche\u0301ma",
      "science",
      "scinder",
      "score",
      "scrutin",
      "sculpter",
      "se\u0301ance",
      "se\u0301cable",
      "se\u0301cher",
      "secouer",
      "se\u0301cre\u0301ter",
      "se\u0301datif",
      "se\u0301duire",
      "seigneur",
      "se\u0301jour",
      "se\u0301lectif",
      "semaine",
      "sembler",
      "semence",
      "se\u0301minal",
      "se\u0301nateur",
      "sensible",
      "sentence",
      "se\u0301parer",
      "se\u0301quence",
      "serein",
      "sergent",
      "se\u0301rieux",
      "serrure",
      "se\u0301rum",
      "service",
      "se\u0301same",
      "se\u0301vir",
      "sevrage",
      "sextuple",
      "side\u0301ral",
      "sie\u0300cle",
      "sie\u0301ger",
      "siffler",
      "sigle",
      "signal",
      "silence",
      "silicium",
      "simple",
      "since\u0300re",
      "sinistre",
      "siphon",
      "sirop",
      "sismique",
      "situer",
      "skier",
      "social",
      "socle",
      "sodium",
      "soigneux",
      "soldat",
      "soleil",
      "solitude",
      "soluble",
      "sombre",
      "sommeil",
      "somnoler",
      "sonde",
      "songeur",
      "sonnette",
      "sonore",
      "sorcier",
      "sortir",
      "sosie",
      "sottise",
      "soucieux",
      "soudure",
      "souffle",
      "soulever",
      "soupape",
      "source",
      "soutirer",
      "souvenir",
      "spacieux",
      "spatial",
      "spe\u0301cial",
      "sphe\u0300re",
      "spiral",
      "stable",
      "station",
      "sternum",
      "stimulus",
      "stipuler",
      "strict",
      "studieux",
      "stupeur",
      "styliste",
      "sublime",
      "substrat",
      "subtil",
      "subvenir",
      "succe\u0300s",
      "sucre",
      "suffixe",
      "sugge\u0301rer",
      "suiveur",
      "sulfate",
      "superbe",
      "supplier",
      "surface",
      "suricate",
      "surmener",
      "surprise",
      "sursaut",
      "survie",
      "suspect",
      "syllabe",
      "symbole",
      "syme\u0301trie",
      "synapse",
      "syntaxe",
      "syste\u0300me",
      "tabac",
      "tablier",
      "tactile",
      "tailler",
      "talent",
      "talisman",
      "talonner",
      "tambour",
      "tamiser",
      "tangible",
      "tapis",
      "taquiner",
      "tarder",
      "tarif",
      "tartine",
      "tasse",
      "tatami",
      "tatouage",
      "taupe",
      "taureau",
      "taxer",
      "te\u0301moin",
      "temporel",
      "tenaille",
      "tendre",
      "teneur",
      "tenir",
      "tension",
      "terminer",
      "terne",
      "terrible",
      "te\u0301tine",
      "texte",
      "the\u0300me",
      "the\u0301orie",
      "the\u0301rapie",
      "thorax",
      "tibia",
      "tie\u0300de",
      "timide",
      "tirelire",
      "tiroir",
      "tissu",
      "titane",
      "titre",
      "tituber",
      "toboggan",
      "tole\u0301rant",
      "tomate",
      "tonique",
      "tonneau",
      "toponyme",
      "torche",
      "tordre",
      "tornade",
      "torpille",
      "torrent",
      "torse",
      "tortue",
      "totem",
      "toucher",
      "tournage",
      "tousser",
      "toxine",
      "traction",
      "trafic",
      "tragique",
      "trahir",
      "train",
      "trancher",
      "travail",
      "tre\u0300fle",
      "tremper",
      "tre\u0301sor",
      "treuil",
      "triage",
      "tribunal",
      "tricoter",
      "trilogie",
      "triomphe",
      "tripler",
      "triturer",
      "trivial",
      "trombone",
      "tronc",
      "tropical",
      "troupeau",
      "tuile",
      "tulipe",
      "tumulte",
      "tunnel",
      "turbine",
      "tuteur",
      "tutoyer",
      "tuyau",
      "tympan",
      "typhon",
      "typique",
      "tyran",
      "ubuesque",
      "ultime",
      "ultrason",
      "unanime",
      "unifier",
      "union",
      "unique",
      "unitaire",
      "univers",
      "uranium",
      "urbain",
      "urticant",
      "usage",
      "usine",
      "usuel",
      "usure",
      "utile",
      "utopie",
      "vacarme",
      "vaccin",
      "vagabond",
      "vague",
      "vaillant",
      "vaincre",
      "vaisseau",
      "valable",
      "valise",
      "vallon",
      "valve",
      "vampire",
      "vanille",
      "vapeur",
      "varier",
      "vaseux",
      "vassal",
      "vaste",
      "vecteur",
      "vedette",
      "ve\u0301ge\u0301tal",
      "ve\u0301hicule",
      "veinard",
      "ve\u0301loce",
      "vendredi",
      "ve\u0301ne\u0301rer",
      "venger",
      "venimeux",
      "ventouse",
      "verdure",
      "ve\u0301rin",
      "vernir",
      "verrou",
      "verser",
      "vertu",
      "veston",
      "ve\u0301te\u0301ran",
      "ve\u0301tuste",
      "vexant",
      "vexer",
      "viaduc",
      "viande",
      "victoire",
      "vidange",
      "vide\u0301o",
      "vignette",
      "vigueur",
      "vilain",
      "village",
      "vinaigre",
      "violon",
      "vipe\u0300re",
      "virement",
      "virtuose",
      "virus",
      "visage",
      "viseur",
      "vision",
      "visqueux",
      "visuel",
      "vital",
      "vitesse",
      "viticole",
      "vitrine",
      "vivace",
      "vivipare",
      "vocation",
      "voguer",
      "voile",
      "voisin",
      "voiture",
      "volaille",
      "volcan",
      "voltiger",
      "volume",
      "vorace",
      "vortex",
      "voter",
      "vouloir",
      "voyage",
      "voyelle",
      "wagon",
      "xe\u0301non",
      "yacht",
      "ze\u0300bre",
      "ze\u0301nith",
      "zeste",
      "zoologie"
    ];
  }
});

// node_modules/bip39/src/wordlists/italian.json
var require_italian = __commonJS({
  "node_modules/bip39/src/wordlists/italian.json"(exports2, module2) {
    module2.exports = [
      "abaco",
      "abbaglio",
      "abbinato",
      "abete",
      "abisso",
      "abolire",
      "abrasivo",
      "abrogato",
      "accadere",
      "accenno",
      "accusato",
      "acetone",
      "achille",
      "acido",
      "acqua",
      "acre",
      "acrilico",
      "acrobata",
      "acuto",
      "adagio",
      "addebito",
      "addome",
      "adeguato",
      "aderire",
      "adipe",
      "adottare",
      "adulare",
      "affabile",
      "affetto",
      "affisso",
      "affranto",
      "aforisma",
      "afoso",
      "africano",
      "agave",
      "agente",
      "agevole",
      "aggancio",
      "agire",
      "agitare",
      "agonismo",
      "agricolo",
      "agrumeto",
      "aguzzo",
      "alabarda",
      "alato",
      "albatro",
      "alberato",
      "albo",
      "albume",
      "alce",
      "alcolico",
      "alettone",
      "alfa",
      "algebra",
      "aliante",
      "alibi",
      "alimento",
      "allagato",
      "allegro",
      "allievo",
      "allodola",
      "allusivo",
      "almeno",
      "alogeno",
      "alpaca",
      "alpestre",
      "altalena",
      "alterno",
      "alticcio",
      "altrove",
      "alunno",
      "alveolo",
      "alzare",
      "amalgama",
      "amanita",
      "amarena",
      "ambito",
      "ambrato",
      "ameba",
      "america",
      "ametista",
      "amico",
      "ammasso",
      "ammenda",
      "ammirare",
      "ammonito",
      "amore",
      "ampio",
      "ampliare",
      "amuleto",
      "anacardo",
      "anagrafe",
      "analista",
      "anarchia",
      "anatra",
      "anca",
      "ancella",
      "ancora",
      "andare",
      "andrea",
      "anello",
      "angelo",
      "angolare",
      "angusto",
      "anima",
      "annegare",
      "annidato",
      "anno",
      "annuncio",
      "anonimo",
      "anticipo",
      "anzi",
      "apatico",
      "apertura",
      "apode",
      "apparire",
      "appetito",
      "appoggio",
      "approdo",
      "appunto",
      "aprile",
      "arabica",
      "arachide",
      "aragosta",
      "araldica",
      "arancio",
      "aratura",
      "arazzo",
      "arbitro",
      "archivio",
      "ardito",
      "arenile",
      "argento",
      "argine",
      "arguto",
      "aria",
      "armonia",
      "arnese",
      "arredato",
      "arringa",
      "arrosto",
      "arsenico",
      "arso",
      "artefice",
      "arzillo",
      "asciutto",
      "ascolto",
      "asepsi",
      "asettico",
      "asfalto",
      "asino",
      "asola",
      "aspirato",
      "aspro",
      "assaggio",
      "asse",
      "assoluto",
      "assurdo",
      "asta",
      "astenuto",
      "astice",
      "astratto",
      "atavico",
      "ateismo",
      "atomico",
      "atono",
      "attesa",
      "attivare",
      "attorno",
      "attrito",
      "attuale",
      "ausilio",
      "austria",
      "autista",
      "autonomo",
      "autunno",
      "avanzato",
      "avere",
      "avvenire",
      "avviso",
      "avvolgere",
      "azione",
      "azoto",
      "azzimo",
      "azzurro",
      "babele",
      "baccano",
      "bacino",
      "baco",
      "badessa",
      "badilata",
      "bagnato",
      "baita",
      "balcone",
      "baldo",
      "balena",
      "ballata",
      "balzano",
      "bambino",
      "bandire",
      "baraonda",
      "barbaro",
      "barca",
      "baritono",
      "barlume",
      "barocco",
      "basilico",
      "basso",
      "batosta",
      "battuto",
      "baule",
      "bava",
      "bavosa",
      "becco",
      "beffa",
      "belgio",
      "belva",
      "benda",
      "benevole",
      "benigno",
      "benzina",
      "bere",
      "berlina",
      "beta",
      "bibita",
      "bici",
      "bidone",
      "bifido",
      "biga",
      "bilancia",
      "bimbo",
      "binocolo",
      "biologo",
      "bipede",
      "bipolare",
      "birbante",
      "birra",
      "biscotto",
      "bisesto",
      "bisnonno",
      "bisonte",
      "bisturi",
      "bizzarro",
      "blando",
      "blatta",
      "bollito",
      "bonifico",
      "bordo",
      "bosco",
      "botanico",
      "bottino",
      "bozzolo",
      "braccio",
      "bradipo",
      "brama",
      "branca",
      "bravura",
      "bretella",
      "brevetto",
      "brezza",
      "briglia",
      "brillante",
      "brindare",
      "broccolo",
      "brodo",
      "bronzina",
      "brullo",
      "bruno",
      "bubbone",
      "buca",
      "budino",
      "buffone",
      "buio",
      "bulbo",
      "buono",
      "burlone",
      "burrasca",
      "bussola",
      "busta",
      "cadetto",
      "caduco",
      "calamaro",
      "calcolo",
      "calesse",
      "calibro",
      "calmo",
      "caloria",
      "cambusa",
      "camerata",
      "camicia",
      "cammino",
      "camola",
      "campale",
      "canapa",
      "candela",
      "cane",
      "canino",
      "canotto",
      "cantina",
      "capace",
      "capello",
      "capitolo",
      "capogiro",
      "cappero",
      "capra",
      "capsula",
      "carapace",
      "carcassa",
      "cardo",
      "carisma",
      "carovana",
      "carretto",
      "cartolina",
      "casaccio",
      "cascata",
      "caserma",
      "caso",
      "cassone",
      "castello",
      "casuale",
      "catasta",
      "catena",
      "catrame",
      "cauto",
      "cavillo",
      "cedibile",
      "cedrata",
      "cefalo",
      "celebre",
      "cellulare",
      "cena",
      "cenone",
      "centesimo",
      "ceramica",
      "cercare",
      "certo",
      "cerume",
      "cervello",
      "cesoia",
      "cespo",
      "ceto",
      "chela",
      "chiaro",
      "chicca",
      "chiedere",
      "chimera",
      "china",
      "chirurgo",
      "chitarra",
      "ciao",
      "ciclismo",
      "cifrare",
      "cigno",
      "cilindro",
      "ciottolo",
      "circa",
      "cirrosi",
      "citrico",
      "cittadino",
      "ciuffo",
      "civetta",
      "civile",
      "classico",
      "clinica",
      "cloro",
      "cocco",
      "codardo",
      "codice",
      "coerente",
      "cognome",
      "collare",
      "colmato",
      "colore",
      "colposo",
      "coltivato",
      "colza",
      "coma",
      "cometa",
      "commando",
      "comodo",
      "computer",
      "comune",
      "conciso",
      "condurre",
      "conferma",
      "congelare",
      "coniuge",
      "connesso",
      "conoscere",
      "consumo",
      "continuo",
      "convegno",
      "coperto",
      "copione",
      "coppia",
      "copricapo",
      "corazza",
      "cordata",
      "coricato",
      "cornice",
      "corolla",
      "corpo",
      "corredo",
      "corsia",
      "cortese",
      "cosmico",
      "costante",
      "cottura",
      "covato",
      "cratere",
      "cravatta",
      "creato",
      "credere",
      "cremoso",
      "crescita",
      "creta",
      "criceto",
      "crinale",
      "crisi",
      "critico",
      "croce",
      "cronaca",
      "crostata",
      "cruciale",
      "crusca",
      "cucire",
      "cuculo",
      "cugino",
      "cullato",
      "cupola",
      "curatore",
      "cursore",
      "curvo",
      "cuscino",
      "custode",
      "dado",
      "daino",
      "dalmata",
      "damerino",
      "daniela",
      "dannoso",
      "danzare",
      "datato",
      "davanti",
      "davvero",
      "debutto",
      "decennio",
      "deciso",
      "declino",
      "decollo",
      "decreto",
      "dedicato",
      "definito",
      "deforme",
      "degno",
      "delegare",
      "delfino",
      "delirio",
      "delta",
      "demenza",
      "denotato",
      "dentro",
      "deposito",
      "derapata",
      "derivare",
      "deroga",
      "descritto",
      "deserto",
      "desiderio",
      "desumere",
      "detersivo",
      "devoto",
      "diametro",
      "dicembre",
      "diedro",
      "difeso",
      "diffuso",
      "digerire",
      "digitale",
      "diluvio",
      "dinamico",
      "dinnanzi",
      "dipinto",
      "diploma",
      "dipolo",
      "diradare",
      "dire",
      "dirotto",
      "dirupo",
      "disagio",
      "discreto",
      "disfare",
      "disgelo",
      "disposto",
      "distanza",
      "disumano",
      "dito",
      "divano",
      "divelto",
      "dividere",
      "divorato",
      "doblone",
      "docente",
      "doganale",
      "dogma",
      "dolce",
      "domato",
      "domenica",
      "dominare",
      "dondolo",
      "dono",
      "dormire",
      "dote",
      "dottore",
      "dovuto",
      "dozzina",
      "drago",
      "druido",
      "dubbio",
      "dubitare",
      "ducale",
      "duna",
      "duomo",
      "duplice",
      "duraturo",
      "ebano",
      "eccesso",
      "ecco",
      "eclissi",
      "economia",
      "edera",
      "edicola",
      "edile",
      "editoria",
      "educare",
      "egemonia",
      "egli",
      "egoismo",
      "egregio",
      "elaborato",
      "elargire",
      "elegante",
      "elencato",
      "eletto",
      "elevare",
      "elfico",
      "elica",
      "elmo",
      "elsa",
      "eluso",
      "emanato",
      "emblema",
      "emesso",
      "emiro",
      "emotivo",
      "emozione",
      "empirico",
      "emulo",
      "endemico",
      "enduro",
      "energia",
      "enfasi",
      "enoteca",
      "entrare",
      "enzima",
      "epatite",
      "epilogo",
      "episodio",
      "epocale",
      "eppure",
      "equatore",
      "erario",
      "erba",
      "erboso",
      "erede",
      "eremita",
      "erigere",
      "ermetico",
      "eroe",
      "erosivo",
      "errante",
      "esagono",
      "esame",
      "esanime",
      "esaudire",
      "esca",
      "esempio",
      "esercito",
      "esibito",
      "esigente",
      "esistere",
      "esito",
      "esofago",
      "esortato",
      "esoso",
      "espanso",
      "espresso",
      "essenza",
      "esso",
      "esteso",
      "estimare",
      "estonia",
      "estroso",
      "esultare",
      "etilico",
      "etnico",
      "etrusco",
      "etto",
      "euclideo",
      "europa",
      "evaso",
      "evidenza",
      "evitato",
      "evoluto",
      "evviva",
      "fabbrica",
      "faccenda",
      "fachiro",
      "falco",
      "famiglia",
      "fanale",
      "fanfara",
      "fango",
      "fantasma",
      "fare",
      "farfalla",
      "farinoso",
      "farmaco",
      "fascia",
      "fastoso",
      "fasullo",
      "faticare",
      "fato",
      "favoloso",
      "febbre",
      "fecola",
      "fede",
      "fegato",
      "felpa",
      "feltro",
      "femmina",
      "fendere",
      "fenomeno",
      "fermento",
      "ferro",
      "fertile",
      "fessura",
      "festivo",
      "fetta",
      "feudo",
      "fiaba",
      "fiducia",
      "fifa",
      "figurato",
      "filo",
      "finanza",
      "finestra",
      "finire",
      "fiore",
      "fiscale",
      "fisico",
      "fiume",
      "flacone",
      "flamenco",
      "flebo",
      "flemma",
      "florido",
      "fluente",
      "fluoro",
      "fobico",
      "focaccia",
      "focoso",
      "foderato",
      "foglio",
      "folata",
      "folclore",
      "folgore",
      "fondente",
      "fonetico",
      "fonia",
      "fontana",
      "forbito",
      "forchetta",
      "foresta",
      "formica",
      "fornaio",
      "foro",
      "fortezza",
      "forzare",
      "fosfato",
      "fosso",
      "fracasso",
      "frana",
      "frassino",
      "fratello",
      "freccetta",
      "frenata",
      "fresco",
      "frigo",
      "frollino",
      "fronde",
      "frugale",
      "frutta",
      "fucilata",
      "fucsia",
      "fuggente",
      "fulmine",
      "fulvo",
      "fumante",
      "fumetto",
      "fumoso",
      "fune",
      "funzione",
      "fuoco",
      "furbo",
      "furgone",
      "furore",
      "fuso",
      "futile",
      "gabbiano",
      "gaffe",
      "galateo",
      "gallina",
      "galoppo",
      "gambero",
      "gamma",
      "garanzia",
      "garbo",
      "garofano",
      "garzone",
      "gasdotto",
      "gasolio",
      "gastrico",
      "gatto",
      "gaudio",
      "gazebo",
      "gazzella",
      "geco",
      "gelatina",
      "gelso",
      "gemello",
      "gemmato",
      "gene",
      "genitore",
      "gennaio",
      "genotipo",
      "gergo",
      "ghepardo",
      "ghiaccio",
      "ghisa",
      "giallo",
      "gilda",
      "ginepro",
      "giocare",
      "gioiello",
      "giorno",
      "giove",
      "girato",
      "girone",
      "gittata",
      "giudizio",
      "giurato",
      "giusto",
      "globulo",
      "glutine",
      "gnomo",
      "gobba",
      "golf",
      "gomito",
      "gommone",
      "gonfio",
      "gonna",
      "governo",
      "gracile",
      "grado",
      "grafico",
      "grammo",
      "grande",
      "grattare",
      "gravoso",
      "grazia",
      "greca",
      "gregge",
      "grifone",
      "grigio",
      "grinza",
      "grotta",
      "gruppo",
      "guadagno",
      "guaio",
      "guanto",
      "guardare",
      "gufo",
      "guidare",
      "ibernato",
      "icona",
      "identico",
      "idillio",
      "idolo",
      "idra",
      "idrico",
      "idrogeno",
      "igiene",
      "ignaro",
      "ignorato",
      "ilare",
      "illeso",
      "illogico",
      "illudere",
      "imballo",
      "imbevuto",
      "imbocco",
      "imbuto",
      "immane",
      "immerso",
      "immolato",
      "impacco",
      "impeto",
      "impiego",
      "importo",
      "impronta",
      "inalare",
      "inarcare",
      "inattivo",
      "incanto",
      "incendio",
      "inchino",
      "incisivo",
      "incluso",
      "incontro",
      "incrocio",
      "incubo",
      "indagine",
      "india",
      "indole",
      "inedito",
      "infatti",
      "infilare",
      "inflitto",
      "ingaggio",
      "ingegno",
      "inglese",
      "ingordo",
      "ingrosso",
      "innesco",
      "inodore",
      "inoltrare",
      "inondato",
      "insano",
      "insetto",
      "insieme",
      "insonnia",
      "insulina",
      "intasato",
      "intero",
      "intonaco",
      "intuito",
      "inumidire",
      "invalido",
      "invece",
      "invito",
      "iperbole",
      "ipnotico",
      "ipotesi",
      "ippica",
      "iride",
      "irlanda",
      "ironico",
      "irrigato",
      "irrorare",
      "isolato",
      "isotopo",
      "isterico",
      "istituto",
      "istrice",
      "italia",
      "iterare",
      "labbro",
      "labirinto",
      "lacca",
      "lacerato",
      "lacrima",
      "lacuna",
      "laddove",
      "lago",
      "lampo",
      "lancetta",
      "lanterna",
      "lardoso",
      "larga",
      "laringe",
      "lastra",
      "latenza",
      "latino",
      "lattuga",
      "lavagna",
      "lavoro",
      "legale",
      "leggero",
      "lembo",
      "lentezza",
      "lenza",
      "leone",
      "lepre",
      "lesivo",
      "lessato",
      "lesto",
      "letterale",
      "leva",
      "levigato",
      "libero",
      "lido",
      "lievito",
      "lilla",
      "limatura",
      "limitare",
      "limpido",
      "lineare",
      "lingua",
      "liquido",
      "lira",
      "lirica",
      "lisca",
      "lite",
      "litigio",
      "livrea",
      "locanda",
      "lode",
      "logica",
      "lombare",
      "londra",
      "longevo",
      "loquace",
      "lorenzo",
      "loto",
      "lotteria",
      "luce",
      "lucidato",
      "lumaca",
      "luminoso",
      "lungo",
      "lupo",
      "luppolo",
      "lusinga",
      "lusso",
      "lutto",
      "macabro",
      "macchina",
      "macero",
      "macinato",
      "madama",
      "magico",
      "maglia",
      "magnete",
      "magro",
      "maiolica",
      "malafede",
      "malgrado",
      "malinteso",
      "malsano",
      "malto",
      "malumore",
      "mana",
      "mancia",
      "mandorla",
      "mangiare",
      "manifesto",
      "mannaro",
      "manovra",
      "mansarda",
      "mantide",
      "manubrio",
      "mappa",
      "maratona",
      "marcire",
      "maretta",
      "marmo",
      "marsupio",
      "maschera",
      "massaia",
      "mastino",
      "materasso",
      "matricola",
      "mattone",
      "maturo",
      "mazurca",
      "meandro",
      "meccanico",
      "mecenate",
      "medesimo",
      "meditare",
      "mega",
      "melassa",
      "melis",
      "melodia",
      "meninge",
      "meno",
      "mensola",
      "mercurio",
      "merenda",
      "merlo",
      "meschino",
      "mese",
      "messere",
      "mestolo",
      "metallo",
      "metodo",
      "mettere",
      "miagolare",
      "mica",
      "micelio",
      "michele",
      "microbo",
      "midollo",
      "miele",
      "migliore",
      "milano",
      "milite",
      "mimosa",
      "minerale",
      "mini",
      "minore",
      "mirino",
      "mirtillo",
      "miscela",
      "missiva",
      "misto",
      "misurare",
      "mitezza",
      "mitigare",
      "mitra",
      "mittente",
      "mnemonico",
      "modello",
      "modifica",
      "modulo",
      "mogano",
      "mogio",
      "mole",
      "molosso",
      "monastero",
      "monco",
      "mondina",
      "monetario",
      "monile",
      "monotono",
      "monsone",
      "montato",
      "monviso",
      "mora",
      "mordere",
      "morsicato",
      "mostro",
      "motivato",
      "motosega",
      "motto",
      "movenza",
      "movimento",
      "mozzo",
      "mucca",
      "mucosa",
      "muffa",
      "mughetto",
      "mugnaio",
      "mulatto",
      "mulinello",
      "multiplo",
      "mummia",
      "munto",
      "muovere",
      "murale",
      "musa",
      "muscolo",
      "musica",
      "mutevole",
      "muto",
      "nababbo",
      "nafta",
      "nanometro",
      "narciso",
      "narice",
      "narrato",
      "nascere",
      "nastrare",
      "naturale",
      "nautica",
      "naviglio",
      "nebulosa",
      "necrosi",
      "negativo",
      "negozio",
      "nemmeno",
      "neofita",
      "neretto",
      "nervo",
      "nessuno",
      "nettuno",
      "neutrale",
      "neve",
      "nevrotico",
      "nicchia",
      "ninfa",
      "nitido",
      "nobile",
      "nocivo",
      "nodo",
      "nome",
      "nomina",
      "nordico",
      "normale",
      "norvegese",
      "nostrano",
      "notare",
      "notizia",
      "notturno",
      "novella",
      "nucleo",
      "nulla",
      "numero",
      "nuovo",
      "nutrire",
      "nuvola",
      "nuziale",
      "oasi",
      "obbedire",
      "obbligo",
      "obelisco",
      "oblio",
      "obolo",
      "obsoleto",
      "occasione",
      "occhio",
      "occidente",
      "occorrere",
      "occultare",
      "ocra",
      "oculato",
      "odierno",
      "odorare",
      "offerta",
      "offrire",
      "offuscato",
      "oggetto",
      "oggi",
      "ognuno",
      "olandese",
      "olfatto",
      "oliato",
      "oliva",
      "ologramma",
      "oltre",
      "omaggio",
      "ombelico",
      "ombra",
      "omega",
      "omissione",
      "ondoso",
      "onere",
      "onice",
      "onnivoro",
      "onorevole",
      "onta",
      "operato",
      "opinione",
      "opposto",
      "oracolo",
      "orafo",
      "ordine",
      "orecchino",
      "orefice",
      "orfano",
      "organico",
      "origine",
      "orizzonte",
      "orma",
      "ormeggio",
      "ornativo",
      "orologio",
      "orrendo",
      "orribile",
      "ortensia",
      "ortica",
      "orzata",
      "orzo",
      "osare",
      "oscurare",
      "osmosi",
      "ospedale",
      "ospite",
      "ossa",
      "ossidare",
      "ostacolo",
      "oste",
      "otite",
      "otre",
      "ottagono",
      "ottimo",
      "ottobre",
      "ovale",
      "ovest",
      "ovino",
      "oviparo",
      "ovocito",
      "ovunque",
      "ovviare",
      "ozio",
      "pacchetto",
      "pace",
      "pacifico",
      "padella",
      "padrone",
      "paese",
      "paga",
      "pagina",
      "palazzina",
      "palesare",
      "pallido",
      "palo",
      "palude",
      "pandoro",
      "pannello",
      "paolo",
      "paonazzo",
      "paprica",
      "parabola",
      "parcella",
      "parere",
      "pargolo",
      "pari",
      "parlato",
      "parola",
      "partire",
      "parvenza",
      "parziale",
      "passivo",
      "pasticca",
      "patacca",
      "patologia",
      "pattume",
      "pavone",
      "peccato",
      "pedalare",
      "pedonale",
      "peggio",
      "peloso",
      "penare",
      "pendice",
      "penisola",
      "pennuto",
      "penombra",
      "pensare",
      "pentola",
      "pepe",
      "pepita",
      "perbene",
      "percorso",
      "perdonato",
      "perforare",
      "pergamena",
      "periodo",
      "permesso",
      "perno",
      "perplesso",
      "persuaso",
      "pertugio",
      "pervaso",
      "pesatore",
      "pesista",
      "peso",
      "pestifero",
      "petalo",
      "pettine",
      "petulante",
      "pezzo",
      "piacere",
      "pianta",
      "piattino",
      "piccino",
      "picozza",
      "piega",
      "pietra",
      "piffero",
      "pigiama",
      "pigolio",
      "pigro",
      "pila",
      "pilifero",
      "pillola",
      "pilota",
      "pimpante",
      "pineta",
      "pinna",
      "pinolo",
      "pioggia",
      "piombo",
      "piramide",
      "piretico",
      "pirite",
      "pirolisi",
      "pitone",
      "pizzico",
      "placebo",
      "planare",
      "plasma",
      "platano",
      "plenario",
      "pochezza",
      "poderoso",
      "podismo",
      "poesia",
      "poggiare",
      "polenta",
      "poligono",
      "pollice",
      "polmonite",
      "polpetta",
      "polso",
      "poltrona",
      "polvere",
      "pomice",
      "pomodoro",
      "ponte",
      "popoloso",
      "porfido",
      "poroso",
      "porpora",
      "porre",
      "portata",
      "posa",
      "positivo",
      "possesso",
      "postulato",
      "potassio",
      "potere",
      "pranzo",
      "prassi",
      "pratica",
      "precluso",
      "predica",
      "prefisso",
      "pregiato",
      "prelievo",
      "premere",
      "prenotare",
      "preparato",
      "presenza",
      "pretesto",
      "prevalso",
      "prima",
      "principe",
      "privato",
      "problema",
      "procura",
      "produrre",
      "profumo",
      "progetto",
      "prolunga",
      "promessa",
      "pronome",
      "proposta",
      "proroga",
      "proteso",
      "prova",
      "prudente",
      "prugna",
      "prurito",
      "psiche",
      "pubblico",
      "pudica",
      "pugilato",
      "pugno",
      "pulce",
      "pulito",
      "pulsante",
      "puntare",
      "pupazzo",
      "pupilla",
      "puro",
      "quadro",
      "qualcosa",
      "quasi",
      "querela",
      "quota",
      "raccolto",
      "raddoppio",
      "radicale",
      "radunato",
      "raffica",
      "ragazzo",
      "ragione",
      "ragno",
      "ramarro",
      "ramingo",
      "ramo",
      "randagio",
      "rantolare",
      "rapato",
      "rapina",
      "rappreso",
      "rasatura",
      "raschiato",
      "rasente",
      "rassegna",
      "rastrello",
      "rata",
      "ravveduto",
      "reale",
      "recepire",
      "recinto",
      "recluta",
      "recondito",
      "recupero",
      "reddito",
      "redimere",
      "regalato",
      "registro",
      "regola",
      "regresso",
      "relazione",
      "remare",
      "remoto",
      "renna",
      "replica",
      "reprimere",
      "reputare",
      "resa",
      "residente",
      "responso",
      "restauro",
      "rete",
      "retina",
      "retorica",
      "rettifica",
      "revocato",
      "riassunto",
      "ribadire",
      "ribelle",
      "ribrezzo",
      "ricarica",
      "ricco",
      "ricevere",
      "riciclato",
      "ricordo",
      "ricreduto",
      "ridicolo",
      "ridurre",
      "rifasare",
      "riflesso",
      "riforma",
      "rifugio",
      "rigare",
      "rigettato",
      "righello",
      "rilassato",
      "rilevato",
      "rimanere",
      "rimbalzo",
      "rimedio",
      "rimorchio",
      "rinascita",
      "rincaro",
      "rinforzo",
      "rinnovo",
      "rinomato",
      "rinsavito",
      "rintocco",
      "rinuncia",
      "rinvenire",
      "riparato",
      "ripetuto",
      "ripieno",
      "riportare",
      "ripresa",
      "ripulire",
      "risata",
      "rischio",
      "riserva",
      "risibile",
      "riso",
      "rispetto",
      "ristoro",
      "risultato",
      "risvolto",
      "ritardo",
      "ritegno",
      "ritmico",
      "ritrovo",
      "riunione",
      "riva",
      "riverso",
      "rivincita",
      "rivolto",
      "rizoma",
      "roba",
      "robotico",
      "robusto",
      "roccia",
      "roco",
      "rodaggio",
      "rodere",
      "roditore",
      "rogito",
      "rollio",
      "romantico",
      "rompere",
      "ronzio",
      "rosolare",
      "rospo",
      "rotante",
      "rotondo",
      "rotula",
      "rovescio",
      "rubizzo",
      "rubrica",
      "ruga",
      "rullino",
      "rumine",
      "rumoroso",
      "ruolo",
      "rupe",
      "russare",
      "rustico",
      "sabato",
      "sabbiare",
      "sabotato",
      "sagoma",
      "salasso",
      "saldatura",
      "salgemma",
      "salivare",
      "salmone",
      "salone",
      "saltare",
      "saluto",
      "salvo",
      "sapere",
      "sapido",
      "saporito",
      "saraceno",
      "sarcasmo",
      "sarto",
      "sassoso",
      "satellite",
      "satira",
      "satollo",
      "saturno",
      "savana",
      "savio",
      "saziato",
      "sbadiglio",
      "sbalzo",
      "sbancato",
      "sbarra",
      "sbattere",
      "sbavare",
      "sbendare",
      "sbirciare",
      "sbloccato",
      "sbocciato",
      "sbrinare",
      "sbruffone",
      "sbuffare",
      "scabroso",
      "scadenza",
      "scala",
      "scambiare",
      "scandalo",
      "scapola",
      "scarso",
      "scatenare",
      "scavato",
      "scelto",
      "scenico",
      "scettro",
      "scheda",
      "schiena",
      "sciarpa",
      "scienza",
      "scindere",
      "scippo",
      "sciroppo",
      "scivolo",
      "sclerare",
      "scodella",
      "scolpito",
      "scomparto",
      "sconforto",
      "scoprire",
      "scorta",
      "scossone",
      "scozzese",
      "scriba",
      "scrollare",
      "scrutinio",
      "scuderia",
      "scultore",
      "scuola",
      "scuro",
      "scusare",
      "sdebitare",
      "sdoganare",
      "seccatura",
      "secondo",
      "sedano",
      "seggiola",
      "segnalato",
      "segregato",
      "seguito",
      "selciato",
      "selettivo",
      "sella",
      "selvaggio",
      "semaforo",
      "sembrare",
      "seme",
      "seminato",
      "sempre",
      "senso",
      "sentire",
      "sepolto",
      "sequenza",
      "serata",
      "serbato",
      "sereno",
      "serio",
      "serpente",
      "serraglio",
      "servire",
      "sestina",
      "setola",
      "settimana",
      "sfacelo",
      "sfaldare",
      "sfamato",
      "sfarzoso",
      "sfaticato",
      "sfera",
      "sfida",
      "sfilato",
      "sfinge",
      "sfocato",
      "sfoderare",
      "sfogo",
      "sfoltire",
      "sforzato",
      "sfratto",
      "sfruttato",
      "sfuggito",
      "sfumare",
      "sfuso",
      "sgabello",
      "sgarbato",
      "sgonfiare",
      "sgorbio",
      "sgrassato",
      "sguardo",
      "sibilo",
      "siccome",
      "sierra",
      "sigla",
      "signore",
      "silenzio",
      "sillaba",
      "simbolo",
      "simpatico",
      "simulato",
      "sinfonia",
      "singolo",
      "sinistro",
      "sino",
      "sintesi",
      "sinusoide",
      "sipario",
      "sisma",
      "sistole",
      "situato",
      "slitta",
      "slogatura",
      "sloveno",
      "smarrito",
      "smemorato",
      "smentito",
      "smeraldo",
      "smilzo",
      "smontare",
      "smottato",
      "smussato",
      "snellire",
      "snervato",
      "snodo",
      "sobbalzo",
      "sobrio",
      "soccorso",
      "sociale",
      "sodale",
      "soffitto",
      "sogno",
      "soldato",
      "solenne",
      "solido",
      "sollazzo",
      "solo",
      "solubile",
      "solvente",
      "somatico",
      "somma",
      "sonda",
      "sonetto",
      "sonnifero",
      "sopire",
      "soppeso",
      "sopra",
      "sorgere",
      "sorpasso",
      "sorriso",
      "sorso",
      "sorteggio",
      "sorvolato",
      "sospiro",
      "sosta",
      "sottile",
      "spada",
      "spalla",
      "spargere",
      "spatola",
      "spavento",
      "spazzola",
      "specie",
      "spedire",
      "spegnere",
      "spelatura",
      "speranza",
      "spessore",
      "spettrale",
      "spezzato",
      "spia",
      "spigoloso",
      "spillato",
      "spinoso",
      "spirale",
      "splendido",
      "sportivo",
      "sposo",
      "spranga",
      "sprecare",
      "spronato",
      "spruzzo",
      "spuntino",
      "squillo",
      "sradicare",
      "srotolato",
      "stabile",
      "stacco",
      "staffa",
      "stagnare",
      "stampato",
      "stantio",
      "starnuto",
      "stasera",
      "statuto",
      "stelo",
      "steppa",
      "sterzo",
      "stiletto",
      "stima",
      "stirpe",
      "stivale",
      "stizzoso",
      "stonato",
      "storico",
      "strappo",
      "stregato",
      "stridulo",
      "strozzare",
      "strutto",
      "stuccare",
      "stufo",
      "stupendo",
      "subentro",
      "succoso",
      "sudore",
      "suggerito",
      "sugo",
      "sultano",
      "suonare",
      "superbo",
      "supporto",
      "surgelato",
      "surrogato",
      "sussurro",
      "sutura",
      "svagare",
      "svedese",
      "sveglio",
      "svelare",
      "svenuto",
      "svezia",
      "sviluppo",
      "svista",
      "svizzera",
      "svolta",
      "svuotare",
      "tabacco",
      "tabulato",
      "tacciare",
      "taciturno",
      "tale",
      "talismano",
      "tampone",
      "tannino",
      "tara",
      "tardivo",
      "targato",
      "tariffa",
      "tarpare",
      "tartaruga",
      "tasto",
      "tattico",
      "taverna",
      "tavolata",
      "tazza",
      "teca",
      "tecnico",
      "telefono",
      "temerario",
      "tempo",
      "temuto",
      "tendone",
      "tenero",
      "tensione",
      "tentacolo",
      "teorema",
      "terme",
      "terrazzo",
      "terzetto",
      "tesi",
      "tesserato",
      "testato",
      "tetro",
      "tettoia",
      "tifare",
      "tigella",
      "timbro",
      "tinto",
      "tipico",
      "tipografo",
      "tiraggio",
      "tiro",
      "titanio",
      "titolo",
      "titubante",
      "tizio",
      "tizzone",
      "toccare",
      "tollerare",
      "tolto",
      "tombola",
      "tomo",
      "tonfo",
      "tonsilla",
      "topazio",
      "topologia",
      "toppa",
      "torba",
      "tornare",
      "torrone",
      "tortora",
      "toscano",
      "tossire",
      "tostatura",
      "totano",
      "trabocco",
      "trachea",
      "trafila",
      "tragedia",
      "tralcio",
      "tramonto",
      "transito",
      "trapano",
      "trarre",
      "trasloco",
      "trattato",
      "trave",
      "treccia",
      "tremolio",
      "trespolo",
      "tributo",
      "tricheco",
      "trifoglio",
      "trillo",
      "trincea",
      "trio",
      "tristezza",
      "triturato",
      "trivella",
      "tromba",
      "trono",
      "troppo",
      "trottola",
      "trovare",
      "truccato",
      "tubatura",
      "tuffato",
      "tulipano",
      "tumulto",
      "tunisia",
      "turbare",
      "turchino",
      "tuta",
      "tutela",
      "ubicato",
      "uccello",
      "uccisore",
      "udire",
      "uditivo",
      "uffa",
      "ufficio",
      "uguale",
      "ulisse",
      "ultimato",
      "umano",
      "umile",
      "umorismo",
      "uncinetto",
      "ungere",
      "ungherese",
      "unicorno",
      "unificato",
      "unisono",
      "unitario",
      "unte",
      "uovo",
      "upupa",
      "uragano",
      "urgenza",
      "urlo",
      "usanza",
      "usato",
      "uscito",
      "usignolo",
      "usuraio",
      "utensile",
      "utilizzo",
      "utopia",
      "vacante",
      "vaccinato",
      "vagabondo",
      "vagliato",
      "valanga",
      "valgo",
      "valico",
      "valletta",
      "valoroso",
      "valutare",
      "valvola",
      "vampata",
      "vangare",
      "vanitoso",
      "vano",
      "vantaggio",
      "vanvera",
      "vapore",
      "varano",
      "varcato",
      "variante",
      "vasca",
      "vedetta",
      "vedova",
      "veduto",
      "vegetale",
      "veicolo",
      "velcro",
      "velina",
      "velluto",
      "veloce",
      "venato",
      "vendemmia",
      "vento",
      "verace",
      "verbale",
      "vergogna",
      "verifica",
      "vero",
      "verruca",
      "verticale",
      "vescica",
      "vessillo",
      "vestale",
      "veterano",
      "vetrina",
      "vetusto",
      "viandante",
      "vibrante",
      "vicenda",
      "vichingo",
      "vicinanza",
      "vidimare",
      "vigilia",
      "vigneto",
      "vigore",
      "vile",
      "villano",
      "vimini",
      "vincitore",
      "viola",
      "vipera",
      "virgola",
      "virologo",
      "virulento",
      "viscoso",
      "visione",
      "vispo",
      "vissuto",
      "visura",
      "vita",
      "vitello",
      "vittima",
      "vivanda",
      "vivido",
      "viziare",
      "voce",
      "voga",
      "volatile",
      "volere",
      "volpe",
      "voragine",
      "vulcano",
      "zampogna",
      "zanna",
      "zappato",
      "zattera",
      "zavorra",
      "zefiro",
      "zelante",
      "zelo",
      "zenzero",
      "zerbino",
      "zibetto",
      "zinco",
      "zircone",
      "zitto",
      "zolla",
      "zotico",
      "zucchero",
      "zufolo",
      "zulu",
      "zuppa"
    ];
  }
});

// node_modules/bip39/src/wordlists/spanish.json
var require_spanish = __commonJS({
  "node_modules/bip39/src/wordlists/spanish.json"(exports2, module2) {
    module2.exports = [
      "a\u0301baco",
      "abdomen",
      "abeja",
      "abierto",
      "abogado",
      "abono",
      "aborto",
      "abrazo",
      "abrir",
      "abuelo",
      "abuso",
      "acabar",
      "academia",
      "acceso",
      "accio\u0301n",
      "aceite",
      "acelga",
      "acento",
      "aceptar",
      "a\u0301cido",
      "aclarar",
      "acne\u0301",
      "acoger",
      "acoso",
      "activo",
      "acto",
      "actriz",
      "actuar",
      "acudir",
      "acuerdo",
      "acusar",
      "adicto",
      "admitir",
      "adoptar",
      "adorno",
      "aduana",
      "adulto",
      "ae\u0301reo",
      "afectar",
      "aficio\u0301n",
      "afinar",
      "afirmar",
      "a\u0301gil",
      "agitar",
      "agoni\u0301a",
      "agosto",
      "agotar",
      "agregar",
      "agrio",
      "agua",
      "agudo",
      "a\u0301guila",
      "aguja",
      "ahogo",
      "ahorro",
      "aire",
      "aislar",
      "ajedrez",
      "ajeno",
      "ajuste",
      "alacra\u0301n",
      "alambre",
      "alarma",
      "alba",
      "a\u0301lbum",
      "alcalde",
      "aldea",
      "alegre",
      "alejar",
      "alerta",
      "aleta",
      "alfiler",
      "alga",
      "algodo\u0301n",
      "aliado",
      "aliento",
      "alivio",
      "alma",
      "almeja",
      "almi\u0301bar",
      "altar",
      "alteza",
      "altivo",
      "alto",
      "altura",
      "alumno",
      "alzar",
      "amable",
      "amante",
      "amapola",
      "amargo",
      "amasar",
      "a\u0301mbar",
      "a\u0301mbito",
      "ameno",
      "amigo",
      "amistad",
      "amor",
      "amparo",
      "amplio",
      "ancho",
      "anciano",
      "ancla",
      "andar",
      "ande\u0301n",
      "anemia",
      "a\u0301ngulo",
      "anillo",
      "a\u0301nimo",
      "ani\u0301s",
      "anotar",
      "antena",
      "antiguo",
      "antojo",
      "anual",
      "anular",
      "anuncio",
      "an\u0303adir",
      "an\u0303ejo",
      "an\u0303o",
      "apagar",
      "aparato",
      "apetito",
      "apio",
      "aplicar",
      "apodo",
      "aporte",
      "apoyo",
      "aprender",
      "aprobar",
      "apuesta",
      "apuro",
      "arado",
      "aran\u0303a",
      "arar",
      "a\u0301rbitro",
      "a\u0301rbol",
      "arbusto",
      "archivo",
      "arco",
      "arder",
      "ardilla",
      "arduo",
      "a\u0301rea",
      "a\u0301rido",
      "aries",
      "armoni\u0301a",
      "arne\u0301s",
      "aroma",
      "arpa",
      "arpo\u0301n",
      "arreglo",
      "arroz",
      "arruga",
      "arte",
      "artista",
      "asa",
      "asado",
      "asalto",
      "ascenso",
      "asegurar",
      "aseo",
      "asesor",
      "asiento",
      "asilo",
      "asistir",
      "asno",
      "asombro",
      "a\u0301spero",
      "astilla",
      "astro",
      "astuto",
      "asumir",
      "asunto",
      "atajo",
      "ataque",
      "atar",
      "atento",
      "ateo",
      "a\u0301tico",
      "atleta",
      "a\u0301tomo",
      "atraer",
      "atroz",
      "atu\u0301n",
      "audaz",
      "audio",
      "auge",
      "aula",
      "aumento",
      "ausente",
      "autor",
      "aval",
      "avance",
      "avaro",
      "ave",
      "avellana",
      "avena",
      "avestruz",
      "avio\u0301n",
      "aviso",
      "ayer",
      "ayuda",
      "ayuno",
      "azafra\u0301n",
      "azar",
      "azote",
      "azu\u0301car",
      "azufre",
      "azul",
      "baba",
      "babor",
      "bache",
      "bahi\u0301a",
      "baile",
      "bajar",
      "balanza",
      "balco\u0301n",
      "balde",
      "bambu\u0301",
      "banco",
      "banda",
      "ban\u0303o",
      "barba",
      "barco",
      "barniz",
      "barro",
      "ba\u0301scula",
      "basto\u0301n",
      "basura",
      "batalla",
      "bateri\u0301a",
      "batir",
      "batuta",
      "bau\u0301l",
      "bazar",
      "bebe\u0301",
      "bebida",
      "bello",
      "besar",
      "beso",
      "bestia",
      "bicho",
      "bien",
      "bingo",
      "blanco",
      "bloque",
      "blusa",
      "boa",
      "bobina",
      "bobo",
      "boca",
      "bocina",
      "boda",
      "bodega",
      "boina",
      "bola",
      "bolero",
      "bolsa",
      "bomba",
      "bondad",
      "bonito",
      "bono",
      "bonsa\u0301i",
      "borde",
      "borrar",
      "bosque",
      "bote",
      "boti\u0301n",
      "bo\u0301veda",
      "bozal",
      "bravo",
      "brazo",
      "brecha",
      "breve",
      "brillo",
      "brinco",
      "brisa",
      "broca",
      "broma",
      "bronce",
      "brote",
      "bruja",
      "brusco",
      "bruto",
      "buceo",
      "bucle",
      "bueno",
      "buey",
      "bufanda",
      "bufo\u0301n",
      "bu\u0301ho",
      "buitre",
      "bulto",
      "burbuja",
      "burla",
      "burro",
      "buscar",
      "butaca",
      "buzo\u0301n",
      "caballo",
      "cabeza",
      "cabina",
      "cabra",
      "cacao",
      "cada\u0301ver",
      "cadena",
      "caer",
      "cafe\u0301",
      "cai\u0301da",
      "caima\u0301n",
      "caja",
      "cajo\u0301n",
      "cal",
      "calamar",
      "calcio",
      "caldo",
      "calidad",
      "calle",
      "calma",
      "calor",
      "calvo",
      "cama",
      "cambio",
      "camello",
      "camino",
      "campo",
      "ca\u0301ncer",
      "candil",
      "canela",
      "canguro",
      "canica",
      "canto",
      "can\u0303a",
      "can\u0303o\u0301n",
      "caoba",
      "caos",
      "capaz",
      "capita\u0301n",
      "capote",
      "captar",
      "capucha",
      "cara",
      "carbo\u0301n",
      "ca\u0301rcel",
      "careta",
      "carga",
      "carin\u0303o",
      "carne",
      "carpeta",
      "carro",
      "carta",
      "casa",
      "casco",
      "casero",
      "caspa",
      "castor",
      "catorce",
      "catre",
      "caudal",
      "causa",
      "cazo",
      "cebolla",
      "ceder",
      "cedro",
      "celda",
      "ce\u0301lebre",
      "celoso",
      "ce\u0301lula",
      "cemento",
      "ceniza",
      "centro",
      "cerca",
      "cerdo",
      "cereza",
      "cero",
      "cerrar",
      "certeza",
      "ce\u0301sped",
      "cetro",
      "chacal",
      "chaleco",
      "champu\u0301",
      "chancla",
      "chapa",
      "charla",
      "chico",
      "chiste",
      "chivo",
      "choque",
      "choza",
      "chuleta",
      "chupar",
      "ciclo\u0301n",
      "ciego",
      "cielo",
      "cien",
      "cierto",
      "cifra",
      "cigarro",
      "cima",
      "cinco",
      "cine",
      "cinta",
      "cipre\u0301s",
      "circo",
      "ciruela",
      "cisne",
      "cita",
      "ciudad",
      "clamor",
      "clan",
      "claro",
      "clase",
      "clave",
      "cliente",
      "clima",
      "cli\u0301nica",
      "cobre",
      "coccio\u0301n",
      "cochino",
      "cocina",
      "coco",
      "co\u0301digo",
      "codo",
      "cofre",
      "coger",
      "cohete",
      "coji\u0301n",
      "cojo",
      "cola",
      "colcha",
      "colegio",
      "colgar",
      "colina",
      "collar",
      "colmo",
      "columna",
      "combate",
      "comer",
      "comida",
      "co\u0301modo",
      "compra",
      "conde",
      "conejo",
      "conga",
      "conocer",
      "consejo",
      "contar",
      "copa",
      "copia",
      "corazo\u0301n",
      "corbata",
      "corcho",
      "cordo\u0301n",
      "corona",
      "correr",
      "coser",
      "cosmos",
      "costa",
      "cra\u0301neo",
      "cra\u0301ter",
      "crear",
      "crecer",
      "crei\u0301do",
      "crema",
      "cri\u0301a",
      "crimen",
      "cripta",
      "crisis",
      "cromo",
      "cro\u0301nica",
      "croqueta",
      "crudo",
      "cruz",
      "cuadro",
      "cuarto",
      "cuatro",
      "cubo",
      "cubrir",
      "cuchara",
      "cuello",
      "cuento",
      "cuerda",
      "cuesta",
      "cueva",
      "cuidar",
      "culebra",
      "culpa",
      "culto",
      "cumbre",
      "cumplir",
      "cuna",
      "cuneta",
      "cuota",
      "cupo\u0301n",
      "cu\u0301pula",
      "curar",
      "curioso",
      "curso",
      "curva",
      "cutis",
      "dama",
      "danza",
      "dar",
      "dardo",
      "da\u0301til",
      "deber",
      "de\u0301bil",
      "de\u0301cada",
      "decir",
      "dedo",
      "defensa",
      "definir",
      "dejar",
      "delfi\u0301n",
      "delgado",
      "delito",
      "demora",
      "denso",
      "dental",
      "deporte",
      "derecho",
      "derrota",
      "desayuno",
      "deseo",
      "desfile",
      "desnudo",
      "destino",
      "desvi\u0301o",
      "detalle",
      "detener",
      "deuda",
      "di\u0301a",
      "diablo",
      "diadema",
      "diamante",
      "diana",
      "diario",
      "dibujo",
      "dictar",
      "diente",
      "dieta",
      "diez",
      "difi\u0301cil",
      "digno",
      "dilema",
      "diluir",
      "dinero",
      "directo",
      "dirigir",
      "disco",
      "disen\u0303o",
      "disfraz",
      "diva",
      "divino",
      "doble",
      "doce",
      "dolor",
      "domingo",
      "don",
      "donar",
      "dorado",
      "dormir",
      "dorso",
      "dos",
      "dosis",
      "drago\u0301n",
      "droga",
      "ducha",
      "duda",
      "duelo",
      "duen\u0303o",
      "dulce",
      "du\u0301o",
      "duque",
      "durar",
      "dureza",
      "duro",
      "e\u0301bano",
      "ebrio",
      "echar",
      "eco",
      "ecuador",
      "edad",
      "edicio\u0301n",
      "edificio",
      "editor",
      "educar",
      "efecto",
      "eficaz",
      "eje",
      "ejemplo",
      "elefante",
      "elegir",
      "elemento",
      "elevar",
      "elipse",
      "e\u0301lite",
      "elixir",
      "elogio",
      "eludir",
      "embudo",
      "emitir",
      "emocio\u0301n",
      "empate",
      "empen\u0303o",
      "empleo",
      "empresa",
      "enano",
      "encargo",
      "enchufe",
      "enci\u0301a",
      "enemigo",
      "enero",
      "enfado",
      "enfermo",
      "engan\u0303o",
      "enigma",
      "enlace",
      "enorme",
      "enredo",
      "ensayo",
      "ensen\u0303ar",
      "entero",
      "entrar",
      "envase",
      "envi\u0301o",
      "e\u0301poca",
      "equipo",
      "erizo",
      "escala",
      "escena",
      "escolar",
      "escribir",
      "escudo",
      "esencia",
      "esfera",
      "esfuerzo",
      "espada",
      "espejo",
      "espi\u0301a",
      "esposa",
      "espuma",
      "esqui\u0301",
      "estar",
      "este",
      "estilo",
      "estufa",
      "etapa",
      "eterno",
      "e\u0301tica",
      "etnia",
      "evadir",
      "evaluar",
      "evento",
      "evitar",
      "exacto",
      "examen",
      "exceso",
      "excusa",
      "exento",
      "exigir",
      "exilio",
      "existir",
      "e\u0301xito",
      "experto",
      "explicar",
      "exponer",
      "extremo",
      "fa\u0301brica",
      "fa\u0301bula",
      "fachada",
      "fa\u0301cil",
      "factor",
      "faena",
      "faja",
      "falda",
      "fallo",
      "falso",
      "faltar",
      "fama",
      "familia",
      "famoso",
      "farao\u0301n",
      "farmacia",
      "farol",
      "farsa",
      "fase",
      "fatiga",
      "fauna",
      "favor",
      "fax",
      "febrero",
      "fecha",
      "feliz",
      "feo",
      "feria",
      "feroz",
      "fe\u0301rtil",
      "fervor",
      "festi\u0301n",
      "fiable",
      "fianza",
      "fiar",
      "fibra",
      "ficcio\u0301n",
      "ficha",
      "fideo",
      "fiebre",
      "fiel",
      "fiera",
      "fiesta",
      "figura",
      "fijar",
      "fijo",
      "fila",
      "filete",
      "filial",
      "filtro",
      "fin",
      "finca",
      "fingir",
      "finito",
      "firma",
      "flaco",
      "flauta",
      "flecha",
      "flor",
      "flota",
      "fluir",
      "flujo",
      "flu\u0301or",
      "fobia",
      "foca",
      "fogata",
      "fogo\u0301n",
      "folio",
      "folleto",
      "fondo",
      "forma",
      "forro",
      "fortuna",
      "forzar",
      "fosa",
      "foto",
      "fracaso",
      "fra\u0301gil",
      "franja",
      "frase",
      "fraude",
      "frei\u0301r",
      "freno",
      "fresa",
      "fri\u0301o",
      "frito",
      "fruta",
      "fuego",
      "fuente",
      "fuerza",
      "fuga",
      "fumar",
      "funcio\u0301n",
      "funda",
      "furgo\u0301n",
      "furia",
      "fusil",
      "fu\u0301tbol",
      "futuro",
      "gacela",
      "gafas",
      "gaita",
      "gajo",
      "gala",
      "galeri\u0301a",
      "gallo",
      "gamba",
      "ganar",
      "gancho",
      "ganga",
      "ganso",
      "garaje",
      "garza",
      "gasolina",
      "gastar",
      "gato",
      "gavila\u0301n",
      "gemelo",
      "gemir",
      "gen",
      "ge\u0301nero",
      "genio",
      "gente",
      "geranio",
      "gerente",
      "germen",
      "gesto",
      "gigante",
      "gimnasio",
      "girar",
      "giro",
      "glaciar",
      "globo",
      "gloria",
      "gol",
      "golfo",
      "goloso",
      "golpe",
      "goma",
      "gordo",
      "gorila",
      "gorra",
      "gota",
      "goteo",
      "gozar",
      "grada",
      "gra\u0301fico",
      "grano",
      "grasa",
      "gratis",
      "grave",
      "grieta",
      "grillo",
      "gripe",
      "gris",
      "grito",
      "grosor",
      "gru\u0301a",
      "grueso",
      "grumo",
      "grupo",
      "guante",
      "guapo",
      "guardia",
      "guerra",
      "gui\u0301a",
      "guin\u0303o",
      "guion",
      "guiso",
      "guitarra",
      "gusano",
      "gustar",
      "haber",
      "ha\u0301bil",
      "hablar",
      "hacer",
      "hacha",
      "hada",
      "hallar",
      "hamaca",
      "harina",
      "haz",
      "hazan\u0303a",
      "hebilla",
      "hebra",
      "hecho",
      "helado",
      "helio",
      "hembra",
      "herir",
      "hermano",
      "he\u0301roe",
      "hervir",
      "hielo",
      "hierro",
      "hi\u0301gado",
      "higiene",
      "hijo",
      "himno",
      "historia",
      "hocico",
      "hogar",
      "hoguera",
      "hoja",
      "hombre",
      "hongo",
      "honor",
      "honra",
      "hora",
      "hormiga",
      "horno",
      "hostil",
      "hoyo",
      "hueco",
      "huelga",
      "huerta",
      "hueso",
      "huevo",
      "huida",
      "huir",
      "humano",
      "hu\u0301medo",
      "humilde",
      "humo",
      "hundir",
      "huraca\u0301n",
      "hurto",
      "icono",
      "ideal",
      "idioma",
      "i\u0301dolo",
      "iglesia",
      "iglu\u0301",
      "igual",
      "ilegal",
      "ilusio\u0301n",
      "imagen",
      "ima\u0301n",
      "imitar",
      "impar",
      "imperio",
      "imponer",
      "impulso",
      "incapaz",
      "i\u0301ndice",
      "inerte",
      "infiel",
      "informe",
      "ingenio",
      "inicio",
      "inmenso",
      "inmune",
      "innato",
      "insecto",
      "instante",
      "intere\u0301s",
      "i\u0301ntimo",
      "intuir",
      "inu\u0301til",
      "invierno",
      "ira",
      "iris",
      "ironi\u0301a",
      "isla",
      "islote",
      "jabali\u0301",
      "jabo\u0301n",
      "jamo\u0301n",
      "jarabe",
      "jardi\u0301n",
      "jarra",
      "jaula",
      "jazmi\u0301n",
      "jefe",
      "jeringa",
      "jinete",
      "jornada",
      "joroba",
      "joven",
      "joya",
      "juerga",
      "jueves",
      "juez",
      "jugador",
      "jugo",
      "juguete",
      "juicio",
      "junco",
      "jungla",
      "junio",
      "juntar",
      "ju\u0301piter",
      "jurar",
      "justo",
      "juvenil",
      "juzgar",
      "kilo",
      "koala",
      "labio",
      "lacio",
      "lacra",
      "lado",
      "ladro\u0301n",
      "lagarto",
      "la\u0301grima",
      "laguna",
      "laico",
      "lamer",
      "la\u0301mina",
      "la\u0301mpara",
      "lana",
      "lancha",
      "langosta",
      "lanza",
      "la\u0301piz",
      "largo",
      "larva",
      "la\u0301stima",
      "lata",
      "la\u0301tex",
      "latir",
      "laurel",
      "lavar",
      "lazo",
      "leal",
      "leccio\u0301n",
      "leche",
      "lector",
      "leer",
      "legio\u0301n",
      "legumbre",
      "lejano",
      "lengua",
      "lento",
      "len\u0303a",
      "leo\u0301n",
      "leopardo",
      "lesio\u0301n",
      "letal",
      "letra",
      "leve",
      "leyenda",
      "libertad",
      "libro",
      "licor",
      "li\u0301der",
      "lidiar",
      "lienzo",
      "liga",
      "ligero",
      "lima",
      "li\u0301mite",
      "limo\u0301n",
      "limpio",
      "lince",
      "lindo",
      "li\u0301nea",
      "lingote",
      "lino",
      "linterna",
      "li\u0301quido",
      "liso",
      "lista",
      "litera",
      "litio",
      "litro",
      "llaga",
      "llama",
      "llanto",
      "llave",
      "llegar",
      "llenar",
      "llevar",
      "llorar",
      "llover",
      "lluvia",
      "lobo",
      "locio\u0301n",
      "loco",
      "locura",
      "lo\u0301gica",
      "logro",
      "lombriz",
      "lomo",
      "lonja",
      "lote",
      "lucha",
      "lucir",
      "lugar",
      "lujo",
      "luna",
      "lunes",
      "lupa",
      "lustro",
      "luto",
      "luz",
      "maceta",
      "macho",
      "madera",
      "madre",
      "maduro",
      "maestro",
      "mafia",
      "magia",
      "mago",
      "mai\u0301z",
      "maldad",
      "maleta",
      "malla",
      "malo",
      "mama\u0301",
      "mambo",
      "mamut",
      "manco",
      "mando",
      "manejar",
      "manga",
      "maniqui\u0301",
      "manjar",
      "mano",
      "manso",
      "manta",
      "man\u0303ana",
      "mapa",
      "ma\u0301quina",
      "mar",
      "marco",
      "marea",
      "marfil",
      "margen",
      "marido",
      "ma\u0301rmol",
      "marro\u0301n",
      "martes",
      "marzo",
      "masa",
      "ma\u0301scara",
      "masivo",
      "matar",
      "materia",
      "matiz",
      "matriz",
      "ma\u0301ximo",
      "mayor",
      "mazorca",
      "mecha",
      "medalla",
      "medio",
      "me\u0301dula",
      "mejilla",
      "mejor",
      "melena",
      "melo\u0301n",
      "memoria",
      "menor",
      "mensaje",
      "mente",
      "menu\u0301",
      "mercado",
      "merengue",
      "me\u0301rito",
      "mes",
      "meso\u0301n",
      "meta",
      "meter",
      "me\u0301todo",
      "metro",
      "mezcla",
      "miedo",
      "miel",
      "miembro",
      "miga",
      "mil",
      "milagro",
      "militar",
      "millo\u0301n",
      "mimo",
      "mina",
      "minero",
      "mi\u0301nimo",
      "minuto",
      "miope",
      "mirar",
      "misa",
      "miseria",
      "misil",
      "mismo",
      "mitad",
      "mito",
      "mochila",
      "mocio\u0301n",
      "moda",
      "modelo",
      "moho",
      "mojar",
      "molde",
      "moler",
      "molino",
      "momento",
      "momia",
      "monarca",
      "moneda",
      "monja",
      "monto",
      "mon\u0303o",
      "morada",
      "morder",
      "moreno",
      "morir",
      "morro",
      "morsa",
      "mortal",
      "mosca",
      "mostrar",
      "motivo",
      "mover",
      "mo\u0301vil",
      "mozo",
      "mucho",
      "mudar",
      "mueble",
      "muela",
      "muerte",
      "muestra",
      "mugre",
      "mujer",
      "mula",
      "muleta",
      "multa",
      "mundo",
      "mun\u0303eca",
      "mural",
      "muro",
      "mu\u0301sculo",
      "museo",
      "musgo",
      "mu\u0301sica",
      "muslo",
      "na\u0301car",
      "nacio\u0301n",
      "nadar",
      "naipe",
      "naranja",
      "nariz",
      "narrar",
      "nasal",
      "natal",
      "nativo",
      "natural",
      "na\u0301usea",
      "naval",
      "nave",
      "navidad",
      "necio",
      "ne\u0301ctar",
      "negar",
      "negocio",
      "negro",
      "neo\u0301n",
      "nervio",
      "neto",
      "neutro",
      "nevar",
      "nevera",
      "nicho",
      "nido",
      "niebla",
      "nieto",
      "nin\u0303ez",
      "nin\u0303o",
      "ni\u0301tido",
      "nivel",
      "nobleza",
      "noche",
      "no\u0301mina",
      "noria",
      "norma",
      "norte",
      "nota",
      "noticia",
      "novato",
      "novela",
      "novio",
      "nube",
      "nuca",
      "nu\u0301cleo",
      "nudillo",
      "nudo",
      "nuera",
      "nueve",
      "nuez",
      "nulo",
      "nu\u0301mero",
      "nutria",
      "oasis",
      "obeso",
      "obispo",
      "objeto",
      "obra",
      "obrero",
      "observar",
      "obtener",
      "obvio",
      "oca",
      "ocaso",
      "oce\u0301ano",
      "ochenta",
      "ocho",
      "ocio",
      "ocre",
      "octavo",
      "octubre",
      "oculto",
      "ocupar",
      "ocurrir",
      "odiar",
      "odio",
      "odisea",
      "oeste",
      "ofensa",
      "oferta",
      "oficio",
      "ofrecer",
      "ogro",
      "oi\u0301do",
      "oi\u0301r",
      "ojo",
      "ola",
      "oleada",
      "olfato",
      "olivo",
      "olla",
      "olmo",
      "olor",
      "olvido",
      "ombligo",
      "onda",
      "onza",
      "opaco",
      "opcio\u0301n",
      "o\u0301pera",
      "opinar",
      "oponer",
      "optar",
      "o\u0301ptica",
      "opuesto",
      "oracio\u0301n",
      "orador",
      "oral",
      "o\u0301rbita",
      "orca",
      "orden",
      "oreja",
      "o\u0301rgano",
      "orgi\u0301a",
      "orgullo",
      "oriente",
      "origen",
      "orilla",
      "oro",
      "orquesta",
      "oruga",
      "osadi\u0301a",
      "oscuro",
      "osezno",
      "oso",
      "ostra",
      "oton\u0303o",
      "otro",
      "oveja",
      "o\u0301vulo",
      "o\u0301xido",
      "oxi\u0301geno",
      "oyente",
      "ozono",
      "pacto",
      "padre",
      "paella",
      "pa\u0301gina",
      "pago",
      "pai\u0301s",
      "pa\u0301jaro",
      "palabra",
      "palco",
      "paleta",
      "pa\u0301lido",
      "palma",
      "paloma",
      "palpar",
      "pan",
      "panal",
      "pa\u0301nico",
      "pantera",
      "pan\u0303uelo",
      "papa\u0301",
      "papel",
      "papilla",
      "paquete",
      "parar",
      "parcela",
      "pared",
      "parir",
      "paro",
      "pa\u0301rpado",
      "parque",
      "pa\u0301rrafo",
      "parte",
      "pasar",
      "paseo",
      "pasio\u0301n",
      "paso",
      "pasta",
      "pata",
      "patio",
      "patria",
      "pausa",
      "pauta",
      "pavo",
      "payaso",
      "peato\u0301n",
      "pecado",
      "pecera",
      "pecho",
      "pedal",
      "pedir",
      "pegar",
      "peine",
      "pelar",
      "peldan\u0303o",
      "pelea",
      "peligro",
      "pellejo",
      "pelo",
      "peluca",
      "pena",
      "pensar",
      "pen\u0303o\u0301n",
      "peo\u0301n",
      "peor",
      "pepino",
      "pequen\u0303o",
      "pera",
      "percha",
      "perder",
      "pereza",
      "perfil",
      "perico",
      "perla",
      "permiso",
      "perro",
      "persona",
      "pesa",
      "pesca",
      "pe\u0301simo",
      "pestan\u0303a",
      "pe\u0301talo",
      "petro\u0301leo",
      "pez",
      "pezun\u0303a",
      "picar",
      "picho\u0301n",
      "pie",
      "piedra",
      "pierna",
      "pieza",
      "pijama",
      "pilar",
      "piloto",
      "pimienta",
      "pino",
      "pintor",
      "pinza",
      "pin\u0303a",
      "piojo",
      "pipa",
      "pirata",
      "pisar",
      "piscina",
      "piso",
      "pista",
      "pito\u0301n",
      "pizca",
      "placa",
      "plan",
      "plata",
      "playa",
      "plaza",
      "pleito",
      "pleno",
      "plomo",
      "pluma",
      "plural",
      "pobre",
      "poco",
      "poder",
      "podio",
      "poema",
      "poesi\u0301a",
      "poeta",
      "polen",
      "polici\u0301a",
      "pollo",
      "polvo",
      "pomada",
      "pomelo",
      "pomo",
      "pompa",
      "poner",
      "porcio\u0301n",
      "portal",
      "posada",
      "poseer",
      "posible",
      "poste",
      "potencia",
      "potro",
      "pozo",
      "prado",
      "precoz",
      "pregunta",
      "premio",
      "prensa",
      "preso",
      "previo",
      "primo",
      "pri\u0301ncipe",
      "prisio\u0301n",
      "privar",
      "proa",
      "probar",
      "proceso",
      "producto",
      "proeza",
      "profesor",
      "programa",
      "prole",
      "promesa",
      "pronto",
      "propio",
      "pro\u0301ximo",
      "prueba",
      "pu\u0301blico",
      "puchero",
      "pudor",
      "pueblo",
      "puerta",
      "puesto",
      "pulga",
      "pulir",
      "pulmo\u0301n",
      "pulpo",
      "pulso",
      "puma",
      "punto",
      "pun\u0303al",
      "pun\u0303o",
      "pupa",
      "pupila",
      "pure\u0301",
      "quedar",
      "queja",
      "quemar",
      "querer",
      "queso",
      "quieto",
      "qui\u0301mica",
      "quince",
      "quitar",
      "ra\u0301bano",
      "rabia",
      "rabo",
      "racio\u0301n",
      "radical",
      "rai\u0301z",
      "rama",
      "rampa",
      "rancho",
      "rango",
      "rapaz",
      "ra\u0301pido",
      "rapto",
      "rasgo",
      "raspa",
      "rato",
      "rayo",
      "raza",
      "razo\u0301n",
      "reaccio\u0301n",
      "realidad",
      "reban\u0303o",
      "rebote",
      "recaer",
      "receta",
      "rechazo",
      "recoger",
      "recreo",
      "recto",
      "recurso",
      "red",
      "redondo",
      "reducir",
      "reflejo",
      "reforma",
      "refra\u0301n",
      "refugio",
      "regalo",
      "regir",
      "regla",
      "regreso",
      "rehe\u0301n",
      "reino",
      "rei\u0301r",
      "reja",
      "relato",
      "relevo",
      "relieve",
      "relleno",
      "reloj",
      "remar",
      "remedio",
      "remo",
      "rencor",
      "rendir",
      "renta",
      "reparto",
      "repetir",
      "reposo",
      "reptil",
      "res",
      "rescate",
      "resina",
      "respeto",
      "resto",
      "resumen",
      "retiro",
      "retorno",
      "retrato",
      "reunir",
      "reve\u0301s",
      "revista",
      "rey",
      "rezar",
      "rico",
      "riego",
      "rienda",
      "riesgo",
      "rifa",
      "ri\u0301gido",
      "rigor",
      "rinco\u0301n",
      "rin\u0303o\u0301n",
      "ri\u0301o",
      "riqueza",
      "risa",
      "ritmo",
      "rito",
      "rizo",
      "roble",
      "roce",
      "rociar",
      "rodar",
      "rodeo",
      "rodilla",
      "roer",
      "rojizo",
      "rojo",
      "romero",
      "romper",
      "ron",
      "ronco",
      "ronda",
      "ropa",
      "ropero",
      "rosa",
      "rosca",
      "rostro",
      "rotar",
      "rubi\u0301",
      "rubor",
      "rudo",
      "rueda",
      "rugir",
      "ruido",
      "ruina",
      "ruleta",
      "rulo",
      "rumbo",
      "rumor",
      "ruptura",
      "ruta",
      "rutina",
      "sa\u0301bado",
      "saber",
      "sabio",
      "sable",
      "sacar",
      "sagaz",
      "sagrado",
      "sala",
      "saldo",
      "salero",
      "salir",
      "salmo\u0301n",
      "salo\u0301n",
      "salsa",
      "salto",
      "salud",
      "salvar",
      "samba",
      "sancio\u0301n",
      "sandi\u0301a",
      "sanear",
      "sangre",
      "sanidad",
      "sano",
      "santo",
      "sapo",
      "saque",
      "sardina",
      "sarte\u0301n",
      "sastre",
      "sata\u0301n",
      "sauna",
      "saxofo\u0301n",
      "seccio\u0301n",
      "seco",
      "secreto",
      "secta",
      "sed",
      "seguir",
      "seis",
      "sello",
      "selva",
      "semana",
      "semilla",
      "senda",
      "sensor",
      "sen\u0303al",
      "sen\u0303or",
      "separar",
      "sepia",
      "sequi\u0301a",
      "ser",
      "serie",
      "sermo\u0301n",
      "servir",
      "sesenta",
      "sesio\u0301n",
      "seta",
      "setenta",
      "severo",
      "sexo",
      "sexto",
      "sidra",
      "siesta",
      "siete",
      "siglo",
      "signo",
      "si\u0301laba",
      "silbar",
      "silencio",
      "silla",
      "si\u0301mbolo",
      "simio",
      "sirena",
      "sistema",
      "sitio",
      "situar",
      "sobre",
      "socio",
      "sodio",
      "sol",
      "solapa",
      "soldado",
      "soledad",
      "so\u0301lido",
      "soltar",
      "solucio\u0301n",
      "sombra",
      "sondeo",
      "sonido",
      "sonoro",
      "sonrisa",
      "sopa",
      "soplar",
      "soporte",
      "sordo",
      "sorpresa",
      "sorteo",
      "soste\u0301n",
      "so\u0301tano",
      "suave",
      "subir",
      "suceso",
      "sudor",
      "suegra",
      "suelo",
      "suen\u0303o",
      "suerte",
      "sufrir",
      "sujeto",
      "sulta\u0301n",
      "sumar",
      "superar",
      "suplir",
      "suponer",
      "supremo",
      "sur",
      "surco",
      "suren\u0303o",
      "surgir",
      "susto",
      "sutil",
      "tabaco",
      "tabique",
      "tabla",
      "tabu\u0301",
      "taco",
      "tacto",
      "tajo",
      "talar",
      "talco",
      "talento",
      "talla",
      "talo\u0301n",
      "taman\u0303o",
      "tambor",
      "tango",
      "tanque",
      "tapa",
      "tapete",
      "tapia",
      "tapo\u0301n",
      "taquilla",
      "tarde",
      "tarea",
      "tarifa",
      "tarjeta",
      "tarot",
      "tarro",
      "tarta",
      "tatuaje",
      "tauro",
      "taza",
      "tazo\u0301n",
      "teatro",
      "techo",
      "tecla",
      "te\u0301cnica",
      "tejado",
      "tejer",
      "tejido",
      "tela",
      "tele\u0301fono",
      "tema",
      "temor",
      "templo",
      "tenaz",
      "tender",
      "tener",
      "tenis",
      "tenso",
      "teori\u0301a",
      "terapia",
      "terco",
      "te\u0301rmino",
      "ternura",
      "terror",
      "tesis",
      "tesoro",
      "testigo",
      "tetera",
      "texto",
      "tez",
      "tibio",
      "tiburo\u0301n",
      "tiempo",
      "tienda",
      "tierra",
      "tieso",
      "tigre",
      "tijera",
      "tilde",
      "timbre",
      "ti\u0301mido",
      "timo",
      "tinta",
      "ti\u0301o",
      "ti\u0301pico",
      "tipo",
      "tira",
      "tiro\u0301n",
      "tita\u0301n",
      "ti\u0301tere",
      "ti\u0301tulo",
      "tiza",
      "toalla",
      "tobillo",
      "tocar",
      "tocino",
      "todo",
      "toga",
      "toldo",
      "tomar",
      "tono",
      "tonto",
      "topar",
      "tope",
      "toque",
      "to\u0301rax",
      "torero",
      "tormenta",
      "torneo",
      "toro",
      "torpedo",
      "torre",
      "torso",
      "tortuga",
      "tos",
      "tosco",
      "toser",
      "to\u0301xico",
      "trabajo",
      "tractor",
      "traer",
      "tra\u0301fico",
      "trago",
      "traje",
      "tramo",
      "trance",
      "trato",
      "trauma",
      "trazar",
      "tre\u0301bol",
      "tregua",
      "treinta",
      "tren",
      "trepar",
      "tres",
      "tribu",
      "trigo",
      "tripa",
      "triste",
      "triunfo",
      "trofeo",
      "trompa",
      "tronco",
      "tropa",
      "trote",
      "trozo",
      "truco",
      "trueno",
      "trufa",
      "tuberi\u0301a",
      "tubo",
      "tuerto",
      "tumba",
      "tumor",
      "tu\u0301nel",
      "tu\u0301nica",
      "turbina",
      "turismo",
      "turno",
      "tutor",
      "ubicar",
      "u\u0301lcera",
      "umbral",
      "unidad",
      "unir",
      "universo",
      "uno",
      "untar",
      "un\u0303a",
      "urbano",
      "urbe",
      "urgente",
      "urna",
      "usar",
      "usuario",
      "u\u0301til",
      "utopi\u0301a",
      "uva",
      "vaca",
      "vaci\u0301o",
      "vacuna",
      "vagar",
      "vago",
      "vaina",
      "vajilla",
      "vale",
      "va\u0301lido",
      "valle",
      "valor",
      "va\u0301lvula",
      "vampiro",
      "vara",
      "variar",
      "varo\u0301n",
      "vaso",
      "vecino",
      "vector",
      "vehi\u0301culo",
      "veinte",
      "vejez",
      "vela",
      "velero",
      "veloz",
      "vena",
      "vencer",
      "venda",
      "veneno",
      "vengar",
      "venir",
      "venta",
      "venus",
      "ver",
      "verano",
      "verbo",
      "verde",
      "vereda",
      "verja",
      "verso",
      "verter",
      "vi\u0301a",
      "viaje",
      "vibrar",
      "vicio",
      "vi\u0301ctima",
      "vida",
      "vi\u0301deo",
      "vidrio",
      "viejo",
      "viernes",
      "vigor",
      "vil",
      "villa",
      "vinagre",
      "vino",
      "vin\u0303edo",
      "violi\u0301n",
      "viral",
      "virgo",
      "virtud",
      "visor",
      "vi\u0301spera",
      "vista",
      "vitamina",
      "viudo",
      "vivaz",
      "vivero",
      "vivir",
      "vivo",
      "volca\u0301n",
      "volumen",
      "volver",
      "voraz",
      "votar",
      "voto",
      "voz",
      "vuelo",
      "vulgar",
      "yacer",
      "yate",
      "yegua",
      "yema",
      "yerno",
      "yeso",
      "yodo",
      "yoga",
      "yogur",
      "zafiro",
      "zanja",
      "zapato",
      "zarza",
      "zona",
      "zorro",
      "zumo",
      "zurdo"
    ];
  }
});

// node_modules/bip39/src/wordlists/japanese.json
var require_japanese = __commonJS({
  "node_modules/bip39/src/wordlists/japanese.json"(exports2, module2) {
    module2.exports = [
      "\u3042\u3044\u3053\u304F\u3057\u3093",
      "\u3042\u3044\u3055\u3064",
      "\u3042\u3044\u305F\u3099",
      "\u3042\u304A\u305D\u3099\u3089",
      "\u3042\u304B\u3061\u3083\u3093",
      "\u3042\u304D\u308B",
      "\u3042\u3051\u304B\u3099\u305F",
      "\u3042\u3051\u308B",
      "\u3042\u3053\u304B\u3099\u308C\u308B",
      "\u3042\u3055\u3044",
      "\u3042\u3055\u3072",
      "\u3042\u3057\u3042\u3068",
      "\u3042\u3057\u3099\u308F\u3046",
      "\u3042\u3059\u3099\u304B\u308B",
      "\u3042\u3059\u3099\u304D",
      "\u3042\u305D\u3075\u3099",
      "\u3042\u305F\u3048\u308B",
      "\u3042\u305F\u305F\u3081\u308B",
      "\u3042\u305F\u308A\u307E\u3048",
      "\u3042\u305F\u308B",
      "\u3042\u3064\u3044",
      "\u3042\u3064\u304B\u3046",
      "\u3042\u3063\u3057\u3085\u304F",
      "\u3042\u3064\u307E\u308A",
      "\u3042\u3064\u3081\u308B",
      "\u3042\u3066\u306A",
      "\u3042\u3066\u306F\u307E\u308B",
      "\u3042\u3072\u308B",
      "\u3042\u3075\u3099\u3089",
      "\u3042\u3075\u3099\u308B",
      "\u3042\u3075\u308C\u308B",
      "\u3042\u307E\u3044",
      "\u3042\u307E\u3068\u3099",
      "\u3042\u307E\u3084\u304B\u3059",
      "\u3042\u307E\u308A",
      "\u3042\u307F\u3082\u306E",
      "\u3042\u3081\u308A\u304B",
      "\u3042\u3084\u307E\u308B",
      "\u3042\u3086\u3080",
      "\u3042\u3089\u3044\u304F\u3099\u307E",
      "\u3042\u3089\u3057",
      "\u3042\u3089\u3059\u3057\u3099",
      "\u3042\u3089\u305F\u3081\u308B",
      "\u3042\u3089\u3086\u308B",
      "\u3042\u3089\u308F\u3059",
      "\u3042\u308A\u304B\u3099\u3068\u3046",
      "\u3042\u308F\u305B\u308B",
      "\u3042\u308F\u3066\u308B",
      "\u3042\u3093\u3044",
      "\u3042\u3093\u304B\u3099\u3044",
      "\u3042\u3093\u3053",
      "\u3042\u3093\u305B\u3099\u3093",
      "\u3042\u3093\u3066\u3044",
      "\u3042\u3093\u306A\u3044",
      "\u3042\u3093\u307E\u308A",
      "\u3044\u3044\u305F\u3099\u3059",
      "\u3044\u304A\u3093",
      "\u3044\u304B\u3099\u3044",
      "\u3044\u304B\u3099\u304F",
      "\u3044\u304D\u304A\u3044",
      "\u3044\u304D\u306A\u308A",
      "\u3044\u304D\u3082\u306E",
      "\u3044\u304D\u308B",
      "\u3044\u304F\u3057\u3099",
      "\u3044\u304F\u3075\u3099\u3093",
      "\u3044\u3051\u306F\u3099\u306A",
      "\u3044\u3051\u3093",
      "\u3044\u3053\u3046",
      "\u3044\u3053\u304F",
      "\u3044\u3053\u3064",
      "\u3044\u3055\u307E\u3057\u3044",
      "\u3044\u3055\u3093",
      "\u3044\u3057\u304D",
      "\u3044\u3057\u3099\u3085\u3046",
      "\u3044\u3057\u3099\u3087\u3046",
      "\u3044\u3057\u3099\u308F\u308B",
      "\u3044\u3059\u3099\u307F",
      "\u3044\u3059\u3099\u308C",
      "\u3044\u305B\u3044",
      "\u3044\u305B\u3048\u3072\u3099",
      "\u3044\u305B\u304B\u3044",
      "\u3044\u305B\u304D",
      "\u3044\u305B\u3099\u3093",
      "\u3044\u305D\u3046\u308D\u3046",
      "\u3044\u305D\u304B\u3099\u3057\u3044",
      "\u3044\u305F\u3099\u3044",
      "\u3044\u305F\u3099\u304F",
      "\u3044\u305F\u3059\u3099\u3089",
      "\u3044\u305F\u307F",
      "\u3044\u305F\u308A\u3042",
      "\u3044\u3061\u304A\u3046",
      "\u3044\u3061\u3057\u3099",
      "\u3044\u3061\u3068\u3099",
      "\u3044\u3061\u306F\u3099",
      "\u3044\u3061\u3075\u3099",
      "\u3044\u3061\u308A\u3085\u3046",
      "\u3044\u3064\u304B",
      "\u3044\u3063\u3057\u3085\u3093",
      "\u3044\u3063\u305B\u3044",
      "\u3044\u3063\u305D\u3046",
      "\u3044\u3063\u305F\u3093",
      "\u3044\u3063\u3061",
      "\u3044\u3063\u3066\u3044",
      "\u3044\u3063\u307B\u309A\u3046",
      "\u3044\u3066\u3055\u3099",
      "\u3044\u3066\u3093",
      "\u3044\u3068\u3099\u3046",
      "\u3044\u3068\u3053",
      "\u3044\u306A\u3044",
      "\u3044\u306A\u304B",
      "\u3044\u306D\u3080\u308A",
      "\u3044\u306E\u3061",
      "\u3044\u306E\u308B",
      "\u3044\u306F\u3064",
      "\u3044\u306F\u3099\u308B",
      "\u3044\u306F\u3093",
      "\u3044\u3072\u3099\u304D",
      "\u3044\u3072\u3093",
      "\u3044\u3075\u304F",
      "\u3044\u3078\u3093",
      "\u3044\u307B\u3046",
      "\u3044\u307F\u3093",
      "\u3044\u3082\u3046\u3068",
      "\u3044\u3082\u305F\u308C",
      "\u3044\u3082\u308A",
      "\u3044\u3084\u304B\u3099\u308B",
      "\u3044\u3084\u3059",
      "\u3044\u3088\u304B\u3093",
      "\u3044\u3088\u304F",
      "\u3044\u3089\u3044",
      "\u3044\u3089\u3059\u3068",
      "\u3044\u308A\u304F\u3099\u3061",
      "\u3044\u308A\u3087\u3046",
      "\u3044\u308C\u3044",
      "\u3044\u308C\u3082\u306E",
      "\u3044\u308C\u308B",
      "\u3044\u308D\u3048\u3093\u3072\u309A\u3064",
      "\u3044\u308F\u3044",
      "\u3044\u308F\u3046",
      "\u3044\u308F\u304B\u3093",
      "\u3044\u308F\u306F\u3099",
      "\u3044\u308F\u3086\u308B",
      "\u3044\u3093\u3051\u3099\u3093\u307E\u3081",
      "\u3044\u3093\u3055\u3064",
      "\u3044\u3093\u3057\u3087\u3046",
      "\u3044\u3093\u3088\u3046",
      "\u3046\u3048\u304D",
      "\u3046\u3048\u308B",
      "\u3046\u304A\u3055\u3099",
      "\u3046\u304B\u3099\u3044",
      "\u3046\u304B\u3075\u3099",
      "\u3046\u304B\u3078\u3099\u308B",
      "\u3046\u304D\u308F",
      "\u3046\u304F\u3089\u3044\u306A",
      "\u3046\u304F\u308C\u308C",
      "\u3046\u3051\u305F\u307E\u308F\u308B",
      "\u3046\u3051\u3064\u3051",
      "\u3046\u3051\u3068\u308B",
      "\u3046\u3051\u3082\u3064",
      "\u3046\u3051\u308B",
      "\u3046\u3053\u3099\u304B\u3059",
      "\u3046\u3053\u3099\u304F",
      "\u3046\u3053\u3093",
      "\u3046\u3055\u304D\u3099",
      "\u3046\u3057\u306A\u3046",
      "\u3046\u3057\u308D\u304B\u3099\u307F",
      "\u3046\u3059\u3044",
      "\u3046\u3059\u304D\u3099",
      "\u3046\u3059\u304F\u3099\u3089\u3044",
      "\u3046\u3059\u3081\u308B",
      "\u3046\u305B\u3064",
      "\u3046\u3061\u3042\u308F\u305B",
      "\u3046\u3061\u304B\u3099\u308F",
      "\u3046\u3061\u304D",
      "\u3046\u3061\u3085\u3046",
      "\u3046\u3063\u304B\u308A",
      "\u3046\u3064\u304F\u3057\u3044",
      "\u3046\u3063\u305F\u3048\u308B",
      "\u3046\u3064\u308B",
      "\u3046\u3068\u3099\u3093",
      "\u3046\u306A\u304D\u3099",
      "\u3046\u306A\u3057\u3099",
      "\u3046\u306A\u3059\u3099\u304F",
      "\u3046\u306A\u308B",
      "\u3046\u306D\u308B",
      "\u3046\u306E\u3046",
      "\u3046\u3075\u3099\u3051\u3099",
      "\u3046\u3075\u3099\u3053\u3099\u3048",
      "\u3046\u307E\u308C\u308B",
      "\u3046\u3081\u308B",
      "\u3046\u3082\u3046",
      "\u3046\u3084\u307E\u3046",
      "\u3046\u3088\u304F",
      "\u3046\u3089\u304B\u3099\u3048\u3059",
      "\u3046\u3089\u304F\u3099\u3061",
      "\u3046\u3089\u306A\u3044",
      "\u3046\u308A\u3042\u3051\u3099",
      "\u3046\u308A\u304D\u308C",
      "\u3046\u308B\u3055\u3044",
      "\u3046\u308C\u3057\u3044",
      "\u3046\u308C\u3086\u304D",
      "\u3046\u308C\u308B",
      "\u3046\u308D\u3053",
      "\u3046\u308F\u304D",
      "\u3046\u308F\u3055",
      "\u3046\u3093\u3053\u3046",
      "\u3046\u3093\u3061\u3093",
      "\u3046\u3093\u3066\u3093",
      "\u3046\u3093\u3068\u3099\u3046",
      "\u3048\u3044\u3048\u3093",
      "\u3048\u3044\u304B\u3099",
      "\u3048\u3044\u304D\u3087\u3046",
      "\u3048\u3044\u3053\u3099",
      "\u3048\u3044\u305B\u3044",
      "\u3048\u3044\u3075\u3099\u3093",
      "\u3048\u3044\u3088\u3046",
      "\u3048\u3044\u308F",
      "\u3048\u304A\u308A",
      "\u3048\u304B\u3099\u304A",
      "\u3048\u304B\u3099\u304F",
      "\u3048\u304D\u305F\u3044",
      "\u3048\u304F\u305B\u308B",
      "\u3048\u3057\u3083\u304F",
      "\u3048\u3059\u3066",
      "\u3048\u3064\u3089\u3093",
      "\u3048\u306E\u304F\u3099",
      "\u3048\u307B\u3046\u307E\u304D",
      "\u3048\u307B\u3093",
      "\u3048\u307E\u304D",
      "\u3048\u3082\u3057\u3099",
      "\u3048\u3082\u306E",
      "\u3048\u3089\u3044",
      "\u3048\u3089\u3075\u3099",
      "\u3048\u308A\u3042",
      "\u3048\u3093\u3048\u3093",
      "\u3048\u3093\u304B\u3044",
      "\u3048\u3093\u304D\u3099",
      "\u3048\u3093\u3051\u3099\u304D",
      "\u3048\u3093\u3057\u3085\u3046",
      "\u3048\u3093\u305B\u3099\u3064",
      "\u3048\u3093\u305D\u304F",
      "\u3048\u3093\u3061\u3087\u3046",
      "\u3048\u3093\u3068\u3064",
      "\u304A\u3044\u304B\u3051\u308B",
      "\u304A\u3044\u3053\u3059",
      "\u304A\u3044\u3057\u3044",
      "\u304A\u3044\u3064\u304F",
      "\u304A\u3046\u3048\u3093",
      "\u304A\u3046\u3055\u307E",
      "\u304A\u3046\u3057\u3099",
      "\u304A\u3046\u305B\u3064",
      "\u304A\u3046\u305F\u3044",
      "\u304A\u3046\u3075\u304F",
      "\u304A\u3046\u3078\u3099\u3044",
      "\u304A\u3046\u3088\u3046",
      "\u304A\u3048\u308B",
      "\u304A\u304A\u3044",
      "\u304A\u304A\u3046",
      "\u304A\u304A\u3068\u3099\u304A\u308A",
      "\u304A\u304A\u3084",
      "\u304A\u304A\u3088\u305D",
      "\u304A\u304B\u3048\u308A",
      "\u304A\u304B\u3059\u3099",
      "\u304A\u304B\u3099\u3080",
      "\u304A\u304B\u308F\u308A",
      "\u304A\u304D\u3099\u306A\u3046",
      "\u304A\u304D\u308B",
      "\u304A\u304F\u3055\u307E",
      "\u304A\u304F\u3057\u3099\u3087\u3046",
      "\u304A\u304F\u308A\u304B\u3099\u306A",
      "\u304A\u304F\u308B",
      "\u304A\u304F\u308C\u308B",
      "\u304A\u3053\u3059",
      "\u304A\u3053\u306A\u3046",
      "\u304A\u3053\u308B",
      "\u304A\u3055\u3048\u308B",
      "\u304A\u3055\u306A\u3044",
      "\u304A\u3055\u3081\u308B",
      "\u304A\u3057\u3044\u308C",
      "\u304A\u3057\u3048\u308B",
      "\u304A\u3057\u3099\u304D\u3099",
      "\u304A\u3057\u3099\u3055\u3093",
      "\u304A\u3057\u3083\u308C",
      "\u304A\u305D\u3089\u304F",
      "\u304A\u305D\u308F\u308B",
      "\u304A\u305F\u304B\u3099\u3044",
      "\u304A\u305F\u304F",
      "\u304A\u305F\u3099\u3084\u304B",
      "\u304A\u3061\u3064\u304F",
      "\u304A\u3063\u3068",
      "\u304A\u3064\u308A",
      "\u304A\u3066\u3099\u304B\u3051",
      "\u304A\u3068\u3057\u3082\u306E",
      "\u304A\u3068\u306A\u3057\u3044",
      "\u304A\u3068\u3099\u308A",
      "\u304A\u3068\u3099\u308D\u304B\u3059",
      "\u304A\u306F\u3099\u3055\u3093",
      "\u304A\u307E\u3044\u308A",
      "\u304A\u3081\u3066\u3099\u3068\u3046",
      "\u304A\u3082\u3044\u3066\u3099",
      "\u304A\u3082\u3046",
      "\u304A\u3082\u305F\u3044",
      "\u304A\u3082\u3061\u3083",
      "\u304A\u3084\u3064",
      "\u304A\u3084\u3086\u3072\u3099",
      "\u304A\u3088\u307B\u3099\u3059",
      "\u304A\u3089\u3093\u305F\u3099",
      "\u304A\u308D\u3059",
      "\u304A\u3093\u304B\u3099\u304F",
      "\u304A\u3093\u3051\u3044",
      "\u304A\u3093\u3057\u3083",
      "\u304A\u3093\u305B\u3093",
      "\u304A\u3093\u305F\u3099\u3093",
      "\u304A\u3093\u3061\u3085\u3046",
      "\u304A\u3093\u3068\u3099\u3051\u3044",
      "\u304B\u3042\u3064",
      "\u304B\u3044\u304B\u3099",
      "\u304B\u3099\u3044\u304D",
      "\u304B\u3099\u3044\u3051\u3093",
      "\u304B\u3099\u3044\u3053\u3046",
      "\u304B\u3044\u3055\u3064",
      "\u304B\u3044\u3057\u3083",
      "\u304B\u3044\u3059\u3044\u3088\u304F",
      "\u304B\u3044\u305B\u3099\u3093",
      "\u304B\u3044\u305D\u3099\u3046\u3068\u3099",
      "\u304B\u3044\u3064\u3046",
      "\u304B\u3044\u3066\u3093",
      "\u304B\u3044\u3068\u3046",
      "\u304B\u3044\u3075\u304F",
      "\u304B\u3099\u3044\u3078\u304D",
      "\u304B\u3044\u307B\u3046",
      "\u304B\u3044\u3088\u3046",
      "\u304B\u3099\u3044\u3089\u3044",
      "\u304B\u3044\u308F",
      "\u304B\u3048\u308B",
      "\u304B\u304A\u308A",
      "\u304B\u304B\u3048\u308B",
      "\u304B\u304B\u3099\u304F",
      "\u304B\u304B\u3099\u3057",
      "\u304B\u304B\u3099\u307F",
      "\u304B\u304F\u3053\u3099",
      "\u304B\u304F\u3068\u304F",
      "\u304B\u3055\u3099\u308B",
      "\u304B\u3099\u305D\u3099\u3046",
      "\u304B\u305F\u3044",
      "\u304B\u305F\u3061",
      "\u304B\u3099\u3061\u3087\u3046",
      "\u304B\u3099\u3063\u304D\u3085\u3046",
      "\u304B\u3099\u3063\u3053\u3046",
      "\u304B\u3099\u3063\u3055\u3093",
      "\u304B\u3099\u3063\u3057\u3087\u3046",
      "\u304B\u306A\u3055\u3099\u308F\u3057",
      "\u304B\u306E\u3046",
      "\u304B\u3099\u306F\u304F",
      "\u304B\u3075\u3099\u304B",
      "\u304B\u307B\u3046",
      "\u304B\u307B\u3053\u3099",
      "\u304B\u307E\u3046",
      "\u304B\u307E\u307B\u3099\u3053",
      "\u304B\u3081\u308C\u304A\u3093",
      "\u304B\u3086\u3044",
      "\u304B\u3088\u3046\u3072\u3099",
      "\u304B\u3089\u3044",
      "\u304B\u308B\u3044",
      "\u304B\u308D\u3046",
      "\u304B\u308F\u304F",
      "\u304B\u308F\u3089",
      "\u304B\u3099\u3093\u304B",
      "\u304B\u3093\u3051\u3044",
      "\u304B\u3093\u3053\u3046",
      "\u304B\u3093\u3057\u3083",
      "\u304B\u3093\u305D\u3046",
      "\u304B\u3093\u305F\u3093",
      "\u304B\u3093\u3061",
      "\u304B\u3099\u3093\u306F\u3099\u308B",
      "\u304D\u3042\u3044",
      "\u304D\u3042\u3064",
      "\u304D\u3044\u308D",
      "\u304D\u3099\u3044\u3093",
      "\u304D\u3046\u3044",
      "\u304D\u3046\u3093",
      "\u304D\u3048\u308B",
      "\u304D\u304A\u3046",
      "\u304D\u304A\u304F",
      "\u304D\u304A\u3061",
      "\u304D\u304A\u3093",
      "\u304D\u304B\u3044",
      "\u304D\u304B\u304F",
      "\u304D\u304B\u3093\u3057\u3083",
      "\u304D\u304D\u3066",
      "\u304D\u304F\u306F\u3099\u308A",
      "\u304D\u304F\u3089\u3051\u3099",
      "\u304D\u3051\u3093\u305B\u3044",
      "\u304D\u3053\u3046",
      "\u304D\u3053\u3048\u308B",
      "\u304D\u3053\u304F",
      "\u304D\u3055\u3044",
      "\u304D\u3055\u304F",
      "\u304D\u3055\u307E",
      "\u304D\u3055\u3089\u304D\u3099",
      "\u304D\u3099\u3057\u3099\u304B\u304B\u3099\u304F",
      "\u304D\u3099\u3057\u304D",
      "\u304D\u3099\u3057\u3099\u305F\u3044\u3051\u3093",
      "\u304D\u3099\u3057\u3099\u306B\u3063\u3066\u3044",
      "\u304D\u3099\u3057\u3099\u3085\u3064\u3057\u3083",
      "\u304D\u3059\u3046",
      "\u304D\u305B\u3044",
      "\u304D\u305B\u304D",
      "\u304D\u305B\u3064",
      "\u304D\u305D\u3046",
      "\u304D\u305D\u3099\u304F",
      "\u304D\u305D\u3099\u3093",
      "\u304D\u305F\u3048\u308B",
      "\u304D\u3061\u3087\u3046",
      "\u304D\u3064\u3048\u3093",
      "\u304D\u3099\u3063\u3061\u308A",
      "\u304D\u3064\u3064\u304D",
      "\u304D\u3064\u306D",
      "\u304D\u3066\u3044",
      "\u304D\u3068\u3099\u3046",
      "\u304D\u3068\u3099\u304F",
      "\u304D\u306A\u3044",
      "\u304D\u306A\u304B\u3099",
      "\u304D\u306A\u3053",
      "\u304D\u306C\u3053\u3099\u3057",
      "\u304D\u306D\u3093",
      "\u304D\u306E\u3046",
      "\u304D\u306E\u3057\u305F",
      "\u304D\u306F\u304F",
      "\u304D\u3072\u3099\u3057\u3044",
      "\u304D\u3072\u3093",
      "\u304D\u3075\u304F",
      "\u304D\u3075\u3099\u3093",
      "\u304D\u307B\u3099\u3046",
      "\u304D\u307B\u3093",
      "\u304D\u307E\u308B",
      "\u304D\u307F\u3064",
      "\u304D\u3080\u3059\u3099\u304B\u3057\u3044",
      "\u304D\u3081\u308B",
      "\u304D\u3082\u305F\u3099\u3081\u3057",
      "\u304D\u3082\u3061",
      "\u304D\u3082\u306E",
      "\u304D\u3083\u304F",
      "\u304D\u3084\u304F",
      "\u304D\u3099\u3085\u3046\u306B\u304F",
      "\u304D\u3088\u3046",
      "\u304D\u3087\u3046\u308A\u3085\u3046",
      "\u304D\u3089\u3044",
      "\u304D\u3089\u304F",
      "\u304D\u308A\u3093",
      "\u304D\u308C\u3044",
      "\u304D\u308C\u3064",
      "\u304D\u308D\u304F",
      "\u304D\u3099\u308D\u3093",
      "\u304D\u308F\u3081\u308B",
      "\u304D\u3099\u3093\u3044\u308D",
      "\u304D\u3093\u304B\u304F\u3057\u3099",
      "\u304D\u3093\u3057\u3099\u3087",
      "\u304D\u3093\u3088\u3046\u3072\u3099",
      "\u304F\u3099\u3042\u3044",
      "\u304F\u3044\u3059\u3099",
      "\u304F\u3046\u304B\u3093",
      "\u304F\u3046\u304D",
      "\u304F\u3046\u304F\u3099\u3093",
      "\u304F\u3046\u3053\u3046",
      "\u304F\u3099\u3046\u305B\u3044",
      "\u304F\u3046\u305D\u3046",
      "\u304F\u3099\u3046\u305F\u3089",
      "\u304F\u3046\u3075\u304F",
      "\u304F\u3046\u307B\u3099",
      "\u304F\u304B\u3093",
      "\u304F\u304D\u3087\u3046",
      "\u304F\u3051\u3099\u3093",
      "\u304F\u3099\u3053\u3046",
      "\u304F\u3055\u3044",
      "\u304F\u3055\u304D",
      "\u304F\u3055\u306F\u3099\u306A",
      "\u304F\u3055\u308B",
      "\u304F\u3057\u3083\u307F",
      "\u304F\u3057\u3087\u3046",
      "\u304F\u3059\u306E\u304D",
      "\u304F\u3059\u308A\u3086\u3072\u3099",
      "\u304F\u305B\u3051\u3099",
      "\u304F\u305B\u3093",
      "\u304F\u3099\u305F\u3044\u3066\u304D",
      "\u304F\u305F\u3099\u3055\u308B",
      "\u304F\u305F\u3072\u3099\u308C\u308B",
      "\u304F\u3061\u3053\u307F",
      "\u304F\u3061\u3055\u304D",
      "\u304F\u3064\u3057\u305F",
      "\u304F\u3099\u3063\u3059\u308A",
      "\u304F\u3064\u308D\u304F\u3099",
      "\u304F\u3068\u3046\u3066\u3093",
      "\u304F\u3068\u3099\u304F",
      "\u304F\u306A\u3093",
      "\u304F\u306D\u304F\u306D",
      "\u304F\u306E\u3046",
      "\u304F\u3075\u3046",
      "\u304F\u307F\u3042\u308F\u305B",
      "\u304F\u307F\u305F\u3066\u308B",
      "\u304F\u3081\u308B",
      "\u304F\u3084\u304F\u3057\u3087",
      "\u304F\u3089\u3059",
      "\u304F\u3089\u3078\u3099\u308B",
      "\u304F\u308B\u307E",
      "\u304F\u308C\u308B",
      "\u304F\u308D\u3046",
      "\u304F\u308F\u3057\u3044",
      "\u304F\u3099\u3093\u304B\u3093",
      "\u304F\u3099\u3093\u3057\u3087\u304F",
      "\u304F\u3099\u3093\u305F\u3044",
      "\u304F\u3099\u3093\u3066",
      "\u3051\u3042\u306A",
      "\u3051\u3044\u304B\u304F",
      "\u3051\u3044\u3051\u3093",
      "\u3051\u3044\u3053",
      "\u3051\u3044\u3055\u3064",
      "\u3051\u3099\u3044\u3057\u3099\u3085\u3064",
      "\u3051\u3044\u305F\u3044",
      "\u3051\u3099\u3044\u306E\u3046\u3057\u3099\u3093",
      "\u3051\u3044\u308C\u304D",
      "\u3051\u3044\u308D",
      "\u3051\u304A\u3068\u3059",
      "\u3051\u304A\u308A\u3082\u306E",
      "\u3051\u3099\u304D\u304B",
      "\u3051\u3099\u304D\u3051\u3099\u3093",
      "\u3051\u3099\u304D\u305F\u3099\u3093",
      "\u3051\u3099\u304D\u3061\u3093",
      "\u3051\u3099\u304D\u3068\u3064",
      "\u3051\u3099\u304D\u306F",
      "\u3051\u3099\u304D\u3084\u304F",
      "\u3051\u3099\u3053\u3046",
      "\u3051\u3099\u3053\u304F\u3057\u3099\u3087\u3046",
      "\u3051\u3099\u3055\u3099\u3044",
      "\u3051\u3055\u304D",
      "\u3051\u3099\u3055\u3099\u3093",
      "\u3051\u3057\u304D",
      "\u3051\u3057\u3053\u3099\u3080",
      "\u3051\u3057\u3087\u3046",
      "\u3051\u3099\u3059\u3068",
      "\u3051\u305F\u306F\u3099",
      "\u3051\u3061\u3083\u3063\u3075\u309A",
      "\u3051\u3061\u3089\u3059",
      "\u3051\u3064\u3042\u3064",
      "\u3051\u3064\u3044",
      "\u3051\u3064\u3048\u304D",
      "\u3051\u3063\u3053\u3093",
      "\u3051\u3064\u3057\u3099\u3087",
      "\u3051\u3063\u305B\u304D",
      "\u3051\u3063\u3066\u3044",
      "\u3051\u3064\u307E\u3064",
      "\u3051\u3099\u3064\u3088\u3046\u3072\u3099",
      "\u3051\u3099\u3064\u308C\u3044",
      "\u3051\u3064\u308D\u3093",
      "\u3051\u3099\u3068\u3099\u304F",
      "\u3051\u3068\u306F\u3099\u3059",
      "\u3051\u3068\u308B",
      "\u3051\u306A\u3051\u3099",
      "\u3051\u306A\u3059",
      "\u3051\u306A\u307F",
      "\u3051\u306C\u304D",
      "\u3051\u3099\u306D\u3064",
      "\u3051\u306D\u3093",
      "\u3051\u306F\u3044",
      "\u3051\u3099\u3072\u3093",
      "\u3051\u3075\u3099\u304B\u3044",
      "\u3051\u3099\u307B\u3099\u304F",
      "\u3051\u307E\u308A",
      "\u3051\u307F\u304B\u308B",
      "\u3051\u3080\u3057",
      "\u3051\u3080\u308A",
      "\u3051\u3082\u306E",
      "\u3051\u3089\u3044",
      "\u3051\u308D\u3051\u308D",
      "\u3051\u308F\u3057\u3044",
      "\u3051\u3093\u3044",
      "\u3051\u3093\u3048\u3064",
      "\u3051\u3093\u304A",
      "\u3051\u3093\u304B",
      "\u3051\u3099\u3093\u304D",
      "\u3051\u3093\u3051\u3099\u3093",
      "\u3051\u3093\u3053\u3046",
      "\u3051\u3093\u3055\u304F",
      "\u3051\u3093\u3057\u3085\u3046",
      "\u3051\u3093\u3059\u3046",
      "\u3051\u3099\u3093\u305D\u3046",
      "\u3051\u3093\u3061\u304F",
      "\u3051\u3093\u3066\u3044",
      "\u3051\u3093\u3068\u3046",
      "\u3051\u3093\u306A\u3044",
      "\u3051\u3093\u306B\u3093",
      "\u3051\u3099\u3093\u3075\u3099\u3064",
      "\u3051\u3093\u307E",
      "\u3051\u3093\u307F\u3093",
      "\u3051\u3093\u3081\u3044",
      "\u3051\u3093\u3089\u3093",
      "\u3051\u3093\u308A",
      "\u3053\u3042\u304F\u307E",
      "\u3053\u3044\u306C",
      "\u3053\u3044\u3072\u3099\u3068",
      "\u3053\u3099\u3046\u3044",
      "\u3053\u3046\u3048\u3093",
      "\u3053\u3046\u304A\u3093",
      "\u3053\u3046\u304B\u3093",
      "\u3053\u3099\u3046\u304D\u3085\u3046",
      "\u3053\u3099\u3046\u3051\u3044",
      "\u3053\u3046\u3053\u3046",
      "\u3053\u3046\u3055\u3044",
      "\u3053\u3046\u3057\u3099",
      "\u3053\u3046\u3059\u3044",
      "\u3053\u3099\u3046\u305B\u3044",
      "\u3053\u3046\u305D\u304F",
      "\u3053\u3046\u305F\u3044",
      "\u3053\u3046\u3061\u3083",
      "\u3053\u3046\u3064\u3046",
      "\u3053\u3046\u3066\u3044",
      "\u3053\u3046\u3068\u3099\u3046",
      "\u3053\u3046\u306A\u3044",
      "\u3053\u3046\u306F\u3044",
      "\u3053\u3099\u3046\u307B\u3046",
      "\u3053\u3099\u3046\u307E\u3093",
      "\u3053\u3046\u3082\u304F",
      "\u3053\u3046\u308A\u3064",
      "\u3053\u3048\u308B",
      "\u3053\u304A\u308A",
      "\u3053\u3099\u304B\u3044",
      "\u3053\u3099\u304B\u3099\u3064",
      "\u3053\u3099\u304B\u3093",
      "\u3053\u304F\u3053\u3099",
      "\u3053\u304F\u3055\u3044",
      "\u3053\u304F\u3068\u3046",
      "\u3053\u304F\u306A\u3044",
      "\u3053\u304F\u306F\u304F",
      "\u3053\u304F\u3099\u307E",
      "\u3053\u3051\u3044",
      "\u3053\u3051\u308B",
      "\u3053\u3053\u306E\u304B",
      "\u3053\u3053\u308D",
      "\u3053\u3055\u3081",
      "\u3053\u3057\u3064",
      "\u3053\u3059\u3046",
      "\u3053\u305B\u3044",
      "\u3053\u305B\u304D",
      "\u3053\u305B\u3099\u3093",
      "\u3053\u305D\u305F\u3099\u3066",
      "\u3053\u305F\u3044",
      "\u3053\u305F\u3048\u308B",
      "\u3053\u305F\u3064",
      "\u3053\u3061\u3087\u3046",
      "\u3053\u3063\u304B",
      "\u3053\u3064\u3053\u3064",
      "\u3053\u3064\u306F\u3099\u3093",
      "\u3053\u3064\u3075\u3099",
      "\u3053\u3066\u3044",
      "\u3053\u3066\u3093",
      "\u3053\u3068\u304B\u3099\u3089",
      "\u3053\u3068\u3057",
      "\u3053\u3068\u306F\u3099",
      "\u3053\u3068\u308A",
      "\u3053\u306A\u3053\u3099\u306A",
      "\u3053\u306D\u3053\u306D",
      "\u3053\u306E\u307E\u307E",
      "\u3053\u306E\u307F",
      "\u3053\u306E\u3088",
      "\u3053\u3099\u306F\u3093",
      "\u3053\u3072\u3064\u3057\u3099",
      "\u3053\u3075\u3046",
      "\u3053\u3075\u3093",
      "\u3053\u307B\u3099\u308C\u308B",
      "\u3053\u3099\u307E\u3042\u3075\u3099\u3089",
      "\u3053\u307E\u304B\u3044",
      "\u3053\u3099\u307E\u3059\u308A",
      "\u3053\u307E\u3064\u306A",
      "\u3053\u307E\u308B",
      "\u3053\u3080\u304D\u3099\u3053",
      "\u3053\u3082\u3057\u3099",
      "\u3053\u3082\u3061",
      "\u3053\u3082\u306E",
      "\u3053\u3082\u3093",
      "\u3053\u3084\u304F",
      "\u3053\u3084\u307E",
      "\u3053\u3086\u3046",
      "\u3053\u3086\u3072\u3099",
      "\u3053\u3088\u3044",
      "\u3053\u3088\u3046",
      "\u3053\u308A\u308B",
      "\u3053\u308C\u304F\u3057\u3087\u3093",
      "\u3053\u308D\u3063\u3051",
      "\u3053\u308F\u3082\u3066",
      "\u3053\u308F\u308C\u308B",
      "\u3053\u3093\u3044\u3093",
      "\u3053\u3093\u304B\u3044",
      "\u3053\u3093\u304D",
      "\u3053\u3093\u3057\u3085\u3046",
      "\u3053\u3093\u3059\u3044",
      "\u3053\u3093\u305F\u3099\u3066",
      "\u3053\u3093\u3068\u3093",
      "\u3053\u3093\u306A\u3093",
      "\u3053\u3093\u3072\u3099\u306B",
      "\u3053\u3093\u307B\u309A\u3093",
      "\u3053\u3093\u307E\u3051",
      "\u3053\u3093\u3084",
      "\u3053\u3093\u308C\u3044",
      "\u3053\u3093\u308F\u304F",
      "\u3055\u3099\u3044\u3048\u304D",
      "\u3055\u3044\u304B\u3044",
      "\u3055\u3044\u304D\u3093",
      "\u3055\u3099\u3044\u3051\u3099\u3093",
      "\u3055\u3099\u3044\u3053",
      "\u3055\u3044\u3057\u3087",
      "\u3055\u3044\u305B\u3044",
      "\u3055\u3099\u3044\u305F\u304F",
      "\u3055\u3099\u3044\u3061\u3085\u3046",
      "\u3055\u3044\u3066\u304D",
      "\u3055\u3099\u3044\u308A\u3087\u3046",
      "\u3055\u3046\u306A",
      "\u3055\u304B\u3044\u3057",
      "\u3055\u304B\u3099\u3059",
      "\u3055\u304B\u306A",
      "\u3055\u304B\u307F\u3061",
      "\u3055\u304B\u3099\u308B",
      "\u3055\u304D\u3099\u3087\u3046",
      "\u3055\u304F\u3057",
      "\u3055\u304F\u3072\u3093",
      "\u3055\u304F\u3089",
      "\u3055\u3053\u304F",
      "\u3055\u3053\u3064",
      "\u3055\u3059\u3099\u304B\u308B",
      "\u3055\u3099\u305B\u304D",
      "\u3055\u305F\u3093",
      "\u3055\u3064\u3048\u3044",
      "\u3055\u3099\u3064\u304A\u3093",
      "\u3055\u3099\u3063\u304B",
      "\u3055\u3099\u3064\u304B\u3099\u304F",
      "\u3055\u3063\u304D\u3087\u304F",
      "\u3055\u3099\u3063\u3057",
      "\u3055\u3064\u3057\u3099\u3093",
      "\u3055\u3099\u3063\u305D\u3046",
      "\u3055\u3064\u305F\u306F\u3099",
      "\u3055\u3064\u307E\u3044\u3082",
      "\u3055\u3066\u3044",
      "\u3055\u3068\u3044\u3082",
      "\u3055\u3068\u3046",
      "\u3055\u3068\u304A\u3084",
      "\u3055\u3068\u3057",
      "\u3055\u3068\u308B",
      "\u3055\u306E\u3046",
      "\u3055\u306F\u3099\u304F",
      "\u3055\u3072\u3099\u3057\u3044",
      "\u3055\u3078\u3099\u3064",
      "\u3055\u307B\u3046",
      "\u3055\u307B\u3068\u3099",
      "\u3055\u307E\u3059",
      "\u3055\u307F\u3057\u3044",
      "\u3055\u307F\u305F\u3099\u308C",
      "\u3055\u3080\u3051",
      "\u3055\u3081\u308B",
      "\u3055\u3084\u3048\u3093\u3068\u3099\u3046",
      "\u3055\u3086\u3046",
      "\u3055\u3088\u3046",
      "\u3055\u3088\u304F",
      "\u3055\u3089\u305F\u3099",
      "\u3055\u3099\u308B\u305D\u306F\u3099",
      "\u3055\u308F\u3084\u304B",
      "\u3055\u308F\u308B",
      "\u3055\u3093\u3044\u3093",
      "\u3055\u3093\u304B",
      "\u3055\u3093\u304D\u3083\u304F",
      "\u3055\u3093\u3053\u3046",
      "\u3055\u3093\u3055\u3044",
      "\u3055\u3099\u3093\u3057\u3087",
      "\u3055\u3093\u3059\u3046",
      "\u3055\u3093\u305B\u3044",
      "\u3055\u3093\u305D",
      "\u3055\u3093\u3061",
      "\u3055\u3093\u307E",
      "\u3055\u3093\u307F",
      "\u3055\u3093\u3089\u3093",
      "\u3057\u3042\u3044",
      "\u3057\u3042\u3051\u3099",
      "\u3057\u3042\u3055\u3063\u3066",
      "\u3057\u3042\u308F\u305B",
      "\u3057\u3044\u304F",
      "\u3057\u3044\u3093",
      "\u3057\u3046\u3061",
      "\u3057\u3048\u3044",
      "\u3057\u304A\u3051",
      "\u3057\u304B\u3044",
      "\u3057\u304B\u304F",
      "\u3057\u3099\u304B\u3093",
      "\u3057\u3053\u3099\u3068",
      "\u3057\u3059\u3046",
      "\u3057\u3099\u305F\u3099\u3044",
      "\u3057\u305F\u3046\u3051",
      "\u3057\u305F\u304D\u3099",
      "\u3057\u305F\u3066",
      "\u3057\u305F\u307F",
      "\u3057\u3061\u3087\u3046",
      "\u3057\u3061\u308A\u3093",
      "\u3057\u3063\u304B\u308A",
      "\u3057\u3064\u3057\u3099",
      "\u3057\u3064\u3082\u3093",
      "\u3057\u3066\u3044",
      "\u3057\u3066\u304D",
      "\u3057\u3066\u3064",
      "\u3057\u3099\u3066\u3093",
      "\u3057\u3099\u3068\u3099\u3046",
      "\u3057\u306A\u304D\u3099\u308C",
      "\u3057\u306A\u3082\u306E",
      "\u3057\u306A\u3093",
      "\u3057\u306D\u307E",
      "\u3057\u306D\u3093",
      "\u3057\u306E\u304F\u3099",
      "\u3057\u306E\u3075\u3099",
      "\u3057\u306F\u3044",
      "\u3057\u306F\u3099\u304B\u308A",
      "\u3057\u306F\u3064",
      "\u3057\u306F\u3089\u3044",
      "\u3057\u306F\u3093",
      "\u3057\u3072\u3087\u3046",
      "\u3057\u3075\u304F",
      "\u3057\u3099\u3075\u3099\u3093",
      "\u3057\u3078\u3044",
      "\u3057\u307B\u3046",
      "\u3057\u307B\u3093",
      "\u3057\u307E\u3046",
      "\u3057\u307E\u308B",
      "\u3057\u307F\u3093",
      "\u3057\u3080\u3051\u308B",
      "\u3057\u3099\u3080\u3057\u3087",
      "\u3057\u3081\u3044",
      "\u3057\u3081\u308B",
      "\u3057\u3082\u3093",
      "\u3057\u3083\u3044\u3093",
      "\u3057\u3083\u3046\u3093",
      "\u3057\u3083\u304A\u3093",
      "\u3057\u3099\u3083\u304B\u3099\u3044\u3082",
      "\u3057\u3084\u304F\u3057\u3087",
      "\u3057\u3083\u304F\u307B\u3046",
      "\u3057\u3083\u3051\u3093",
      "\u3057\u3083\u3053",
      "\u3057\u3083\u3055\u3099\u3044",
      "\u3057\u3083\u3057\u3093",
      "\u3057\u3083\u305B\u3093",
      "\u3057\u3083\u305D\u3046",
      "\u3057\u3083\u305F\u3044",
      "\u3057\u3083\u3061\u3087\u3046",
      "\u3057\u3083\u3063\u304D\u3093",
      "\u3057\u3099\u3083\u307E",
      "\u3057\u3083\u308A\u3093",
      "\u3057\u3083\u308C\u3044",
      "\u3057\u3099\u3086\u3046",
      "\u3057\u3099\u3085\u3046\u3057\u3087",
      "\u3057\u3085\u304F\u306F\u304F",
      "\u3057\u3099\u3085\u3057\u3093",
      "\u3057\u3085\u3063\u305B\u304D",
      "\u3057\u3085\u307F",
      "\u3057\u3085\u3089\u306F\u3099",
      "\u3057\u3099\u3085\u3093\u306F\u3099\u3093",
      "\u3057\u3087\u3046\u304B\u3044",
      "\u3057\u3087\u304F\u305F\u304F",
      "\u3057\u3087\u3063\u3051\u3093",
      "\u3057\u3087\u3068\u3099\u3046",
      "\u3057\u3087\u3082\u3064",
      "\u3057\u3089\u305B\u308B",
      "\u3057\u3089\u3078\u3099\u308B",
      "\u3057\u3093\u304B",
      "\u3057\u3093\u3053\u3046",
      "\u3057\u3099\u3093\u3057\u3099\u3083",
      "\u3057\u3093\u305B\u3044\u3057\u3099",
      "\u3057\u3093\u3061\u304F",
      "\u3057\u3093\u308A\u3093",
      "\u3059\u3042\u3051\u3099",
      "\u3059\u3042\u3057",
      "\u3059\u3042\u306A",
      "\u3059\u3099\u3042\u3093",
      "\u3059\u3044\u3048\u3044",
      "\u3059\u3044\u304B",
      "\u3059\u3044\u3068\u3046",
      "\u3059\u3099\u3044\u3075\u3099\u3093",
      "\u3059\u3044\u3088\u3046\u3072\u3099",
      "\u3059\u3046\u304B\u3099\u304F",
      "\u3059\u3046\u3057\u3099\u3064",
      "\u3059\u3046\u305B\u3093",
      "\u3059\u304A\u3068\u3099\u308A",
      "\u3059\u304D\u307E",
      "\u3059\u304F\u3046",
      "\u3059\u304F\u306A\u3044",
      "\u3059\u3051\u308B",
      "\u3059\u3053\u3099\u3044",
      "\u3059\u3053\u3057",
      "\u3059\u3099\u3055\u3093",
      "\u3059\u3059\u3099\u3057\u3044",
      "\u3059\u3059\u3080",
      "\u3059\u3059\u3081\u308B",
      "\u3059\u3063\u304B\u308A",
      "\u3059\u3099\u3063\u3057\u308A",
      "\u3059\u3099\u3063\u3068",
      "\u3059\u3066\u304D",
      "\u3059\u3066\u308B",
      "\u3059\u306D\u308B",
      "\u3059\u306E\u3053",
      "\u3059\u306F\u305F\u3099",
      "\u3059\u306F\u3099\u3089\u3057\u3044",
      "\u3059\u3099\u3072\u3087\u3046",
      "\u3059\u3099\u3075\u3099\u306C\u308C",
      "\u3059\u3075\u3099\u308A",
      "\u3059\u3075\u308C",
      "\u3059\u3078\u3099\u3066",
      "\u3059\u3078\u3099\u308B",
      "\u3059\u3099\u307B\u3046",
      "\u3059\u307B\u3099\u3093",
      "\u3059\u307E\u3044",
      "\u3059\u3081\u3057",
      "\u3059\u3082\u3046",
      "\u3059\u3084\u304D",
      "\u3059\u3089\u3059\u3089",
      "\u3059\u308B\u3081",
      "\u3059\u308C\u3061\u304B\u3099\u3046",
      "\u3059\u308D\u3063\u3068",
      "\u3059\u308F\u308B",
      "\u3059\u3093\u305B\u3099\u3093",
      "\u3059\u3093\u307B\u309A\u3046",
      "\u305B\u3042\u3075\u3099\u3089",
      "\u305B\u3044\u304B\u3064",
      "\u305B\u3044\u3051\u3099\u3093",
      "\u305B\u3044\u3057\u3099",
      "\u305B\u3044\u3088\u3046",
      "\u305B\u304A\u3046",
      "\u305B\u304B\u3044\u304B\u3093",
      "\u305B\u304D\u306B\u3093",
      "\u305B\u304D\u3080",
      "\u305B\u304D\u3086",
      "\u305B\u304D\u3089\u3093\u3046\u3093",
      "\u305B\u3051\u3093",
      "\u305B\u3053\u3046",
      "\u305B\u3059\u3057\u3099",
      "\u305B\u305F\u3044",
      "\u305B\u305F\u3051",
      "\u305B\u3063\u304B\u304F",
      "\u305B\u3063\u304D\u3083\u304F",
      "\u305B\u3099\u3063\u304F",
      "\u305B\u3063\u3051\u3093",
      "\u305B\u3063\u3053\u3064",
      "\u305B\u3063\u3055\u305F\u304F\u307E",
      "\u305B\u3064\u305D\u3099\u304F",
      "\u305B\u3064\u305F\u3099\u3093",
      "\u305B\u3064\u3066\u3099\u3093",
      "\u305B\u3063\u306F\u309A\u3093",
      "\u305B\u3064\u3072\u3099",
      "\u305B\u3064\u3075\u3099\u3093",
      "\u305B\u3064\u3081\u3044",
      "\u305B\u3064\u308A\u3064",
      "\u305B\u306A\u304B",
      "\u305B\u306E\u3072\u3099",
      "\u305B\u306F\u306F\u3099",
      "\u305B\u3072\u3099\u308D",
      "\u305B\u307B\u3099\u306D",
      "\u305B\u307E\u3044",
      "\u305B\u307E\u308B",
      "\u305B\u3081\u308B",
      "\u305B\u3082\u305F\u308C",
      "\u305B\u308A\u3075",
      "\u305B\u3099\u3093\u3042\u304F",
      "\u305B\u3093\u3044",
      "\u305B\u3093\u3048\u3044",
      "\u305B\u3093\u304B",
      "\u305B\u3093\u304D\u3087",
      "\u305B\u3093\u304F",
      "\u305B\u3093\u3051\u3099\u3093",
      "\u305B\u3099\u3093\u3053\u3099",
      "\u305B\u3093\u3055\u3044",
      "\u305B\u3093\u3057\u3085",
      "\u305B\u3093\u3059\u3044",
      "\u305B\u3093\u305B\u3044",
      "\u305B\u3093\u305D\u3099",
      "\u305B\u3093\u305F\u304F",
      "\u305B\u3093\u3061\u3087\u3046",
      "\u305B\u3093\u3066\u3044",
      "\u305B\u3093\u3068\u3046",
      "\u305B\u3093\u306C\u304D",
      "\u305B\u3093\u306D\u3093",
      "\u305B\u3093\u306F\u309A\u3044",
      "\u305B\u3099\u3093\u3075\u3099",
      "\u305B\u3099\u3093\u307B\u309A\u3046",
      "\u305B\u3093\u3080",
      "\u305B\u3093\u3081\u3093\u3057\u3099\u3087",
      "\u305B\u3093\u3082\u3093",
      "\u305B\u3093\u3084\u304F",
      "\u305B\u3093\u3086\u3046",
      "\u305B\u3093\u3088\u3046",
      "\u305B\u3099\u3093\u3089",
      "\u305B\u3099\u3093\u308A\u3083\u304F",
      "\u305B\u3093\u308C\u3044",
      "\u305B\u3093\u308D",
      "\u305D\u3042\u304F",
      "\u305D\u3044\u3068\u3051\u3099\u308B",
      "\u305D\u3044\u306D",
      "\u305D\u3046\u304B\u3099\u3093\u304D\u3087\u3046",
      "\u305D\u3046\u304D",
      "\u305D\u3046\u3053\u3099",
      "\u305D\u3046\u3057\u3093",
      "\u305D\u3046\u305F\u3099\u3093",
      "\u305D\u3046\u306A\u3093",
      "\u305D\u3046\u3072\u3099",
      "\u305D\u3046\u3081\u3093",
      "\u305D\u3046\u308A",
      "\u305D\u3048\u3082\u306E",
      "\u305D\u3048\u3093",
      "\u305D\u304B\u3099\u3044",
      "\u305D\u3051\u3099\u304D",
      "\u305D\u3053\u3046",
      "\u305D\u3053\u305D\u3053",
      "\u305D\u3055\u3099\u3044",
      "\u305D\u3057\u306A",
      "\u305D\u305B\u3044",
      "\u305D\u305B\u3093",
      "\u305D\u305D\u304F\u3099",
      "\u305D\u305F\u3099\u3066\u308B",
      "\u305D\u3064\u3046",
      "\u305D\u3064\u3048\u3093",
      "\u305D\u3063\u304B\u3093",
      "\u305D\u3064\u304D\u3099\u3087\u3046",
      "\u305D\u3063\u3051\u3064",
      "\u305D\u3063\u3053\u3046",
      "\u305D\u3063\u305B\u3093",
      "\u305D\u3063\u3068",
      "\u305D\u3068\u304B\u3099\u308F",
      "\u305D\u3068\u3064\u3099\u3089",
      "\u305D\u306A\u3048\u308B",
      "\u305D\u306A\u305F",
      "\u305D\u3075\u307B\u3099",
      "\u305D\u307B\u3099\u304F",
      "\u305D\u307B\u3099\u308D",
      "\u305D\u307E\u3064",
      "\u305D\u307E\u308B",
      "\u305D\u3080\u304F",
      "\u305D\u3080\u308A\u3048",
      "\u305D\u3081\u308B",
      "\u305D\u3082\u305D\u3082",
      "\u305D\u3088\u304B\u305B\u3099",
      "\u305D\u3089\u307E\u3081",
      "\u305D\u308D\u3046",
      "\u305D\u3093\u304B\u3044",
      "\u305D\u3093\u3051\u3044",
      "\u305D\u3093\u3055\u3099\u3044",
      "\u305D\u3093\u3057\u3064",
      "\u305D\u3093\u305D\u3099\u304F",
      "\u305D\u3093\u3061\u3087\u3046",
      "\u305D\u3099\u3093\u3072\u3099",
      "\u305D\u3099\u3093\u3075\u3099\u3093",
      "\u305D\u3093\u307F\u3093",
      "\u305F\u3042\u3044",
      "\u305F\u3044\u3044\u3093",
      "\u305F\u3044\u3046\u3093",
      "\u305F\u3044\u3048\u304D",
      "\u305F\u3044\u304A\u3046",
      "\u305F\u3099\u3044\u304B\u3099\u304F",
      "\u305F\u3044\u304D",
      "\u305F\u3044\u304F\u3099\u3046",
      "\u305F\u3044\u3051\u3093",
      "\u305F\u3044\u3053",
      "\u305F\u3044\u3055\u3099\u3044",
      "\u305F\u3099\u3044\u3057\u3099\u3087\u3046\u3075\u3099",
      "\u305F\u3099\u3044\u3059\u304D",
      "\u305F\u3044\u305B\u3064",
      "\u305F\u3044\u305D\u3046",
      "\u305F\u3099\u3044\u305F\u3044",
      "\u305F\u3044\u3061\u3087\u3046",
      "\u305F\u3044\u3066\u3044",
      "\u305F\u3099\u3044\u3068\u3099\u3053\u308D",
      "\u305F\u3044\u306A\u3044",
      "\u305F\u3044\u306D\u3064",
      "\u305F\u3044\u306E\u3046",
      "\u305F\u3044\u306F\u3093",
      "\u305F\u3099\u3044\u3072\u3087\u3046",
      "\u305F\u3044\u3075\u3046",
      "\u305F\u3044\u3078\u3093",
      "\u305F\u3044\u307B",
      "\u305F\u3044\u307E\u3064\u306F\u3099\u306A",
      "\u305F\u3044\u307F\u3093\u304F\u3099",
      "\u305F\u3044\u3080",
      "\u305F\u3044\u3081\u3093",
      "\u305F\u3044\u3084\u304D",
      "\u305F\u3044\u3088\u3046",
      "\u305F\u3044\u3089",
      "\u305F\u3044\u308A\u3087\u304F",
      "\u305F\u3044\u308B",
      "\u305F\u3044\u308F\u3093",
      "\u305F\u3046\u3048",
      "\u305F\u3048\u308B",
      "\u305F\u304A\u3059",
      "\u305F\u304A\u308B",
      "\u305F\u304A\u308C\u308B",
      "\u305F\u304B\u3044",
      "\u305F\u304B\u306D",
      "\u305F\u304D\u3072\u3099",
      "\u305F\u304F\u3055\u3093",
      "\u305F\u3053\u304F",
      "\u305F\u3053\u3084\u304D",
      "\u305F\u3055\u3044",
      "\u305F\u3057\u3055\u3099\u3093",
      "\u305F\u3099\u3057\u3099\u3083\u308C",
      "\u305F\u3059\u3051\u308B",
      "\u305F\u3059\u3099\u3055\u308F\u308B",
      "\u305F\u305D\u304B\u3099\u308C",
      "\u305F\u305F\u304B\u3046",
      "\u305F\u305F\u304F",
      "\u305F\u305F\u3099\u3057\u3044",
      "\u305F\u305F\u307F",
      "\u305F\u3061\u306F\u3099\u306A",
      "\u305F\u3099\u3063\u304B\u3044",
      "\u305F\u3099\u3063\u304D\u3083\u304F",
      "\u305F\u3099\u3063\u3053",
      "\u305F\u3099\u3063\u3057\u3085\u3064",
      "\u305F\u3099\u3063\u305F\u3044",
      "\u305F\u3066\u308B",
      "\u305F\u3068\u3048\u308B",
      "\u305F\u306A\u306F\u3099\u305F",
      "\u305F\u306B\u3093",
      "\u305F\u306C\u304D",
      "\u305F\u306E\u3057\u307F",
      "\u305F\u306F\u3064",
      "\u305F\u3075\u3099\u3093",
      "\u305F\u3078\u3099\u308B",
      "\u305F\u307B\u3099\u3046",
      "\u305F\u307E\u3053\u3099",
      "\u305F\u307E\u308B",
      "\u305F\u3099\u3080\u308B",
      "\u305F\u3081\u3044\u304D",
      "\u305F\u3081\u3059",
      "\u305F\u3081\u308B",
      "\u305F\u3082\u3064",
      "\u305F\u3084\u3059\u3044",
      "\u305F\u3088\u308B",
      "\u305F\u3089\u3059",
      "\u305F\u308A\u304D\u307B\u3093\u304B\u3099\u3093",
      "\u305F\u308A\u3087\u3046",
      "\u305F\u308A\u308B",
      "\u305F\u308B\u3068",
      "\u305F\u308C\u308B",
      "\u305F\u308C\u3093\u3068",
      "\u305F\u308D\u3063\u3068",
      "\u305F\u308F\u3080\u308C\u308B",
      "\u305F\u3099\u3093\u3042\u3064",
      "\u305F\u3093\u3044",
      "\u305F\u3093\u304A\u3093",
      "\u305F\u3093\u304B",
      "\u305F\u3093\u304D",
      "\u305F\u3093\u3051\u3093",
      "\u305F\u3093\u3053\u3099",
      "\u305F\u3093\u3055\u3093",
      "\u305F\u3093\u3057\u3099\u3087\u3046\u3072\u3099",
      "\u305F\u3099\u3093\u305B\u3044",
      "\u305F\u3093\u305D\u304F",
      "\u305F\u3093\u305F\u3044",
      "\u305F\u3099\u3093\u3061",
      "\u305F\u3093\u3066\u3044",
      "\u305F\u3093\u3068\u3046",
      "\u305F\u3099\u3093\u306A",
      "\u305F\u3093\u306B\u3093",
      "\u305F\u3099\u3093\u306D\u3064",
      "\u305F\u3093\u306E\u3046",
      "\u305F\u3093\u3072\u309A\u3093",
      "\u305F\u3099\u3093\u307B\u3099\u3046",
      "\u305F\u3093\u307E\u3064",
      "\u305F\u3093\u3081\u3044",
      "\u305F\u3099\u3093\u308C\u3064",
      "\u305F\u3099\u3093\u308D",
      "\u305F\u3099\u3093\u308F",
      "\u3061\u3042\u3044",
      "\u3061\u3042\u3093",
      "\u3061\u3044\u304D",
      "\u3061\u3044\u3055\u3044",
      "\u3061\u3048\u3093",
      "\u3061\u304B\u3044",
      "\u3061\u304B\u3089",
      "\u3061\u304D\u3085\u3046",
      "\u3061\u304D\u3093",
      "\u3061\u3051\u3044\u3059\u3099",
      "\u3061\u3051\u3093",
      "\u3061\u3053\u304F",
      "\u3061\u3055\u3044",
      "\u3061\u3057\u304D",
      "\u3061\u3057\u308A\u3087\u3046",
      "\u3061\u305B\u3044",
      "\u3061\u305D\u3046",
      "\u3061\u305F\u3044",
      "\u3061\u305F\u3093",
      "\u3061\u3061\u304A\u3084",
      "\u3061\u3064\u3057\u3099\u3087",
      "\u3061\u3066\u304D",
      "\u3061\u3066\u3093",
      "\u3061\u306C\u304D",
      "\u3061\u306C\u308A",
      "\u3061\u306E\u3046",
      "\u3061\u3072\u3087\u3046",
      "\u3061\u3078\u3044\u305B\u3093",
      "\u3061\u307B\u3046",
      "\u3061\u307E\u305F",
      "\u3061\u307F\u3064",
      "\u3061\u307F\u3068\u3099\u308D",
      "\u3061\u3081\u3044\u3068\u3099",
      "\u3061\u3083\u3093\u3053\u306A\u3078\u3099",
      "\u3061\u3085\u3046\u3044",
      "\u3061\u3086\u308A\u3087\u304F",
      "\u3061\u3087\u3046\u3057",
      "\u3061\u3087\u3055\u304F\u3051\u3093",
      "\u3061\u3089\u3057",
      "\u3061\u3089\u307F",
      "\u3061\u308A\u304B\u3099\u307F",
      "\u3061\u308A\u3087\u3046",
      "\u3061\u308B\u3068\u3099",
      "\u3061\u308F\u308F",
      "\u3061\u3093\u305F\u3044",
      "\u3061\u3093\u3082\u304F",
      "\u3064\u3044\u304B",
      "\u3064\u3044\u305F\u3061",
      "\u3064\u3046\u304B",
      "\u3064\u3046\u3057\u3099\u3087\u3046",
      "\u3064\u3046\u306F\u3093",
      "\u3064\u3046\u308F",
      "\u3064\u304B\u3046",
      "\u3064\u304B\u308C\u308B",
      "\u3064\u304F\u306D",
      "\u3064\u304F\u308B",
      "\u3064\u3051\u306D",
      "\u3064\u3051\u308B",
      "\u3064\u3053\u3099\u3046",
      "\u3064\u305F\u3048\u308B",
      "\u3064\u3064\u3099\u304F",
      "\u3064\u3064\u3057\u3099",
      "\u3064\u3064\u3080",
      "\u3064\u3068\u3081\u308B",
      "\u3064\u306A\u304B\u3099\u308B",
      "\u3064\u306A\u307F",
      "\u3064\u306D\u3064\u3099\u306D",
      "\u3064\u306E\u308B",
      "\u3064\u3075\u3099\u3059",
      "\u3064\u307E\u3089\u306A\u3044",
      "\u3064\u307E\u308B",
      "\u3064\u307F\u304D",
      "\u3064\u3081\u305F\u3044",
      "\u3064\u3082\u308A",
      "\u3064\u3082\u308B",
      "\u3064\u3088\u3044",
      "\u3064\u308B\u307B\u3099",
      "\u3064\u308B\u307F\u304F",
      "\u3064\u308F\u3082\u306E",
      "\u3064\u308F\u308A",
      "\u3066\u3042\u3057",
      "\u3066\u3042\u3066",
      "\u3066\u3042\u307F",
      "\u3066\u3044\u304A\u3093",
      "\u3066\u3044\u304B",
      "\u3066\u3044\u304D",
      "\u3066\u3044\u3051\u3044",
      "\u3066\u3044\u3053\u304F",
      "\u3066\u3044\u3055\u3064",
      "\u3066\u3044\u3057",
      "\u3066\u3044\u305B\u3044",
      "\u3066\u3044\u305F\u3044",
      "\u3066\u3044\u3068\u3099",
      "\u3066\u3044\u306D\u3044",
      "\u3066\u3044\u3072\u3087\u3046",
      "\u3066\u3044\u3078\u3093",
      "\u3066\u3044\u307B\u3099\u3046",
      "\u3066\u3046\u3061",
      "\u3066\u304A\u304F\u308C",
      "\u3066\u304D\u3068\u3046",
      "\u3066\u304F\u3072\u3099",
      "\u3066\u3099\u3053\u307B\u3099\u3053",
      "\u3066\u3055\u304D\u3099\u3087\u3046",
      "\u3066\u3055\u3051\u3099",
      "\u3066\u3059\u308A",
      "\u3066\u305D\u3046",
      "\u3066\u3061\u304B\u3099\u3044",
      "\u3066\u3061\u3087\u3046",
      "\u3066\u3064\u304B\u3099\u304F",
      "\u3066\u3064\u3064\u3099\u304D",
      "\u3066\u3099\u3063\u306F\u309A",
      "\u3066\u3064\u307B\u3099\u3046",
      "\u3066\u3064\u3084",
      "\u3066\u3099\u306C\u304B\u3048",
      "\u3066\u306C\u304D",
      "\u3066\u306C\u304F\u3099\u3044",
      "\u3066\u306E\u3072\u3089",
      "\u3066\u306F\u3044",
      "\u3066\u3075\u3099\u304F\u308D",
      "\u3066\u3075\u305F\u3099",
      "\u3066\u307B\u3068\u3099\u304D",
      "\u3066\u307B\u3093",
      "\u3066\u307E\u3048",
      "\u3066\u307E\u304D\u3059\u3099\u3057",
      "\u3066\u307F\u3057\u3099\u304B",
      "\u3066\u307F\u3084\u3051\u3099",
      "\u3066\u3089\u3059",
      "\u3066\u308C\u3072\u3099",
      "\u3066\u308F\u3051",
      "\u3066\u308F\u305F\u3057",
      "\u3066\u3099\u3093\u3042\u3064",
      "\u3066\u3093\u3044\u3093",
      "\u3066\u3093\u304B\u3044",
      "\u3066\u3093\u304D",
      "\u3066\u3093\u304F\u3099",
      "\u3066\u3093\u3051\u3093",
      "\u3066\u3093\u3053\u3099\u304F",
      "\u3066\u3093\u3055\u3044",
      "\u3066\u3093\u3057",
      "\u3066\u3093\u3059\u3046",
      "\u3066\u3099\u3093\u3061",
      "\u3066\u3093\u3066\u304D",
      "\u3066\u3093\u3068\u3046",
      "\u3066\u3093\u306A\u3044",
      "\u3066\u3093\u3075\u309A\u3089",
      "\u3066\u3093\u307B\u3099\u3046\u305F\u3099\u3044",
      "\u3066\u3093\u3081\u3064",
      "\u3066\u3093\u3089\u3093\u304B\u3044",
      "\u3066\u3099\u3093\u308A\u3087\u304F",
      "\u3066\u3099\u3093\u308F",
      "\u3068\u3099\u3042\u3044",
      "\u3068\u3044\u308C",
      "\u3068\u3099\u3046\u304B\u3093",
      "\u3068\u3046\u304D\u3085\u3046",
      "\u3068\u3099\u3046\u304F\u3099",
      "\u3068\u3046\u3057",
      "\u3068\u3046\u3080\u304D\u3099",
      "\u3068\u304A\u3044",
      "\u3068\u304A\u304B",
      "\u3068\u304A\u304F",
      "\u3068\u304A\u3059",
      "\u3068\u304A\u308B",
      "\u3068\u304B\u3044",
      "\u3068\u304B\u3059",
      "\u3068\u304D\u304A\u308A",
      "\u3068\u304D\u3068\u3099\u304D",
      "\u3068\u304F\u3044",
      "\u3068\u304F\u3057\u3085\u3046",
      "\u3068\u304F\u3066\u3093",
      "\u3068\u304F\u306B",
      "\u3068\u304F\u3078\u3099\u3064",
      "\u3068\u3051\u3044",
      "\u3068\u3051\u308B",
      "\u3068\u3053\u3084",
      "\u3068\u3055\u304B",
      "\u3068\u3057\u3087\u304B\u3093",
      "\u3068\u305D\u3046",
      "\u3068\u305F\u3093",
      "\u3068\u3061\u3085\u3046",
      "\u3068\u3063\u304D\u3085\u3046",
      "\u3068\u3063\u304F\u3093",
      "\u3068\u3064\u305B\u3099\u3093",
      "\u3068\u3064\u306B\u3085\u3046",
      "\u3068\u3068\u3099\u3051\u308B",
      "\u3068\u3068\u306E\u3048\u308B",
      "\u3068\u306A\u3044",
      "\u3068\u306A\u3048\u308B",
      "\u3068\u306A\u308A",
      "\u3068\u306E\u3055\u307E",
      "\u3068\u306F\u3099\u3059",
      "\u3068\u3099\u3075\u3099\u304B\u3099\u308F",
      "\u3068\u307B\u3046",
      "\u3068\u307E\u308B",
      "\u3068\u3081\u308B",
      "\u3068\u3082\u305F\u3099\u3061",
      "\u3068\u3082\u308B",
      "\u3068\u3099\u3088\u3046\u3072\u3099",
      "\u3068\u3089\u3048\u308B",
      "\u3068\u3093\u304B\u3064",
      "\u3068\u3099\u3093\u3075\u3099\u308A",
      "\u306A\u3044\u304B\u304F",
      "\u306A\u3044\u3053\u3046",
      "\u306A\u3044\u3057\u3087",
      "\u306A\u3044\u3059",
      "\u306A\u3044\u305B\u3093",
      "\u306A\u3044\u305D\u3046",
      "\u306A\u304A\u3059",
      "\u306A\u304B\u3099\u3044",
      "\u306A\u304F\u3059",
      "\u306A\u3051\u3099\u308B",
      "\u306A\u3053\u3046\u3068\u3099",
      "\u306A\u3055\u3051",
      "\u306A\u305F\u3066\u3099\u3053\u3053",
      "\u306A\u3063\u3068\u3046",
      "\u306A\u3064\u3084\u3059\u307F",
      "\u306A\u306A\u304A\u3057",
      "\u306A\u306B\u3053\u3099\u3068",
      "\u306A\u306B\u3082\u306E",
      "\u306A\u306B\u308F",
      "\u306A\u306E\u304B",
      "\u306A\u3075\u305F\u3099",
      "\u306A\u307E\u3044\u304D",
      "\u306A\u307E\u3048",
      "\u306A\u307E\u307F",
      "\u306A\u307F\u305F\u3099",
      "\u306A\u3081\u3089\u304B",
      "\u306A\u3081\u308B",
      "\u306A\u3084\u3080",
      "\u306A\u3089\u3046",
      "\u306A\u3089\u3072\u3099",
      "\u306A\u3089\u3075\u3099",
      "\u306A\u308C\u308B",
      "\u306A\u308F\u3068\u3072\u3099",
      "\u306A\u308F\u306F\u3099\u308A",
      "\u306B\u3042\u3046",
      "\u306B\u3044\u304B\u3099\u305F",
      "\u306B\u3046\u3051",
      "\u306B\u304A\u3044",
      "\u306B\u304B\u3044",
      "\u306B\u304B\u3099\u3066",
      "\u306B\u304D\u3072\u3099",
      "\u306B\u304F\u3057\u307F",
      "\u306B\u304F\u307E\u3093",
      "\u306B\u3051\u3099\u308B",
      "\u306B\u3055\u3093\u304B\u305F\u3093\u305D",
      "\u306B\u3057\u304D",
      "\u306B\u305B\u3082\u306E",
      "\u306B\u3061\u3057\u3099\u3087\u3046",
      "\u306B\u3061\u3088\u3046\u3072\u3099",
      "\u306B\u3063\u304B",
      "\u306B\u3063\u304D",
      "\u306B\u3063\u3051\u3044",
      "\u306B\u3063\u3053\u3046",
      "\u306B\u3063\u3055\u3093",
      "\u306B\u3063\u3057\u3087\u304F",
      "\u306B\u3063\u3059\u3046",
      "\u306B\u3063\u305B\u304D",
      "\u306B\u3063\u3066\u3044",
      "\u306B\u306A\u3046",
      "\u306B\u307B\u3093",
      "\u306B\u307E\u3081",
      "\u306B\u3082\u3064",
      "\u306B\u3084\u308A",
      "\u306B\u3085\u3046\u3044\u3093",
      "\u306B\u308A\u3093\u3057\u3083",
      "\u306B\u308F\u3068\u308A",
      "\u306B\u3093\u3044",
      "\u306B\u3093\u304B",
      "\u306B\u3093\u304D",
      "\u306B\u3093\u3051\u3099\u3093",
      "\u306B\u3093\u3057\u304D",
      "\u306B\u3093\u3059\u3099\u3046",
      "\u306B\u3093\u305D\u3046",
      "\u306B\u3093\u305F\u3044",
      "\u306B\u3093\u3061",
      "\u306B\u3093\u3066\u3044",
      "\u306B\u3093\u306B\u304F",
      "\u306B\u3093\u3075\u309A",
      "\u306B\u3093\u307E\u308A",
      "\u306B\u3093\u3080",
      "\u306B\u3093\u3081\u3044",
      "\u306B\u3093\u3088\u3046",
      "\u306C\u3044\u304F\u304D\u3099",
      "\u306C\u304B\u3059",
      "\u306C\u304F\u3099\u3044\u3068\u308B",
      "\u306C\u304F\u3099\u3046",
      "\u306C\u304F\u3082\u308A",
      "\u306C\u3059\u3080",
      "\u306C\u307E\u3048\u3072\u3099",
      "\u306C\u3081\u308A",
      "\u306C\u3089\u3059",
      "\u306C\u3093\u3061\u3083\u304F",
      "\u306D\u3042\u3051\u3099",
      "\u306D\u3044\u304D",
      "\u306D\u3044\u308B",
      "\u306D\u3044\u308D",
      "\u306D\u304F\u3099\u305B",
      "\u306D\u304F\u305F\u3044",
      "\u306D\u304F\u3089",
      "\u306D\u3053\u305B\u3099",
      "\u306D\u3053\u3080",
      "\u306D\u3055\u3051\u3099",
      "\u306D\u3059\u3053\u3099\u3059",
      "\u306D\u305D\u3078\u3099\u308B",
      "\u306D\u305F\u3099\u3093",
      "\u306D\u3064\u3044",
      "\u306D\u3063\u3057\u3093",
      "\u306D\u3064\u305D\u3099\u3046",
      "\u306D\u3063\u305F\u3044\u304D\u3099\u3087",
      "\u306D\u3075\u3099\u305D\u304F",
      "\u306D\u3075\u305F\u3099",
      "\u306D\u307B\u3099\u3046",
      "\u306D\u307B\u308A\u306F\u307B\u308A",
      "\u306D\u307E\u304D",
      "\u306D\u307E\u308F\u3057",
      "\u306D\u307F\u307F",
      "\u306D\u3080\u3044",
      "\u306D\u3080\u305F\u3044",
      "\u306D\u3082\u3068",
      "\u306D\u3089\u3046",
      "\u306D\u308F\u3055\u3099",
      "\u306D\u3093\u3044\u308A",
      "\u306D\u3093\u304A\u3057",
      "\u306D\u3093\u304B\u3093",
      "\u306D\u3093\u304D\u3093",
      "\u306D\u3093\u304F\u3099",
      "\u306D\u3093\u3055\u3099",
      "\u306D\u3093\u3057",
      "\u306D\u3093\u3061\u3083\u304F",
      "\u306D\u3093\u3068\u3099",
      "\u306D\u3093\u3072\u309A",
      "\u306D\u3093\u3075\u3099\u3064",
      "\u306D\u3093\u307E\u3064",
      "\u306D\u3093\u308A\u3087\u3046",
      "\u306D\u3093\u308C\u3044",
      "\u306E\u3044\u3059\u3099",
      "\u306E\u304A\u3064\u3099\u307E",
      "\u306E\u304B\u3099\u3059",
      "\u306E\u304D\u306A\u307F",
      "\u306E\u3053\u304D\u3099\u308A",
      "\u306E\u3053\u3059",
      "\u306E\u3053\u308B",
      "\u306E\u305B\u308B",
      "\u306E\u305D\u3099\u304F",
      "\u306E\u305D\u3099\u3080",
      "\u306E\u305F\u307E\u3046",
      "\u306E\u3061\u307B\u3068\u3099",
      "\u306E\u3063\u304F",
      "\u306E\u306F\u3099\u3059",
      "\u306E\u306F\u3089",
      "\u306E\u3078\u3099\u308B",
      "\u306E\u307B\u3099\u308B",
      "\u306E\u307F\u3082\u306E",
      "\u306E\u3084\u307E",
      "\u306E\u3089\u3044\u306C",
      "\u306E\u3089\u306D\u3053",
      "\u306E\u308A\u3082\u306E",
      "\u306E\u308A\u3086\u304D",
      "\u306E\u308C\u3093",
      "\u306E\u3093\u304D",
      "\u306F\u3099\u3042\u3044",
      "\u306F\u3042\u304F",
      "\u306F\u3099\u3042\u3055\u3093",
      "\u306F\u3099\u3044\u304B",
      "\u306F\u3099\u3044\u304F",
      "\u306F\u3044\u3051\u3093",
      "\u306F\u3044\u3053\u3099",
      "\u306F\u3044\u3057\u3093",
      "\u306F\u3044\u3059\u3044",
      "\u306F\u3044\u305B\u3093",
      "\u306F\u3044\u305D\u3046",
      "\u306F\u3044\u3061",
      "\u306F\u3099\u3044\u306F\u3099\u3044",
      "\u306F\u3044\u308C\u3064",
      "\u306F\u3048\u308B",
      "\u306F\u304A\u308B",
      "\u306F\u304B\u3044",
      "\u306F\u3099\u304B\u308A",
      "\u306F\u304B\u308B",
      "\u306F\u304F\u3057\u3085",
      "\u306F\u3051\u3093",
      "\u306F\u3053\u3075\u3099",
      "\u306F\u3055\u307F",
      "\u306F\u3055\u3093",
      "\u306F\u3057\u3053\u3099",
      "\u306F\u3099\u3057\u3087",
      "\u306F\u3057\u308B",
      "\u306F\u305B\u308B",
      "\u306F\u309A\u305D\u3053\u3093",
      "\u306F\u305D\u3093",
      "\u306F\u305F\u3093",
      "\u306F\u3061\u307F\u3064",
      "\u306F\u3064\u304A\u3093",
      "\u306F\u3063\u304B\u304F",
      "\u306F\u3064\u3099\u304D",
      "\u306F\u3063\u304D\u308A",
      "\u306F\u3063\u304F\u3064",
      "\u306F\u3063\u3051\u3093",
      "\u306F\u3063\u3053\u3046",
      "\u306F\u3063\u3055\u3093",
      "\u306F\u3063\u3057\u3093",
      "\u306F\u3063\u305F\u3064",
      "\u306F\u3063\u3061\u3085\u3046",
      "\u306F\u3063\u3066\u3093",
      "\u306F\u3063\u3072\u309A\u3087\u3046",
      "\u306F\u3063\u307B\u309A\u3046",
      "\u306F\u306A\u3059",
      "\u306F\u306A\u3072\u3099",
      "\u306F\u306B\u304B\u3080",
      "\u306F\u3075\u3099\u3089\u3057",
      "\u306F\u307F\u304B\u3099\u304D",
      "\u306F\u3080\u304B\u3046",
      "\u306F\u3081\u3064",
      "\u306F\u3084\u3044",
      "\u306F\u3084\u3057",
      "\u306F\u3089\u3046",
      "\u306F\u308D\u3046\u3043\u3093",
      "\u306F\u308F\u3044",
      "\u306F\u3093\u3044",
      "\u306F\u3093\u3048\u3044",
      "\u306F\u3093\u304A\u3093",
      "\u306F\u3093\u304B\u304F",
      "\u306F\u3093\u304D\u3087\u3046",
      "\u306F\u3099\u3093\u304F\u3099\u307F",
      "\u306F\u3093\u3053",
      "\u306F\u3093\u3057\u3083",
      "\u306F\u3093\u3059\u3046",
      "\u306F\u3093\u305F\u3099\u3093",
      "\u306F\u309A\u3093\u3061",
      "\u306F\u309A\u3093\u3064",
      "\u306F\u3093\u3066\u3044",
      "\u306F\u3093\u3068\u3057",
      "\u306F\u3093\u306E\u3046",
      "\u306F\u3093\u306F\u309A",
      "\u306F\u3093\u3075\u3099\u3093",
      "\u306F\u3093\u3078\u309A\u3093",
      "\u306F\u3093\u307B\u3099\u3046\u304D",
      "\u306F\u3093\u3081\u3044",
      "\u306F\u3093\u3089\u3093",
      "\u306F\u3093\u308D\u3093",
      "\u3072\u3044\u304D",
      "\u3072\u3046\u3093",
      "\u3072\u3048\u308B",
      "\u3072\u304B\u304F",
      "\u3072\u304B\u308A",
      "\u3072\u304B\u308B",
      "\u3072\u304B\u3093",
      "\u3072\u304F\u3044",
      "\u3072\u3051\u3064",
      "\u3072\u3053\u3046\u304D",
      "\u3072\u3053\u304F",
      "\u3072\u3055\u3044",
      "\u3072\u3055\u3057\u3075\u3099\u308A",
      "\u3072\u3055\u3093",
      "\u3072\u3099\u3057\u3099\u3085\u3064\u304B\u3093",
      "\u3072\u3057\u3087",
      "\u3072\u305D\u304B",
      "\u3072\u305D\u3080",
      "\u3072\u305F\u3080\u304D",
      "\u3072\u305F\u3099\u308A",
      "\u3072\u305F\u308B",
      "\u3072\u3064\u304D\u3099",
      "\u3072\u3063\u3053\u3057",
      "\u3072\u3063\u3057",
      "\u3072\u3064\u3057\u3099\u3085\u3072\u3093",
      "\u3072\u3063\u3059",
      "\u3072\u3064\u305B\u3099\u3093",
      "\u3072\u309A\u3063\u305F\u308A",
      "\u3072\u309A\u3063\u3061\u308A",
      "\u3072\u3064\u3088\u3046",
      "\u3072\u3066\u3044",
      "\u3072\u3068\u3053\u3099\u307F",
      "\u3072\u306A\u307E\u3064\u308A",
      "\u3072\u306A\u3093",
      "\u3072\u306D\u308B",
      "\u3072\u306F\u3093",
      "\u3072\u3072\u3099\u304F",
      "\u3072\u3072\u3087\u3046",
      "\u3072\u307B\u3046",
      "\u3072\u307E\u308F\u308A",
      "\u3072\u307E\u3093",
      "\u3072\u307F\u3064",
      "\u3072\u3081\u3044",
      "\u3072\u3081\u3057\u3099\u3057",
      "\u3072\u3084\u3051",
      "\u3072\u3084\u3059",
      "\u3072\u3088\u3046",
      "\u3072\u3099\u3087\u3046\u304D",
      "\u3072\u3089\u304B\u3099\u306A",
      "\u3072\u3089\u304F",
      "\u3072\u308A\u3064",
      "\u3072\u308A\u3087\u3046",
      "\u3072\u308B\u307E",
      "\u3072\u308B\u3084\u3059\u307F",
      "\u3072\u308C\u3044",
      "\u3072\u308D\u3044",
      "\u3072\u308D\u3046",
      "\u3072\u308D\u304D",
      "\u3072\u308D\u3086\u304D",
      "\u3072\u3093\u304B\u304F",
      "\u3072\u3093\u3051\u3064",
      "\u3072\u3093\u3053\u3093",
      "\u3072\u3093\u3057\u3085",
      "\u3072\u3093\u305D\u3046",
      "\u3072\u309A\u3093\u3061",
      "\u3072\u3093\u306F\u309A\u3093",
      "\u3072\u3099\u3093\u307B\u3099\u3046",
      "\u3075\u3042\u3093",
      "\u3075\u3044\u3046\u3061",
      "\u3075\u3046\u3051\u3044",
      "\u3075\u3046\u305B\u3093",
      "\u3075\u309A\u3046\u305F\u308D\u3046",
      "\u3075\u3046\u3068\u3046",
      "\u3075\u3046\u3075",
      "\u3075\u3048\u308B",
      "\u3075\u304A\u3093",
      "\u3075\u304B\u3044",
      "\u3075\u304D\u3093",
      "\u3075\u304F\u3055\u3099\u3064",
      "\u3075\u304F\u3075\u3099\u304F\u308D",
      "\u3075\u3053\u3046",
      "\u3075\u3055\u3044",
      "\u3075\u3057\u304D\u3099",
      "\u3075\u3057\u3099\u307F",
      "\u3075\u3059\u307E",
      "\u3075\u305B\u3044",
      "\u3075\u305B\u304F\u3099",
      "\u3075\u305D\u304F",
      "\u3075\u3099\u305F\u306B\u304F",
      "\u3075\u305F\u3093",
      "\u3075\u3061\u3087\u3046",
      "\u3075\u3064\u3046",
      "\u3075\u3064\u304B",
      "\u3075\u3063\u304B\u3064",
      "\u3075\u3063\u304D",
      "\u3075\u3063\u3053\u304F",
      "\u3075\u3099\u3068\u3099\u3046",
      "\u3075\u3068\u308B",
      "\u3075\u3068\u3093",
      "\u3075\u306E\u3046",
      "\u3075\u306F\u3044",
      "\u3075\u3072\u3087\u3046",
      "\u3075\u3078\u3093",
      "\u3075\u307E\u3093",
      "\u3075\u307F\u3093",
      "\u3075\u3081\u3064",
      "\u3075\u3081\u3093",
      "\u3075\u3088\u3046",
      "\u3075\u308A\u3053",
      "\u3075\u308A\u308B",
      "\u3075\u308B\u3044",
      "\u3075\u3093\u3044\u304D",
      "\u3075\u3099\u3093\u304B\u3099\u304F",
      "\u3075\u3099\u3093\u304F\u3099",
      "\u3075\u3093\u3057\u3064",
      "\u3075\u3099\u3093\u305B\u304D",
      "\u3075\u3093\u305D\u3046",
      "\u3075\u3099\u3093\u307B\u309A\u3046",
      "\u3078\u3044\u3042\u3093",
      "\u3078\u3044\u304A\u3093",
      "\u3078\u3044\u304B\u3099\u3044",
      "\u3078\u3044\u304D",
      "\u3078\u3044\u3051\u3099\u3093",
      "\u3078\u3044\u3053\u3046",
      "\u3078\u3044\u3055",
      "\u3078\u3044\u3057\u3083",
      "\u3078\u3044\u305B\u3064",
      "\u3078\u3044\u305D",
      "\u3078\u3044\u305F\u304F",
      "\u3078\u3044\u3066\u3093",
      "\u3078\u3044\u306D\u3064",
      "\u3078\u3044\u308F",
      "\u3078\u304D\u304B\u3099",
      "\u3078\u3053\u3080",
      "\u3078\u3099\u306B\u3044\u308D",
      "\u3078\u3099\u306B\u3057\u3087\u3046\u304B\u3099",
      "\u3078\u3089\u3059",
      "\u3078\u3093\u304B\u3093",
      "\u3078\u3099\u3093\u304D\u3087\u3046",
      "\u3078\u3099\u3093\u3053\u3099\u3057",
      "\u3078\u3093\u3055\u3044",
      "\u3078\u3093\u305F\u3044",
      "\u3078\u3099\u3093\u308A",
      "\u307B\u3042\u3093",
      "\u307B\u3044\u304F",
      "\u307B\u3099\u3046\u304D\u3099\u3087",
      "\u307B\u3046\u3053\u304F",
      "\u307B\u3046\u305D\u3046",
      "\u307B\u3046\u307B\u3046",
      "\u307B\u3046\u3082\u3093",
      "\u307B\u3046\u308A\u3064",
      "\u307B\u3048\u308B",
      "\u307B\u304A\u3093",
      "\u307B\u304B\u3093",
      "\u307B\u304D\u3087\u3046",
      "\u307B\u3099\u304D\u3093",
      "\u307B\u304F\u308D",
      "\u307B\u3051\u3064",
      "\u307B\u3051\u3093",
      "\u307B\u3053\u3046",
      "\u307B\u3053\u308B",
      "\u307B\u3057\u3044",
      "\u307B\u3057\u3064",
      "\u307B\u3057\u3085",
      "\u307B\u3057\u3087\u3046",
      "\u307B\u305B\u3044",
      "\u307B\u305D\u3044",
      "\u307B\u305D\u304F",
      "\u307B\u305F\u3066",
      "\u307B\u305F\u308B",
      "\u307B\u309A\u3061\u3075\u3099\u304F\u308D",
      "\u307B\u3063\u304D\u3087\u304F",
      "\u307B\u3063\u3055",
      "\u307B\u3063\u305F\u3093",
      "\u307B\u3068\u3093\u3068\u3099",
      "\u307B\u3081\u308B",
      "\u307B\u3093\u3044",
      "\u307B\u3093\u304D",
      "\u307B\u3093\u3051",
      "\u307B\u3093\u3057\u3064",
      "\u307B\u3093\u3084\u304F",
      "\u307E\u3044\u306B\u3061",
      "\u307E\u304B\u3044",
      "\u307E\u304B\u305B\u308B",
      "\u307E\u304B\u3099\u308B",
      "\u307E\u3051\u308B",
      "\u307E\u3053\u3068",
      "\u307E\u3055\u3064",
      "\u307E\u3057\u3099\u3081",
      "\u307E\u3059\u304F",
      "\u307E\u305B\u3099\u308B",
      "\u307E\u3064\u308A",
      "\u307E\u3068\u3081",
      "\u307E\u306A\u3075\u3099",
      "\u307E\u306C\u3051",
      "\u307E\u306D\u304F",
      "\u307E\u307B\u3046",
      "\u307E\u3082\u308B",
      "\u307E\u3086\u3051\u3099",
      "\u307E\u3088\u3046",
      "\u307E\u308D\u3084\u304B",
      "\u307E\u308F\u3059",
      "\u307E\u308F\u308A",
      "\u307E\u308F\u308B",
      "\u307E\u3093\u304B\u3099",
      "\u307E\u3093\u304D\u3064",
      "\u307E\u3093\u305D\u3099\u304F",
      "\u307E\u3093\u306A\u304B",
      "\u307F\u3044\u3089",
      "\u307F\u3046\u3061",
      "\u307F\u3048\u308B",
      "\u307F\u304B\u3099\u304F",
      "\u307F\u304B\u305F",
      "\u307F\u304B\u3093",
      "\u307F\u3051\u3093",
      "\u307F\u3053\u3093",
      "\u307F\u3057\u3099\u304B\u3044",
      "\u307F\u3059\u3044",
      "\u307F\u3059\u3048\u308B",
      "\u307F\u305B\u308B",
      "\u307F\u3063\u304B",
      "\u307F\u3064\u304B\u308B",
      "\u307F\u3064\u3051\u308B",
      "\u307F\u3066\u3044",
      "\u307F\u3068\u3081\u308B",
      "\u307F\u306A\u3068",
      "\u307F\u306A\u307F\u304B\u3055\u3044",
      "\u307F\u306D\u3089\u308B",
      "\u307F\u306E\u3046",
      "\u307F\u306E\u304B\u3099\u3059",
      "\u307F\u307B\u3093",
      "\u307F\u3082\u3068",
      "\u307F\u3084\u3051\u3099",
      "\u307F\u3089\u3044",
      "\u307F\u308A\u3087\u304F",
      "\u307F\u308F\u304F",
      "\u307F\u3093\u304B",
      "\u307F\u3093\u305D\u3099\u304F",
      "\u3080\u3044\u304B",
      "\u3080\u3048\u304D",
      "\u3080\u3048\u3093",
      "\u3080\u304B\u3044",
      "\u3080\u304B\u3046",
      "\u3080\u304B\u3048",
      "\u3080\u304B\u3057",
      "\u3080\u304D\u3099\u3061\u3083",
      "\u3080\u3051\u308B",
      "\u3080\u3051\u3099\u3093",
      "\u3080\u3055\u307B\u3099\u308B",
      "\u3080\u3057\u3042\u3064\u3044",
      "\u3080\u3057\u306F\u3099",
      "\u3080\u3057\u3099\u3085\u3093",
      "\u3080\u3057\u308D",
      "\u3080\u3059\u3046",
      "\u3080\u3059\u3053",
      "\u3080\u3059\u3075\u3099",
      "\u3080\u3059\u3081",
      "\u3080\u305B\u308B",
      "\u3080\u305B\u3093",
      "\u3080\u3061\u3085\u3046",
      "\u3080\u306A\u3057\u3044",
      "\u3080\u306E\u3046",
      "\u3080\u3084\u307F",
      "\u3080\u3088\u3046",
      "\u3080\u3089\u3055\u304D",
      "\u3080\u308A\u3087\u3046",
      "\u3080\u308D\u3093",
      "\u3081\u3044\u3042\u3093",
      "\u3081\u3044\u3046\u3093",
      "\u3081\u3044\u3048\u3093",
      "\u3081\u3044\u304B\u304F",
      "\u3081\u3044\u304D\u3087\u304F",
      "\u3081\u3044\u3055\u3044",
      "\u3081\u3044\u3057",
      "\u3081\u3044\u305D\u3046",
      "\u3081\u3044\u3075\u3099\u3064",
      "\u3081\u3044\u308C\u3044",
      "\u3081\u3044\u308F\u304F",
      "\u3081\u304F\u3099\u307E\u308C\u308B",
      "\u3081\u3055\u3099\u3059",
      "\u3081\u3057\u305F",
      "\u3081\u3059\u3099\u3089\u3057\u3044",
      "\u3081\u305F\u3099\u3064",
      "\u3081\u307E\u3044",
      "\u3081\u3084\u3059",
      "\u3081\u3093\u304D\u3087",
      "\u3081\u3093\u305B\u304D",
      "\u3081\u3093\u3068\u3099\u3046",
      "\u3082\u3046\u3057\u3042\u3051\u3099\u308B",
      "\u3082\u3046\u3068\u3099\u3046\u3051\u3093",
      "\u3082\u3048\u308B",
      "\u3082\u304F\u3057",
      "\u3082\u304F\u3066\u304D",
      "\u3082\u304F\u3088\u3046\u3072\u3099",
      "\u3082\u3061\u308D\u3093",
      "\u3082\u3068\u3099\u308B",
      "\u3082\u3089\u3046",
      "\u3082\u3093\u304F",
      "\u3082\u3093\u305F\u3099\u3044",
      "\u3084\u304A\u3084",
      "\u3084\u3051\u308B",
      "\u3084\u3055\u3044",
      "\u3084\u3055\u3057\u3044",
      "\u3084\u3059\u3044",
      "\u3084\u3059\u305F\u308D\u3046",
      "\u3084\u3059\u307F",
      "\u3084\u305B\u308B",
      "\u3084\u305D\u3046",
      "\u3084\u305F\u3044",
      "\u3084\u3061\u3093",
      "\u3084\u3063\u3068",
      "\u3084\u3063\u306F\u309A\u308A",
      "\u3084\u3075\u3099\u308B",
      "\u3084\u3081\u308B",
      "\u3084\u3084\u3053\u3057\u3044",
      "\u3084\u3088\u3044",
      "\u3084\u308F\u3089\u304B\u3044",
      "\u3086\u3046\u304D",
      "\u3086\u3046\u3072\u3099\u3093\u304D\u3087\u304F",
      "\u3086\u3046\u3078\u3099",
      "\u3086\u3046\u3081\u3044",
      "\u3086\u3051\u3064",
      "\u3086\u3057\u3085\u3064",
      "\u3086\u305B\u3093",
      "\u3086\u305D\u3046",
      "\u3086\u305F\u304B",
      "\u3086\u3061\u3083\u304F",
      "\u3086\u3066\u3099\u308B",
      "\u3086\u306B\u3085\u3046",
      "\u3086\u3072\u3099\u308F",
      "\u3086\u3089\u3044",
      "\u3086\u308C\u308B",
      "\u3088\u3046\u3044",
      "\u3088\u3046\u304B",
      "\u3088\u3046\u304D\u3085\u3046",
      "\u3088\u3046\u3057\u3099",
      "\u3088\u3046\u3059",
      "\u3088\u3046\u3061\u3048\u3093",
      "\u3088\u304B\u305B\u3099",
      "\u3088\u304B\u3093",
      "\u3088\u304D\u3093",
      "\u3088\u304F\u305B\u3044",
      "\u3088\u304F\u307B\u3099\u3046",
      "\u3088\u3051\u3044",
      "\u3088\u3053\u3099\u308C\u308B",
      "\u3088\u3055\u3093",
      "\u3088\u3057\u3085\u3046",
      "\u3088\u305D\u3046",
      "\u3088\u305D\u304F",
      "\u3088\u3063\u304B",
      "\u3088\u3066\u3044",
      "\u3088\u3068\u3099\u304B\u3099\u308F\u304F",
      "\u3088\u306D\u3064",
      "\u3088\u3084\u304F",
      "\u3088\u3086\u3046",
      "\u3088\u308D\u3053\u3075\u3099",
      "\u3088\u308D\u3057\u3044",
      "\u3089\u3044\u3046",
      "\u3089\u304F\u304B\u3099\u304D",
      "\u3089\u304F\u3053\u3099",
      "\u3089\u304F\u3055\u3064",
      "\u3089\u304F\u305F\u3099",
      "\u3089\u3057\u3093\u306F\u3099\u3093",
      "\u3089\u305B\u3093",
      "\u3089\u305D\u3099\u304F",
      "\u3089\u305F\u3044",
      "\u3089\u3063\u304B",
      "\u3089\u308C\u3064",
      "\u308A\u3048\u304D",
      "\u308A\u304B\u3044",
      "\u308A\u304D\u3055\u304F",
      "\u308A\u304D\u305B\u3064",
      "\u308A\u304F\u304F\u3099\u3093",
      "\u308A\u304F\u3064",
      "\u308A\u3051\u3093",
      "\u308A\u3053\u3046",
      "\u308A\u305B\u3044",
      "\u308A\u305D\u3046",
      "\u308A\u305D\u304F",
      "\u308A\u3066\u3093",
      "\u308A\u306D\u3093",
      "\u308A\u3086\u3046",
      "\u308A\u3085\u3046\u304B\u3099\u304F",
      "\u308A\u3088\u3046",
      "\u308A\u3087\u3046\u308A",
      "\u308A\u3087\u304B\u3093",
      "\u308A\u3087\u304F\u3061\u3083",
      "\u308A\u3087\u3053\u3046",
      "\u308A\u308A\u304F",
      "\u308A\u308C\u304D",
      "\u308A\u308D\u3093",
      "\u308A\u3093\u3053\u3099",
      "\u308B\u3044\u3051\u3044",
      "\u308B\u3044\u3055\u3044",
      "\u308B\u3044\u3057\u3099",
      "\u308B\u3044\u305B\u304D",
      "\u308B\u3059\u306F\u3099\u3093",
      "\u308B\u308A\u304B\u3099\u308F\u3089",
      "\u308C\u3044\u304B\u3093",
      "\u308C\u3044\u304D\u3099",
      "\u308C\u3044\u305B\u3044",
      "\u308C\u3044\u305D\u3099\u3046\u3053",
      "\u308C\u3044\u3068\u3046",
      "\u308C\u3044\u307B\u3099\u3046",
      "\u308C\u304D\u3057",
      "\u308C\u304D\u305F\u3099\u3044",
      "\u308C\u3093\u3042\u3044",
      "\u308C\u3093\u3051\u3044",
      "\u308C\u3093\u3053\u3093",
      "\u308C\u3093\u3055\u3044",
      "\u308C\u3093\u3057\u3085\u3046",
      "\u308C\u3093\u305D\u3099\u304F",
      "\u308C\u3093\u3089\u304F",
      "\u308D\u3046\u304B",
      "\u308D\u3046\u3053\u3099",
      "\u308D\u3046\u3057\u3099\u3093",
      "\u308D\u3046\u305D\u304F",
      "\u308D\u304F\u304B\u3099",
      "\u308D\u3053\u3064",
      "\u308D\u3057\u3099\u3046\u3089",
      "\u308D\u3057\u3085\u3064",
      "\u308D\u305B\u3093",
      "\u308D\u3066\u3093",
      "\u308D\u3081\u3093",
      "\u308D\u308C\u3064",
      "\u308D\u3093\u304D\u3099",
      "\u308D\u3093\u306F\u309A",
      "\u308D\u3093\u3075\u3099\u3093",
      "\u308D\u3093\u308A",
      "\u308F\u304B\u3059",
      "\u308F\u304B\u3081",
      "\u308F\u304B\u3084\u307E",
      "\u308F\u304B\u308C\u308B",
      "\u308F\u3057\u3064",
      "\u308F\u3057\u3099\u307E\u3057",
      "\u308F\u3059\u308C\u3082\u306E",
      "\u308F\u3089\u3046",
      "\u308F\u308C\u308B"
    ];
  }
});

// node_modules/bip39/src/wordlists/portuguese.json
var require_portuguese = __commonJS({
  "node_modules/bip39/src/wordlists/portuguese.json"(exports2, module2) {
    module2.exports = [
      "abacate",
      "abaixo",
      "abalar",
      "abater",
      "abduzir",
      "abelha",
      "aberto",
      "abismo",
      "abotoar",
      "abranger",
      "abreviar",
      "abrigar",
      "abrupto",
      "absinto",
      "absoluto",
      "absurdo",
      "abutre",
      "acabado",
      "acalmar",
      "acampar",
      "acanhar",
      "acaso",
      "aceitar",
      "acelerar",
      "acenar",
      "acervo",
      "acessar",
      "acetona",
      "achatar",
      "acidez",
      "acima",
      "acionado",
      "acirrar",
      "aclamar",
      "aclive",
      "acolhida",
      "acomodar",
      "acoplar",
      "acordar",
      "acumular",
      "acusador",
      "adaptar",
      "adega",
      "adentro",
      "adepto",
      "adequar",
      "aderente",
      "adesivo",
      "adeus",
      "adiante",
      "aditivo",
      "adjetivo",
      "adjunto",
      "admirar",
      "adorar",
      "adquirir",
      "adubo",
      "adverso",
      "advogado",
      "aeronave",
      "afastar",
      "aferir",
      "afetivo",
      "afinador",
      "afivelar",
      "aflito",
      "afluente",
      "afrontar",
      "agachar",
      "agarrar",
      "agasalho",
      "agenciar",
      "agilizar",
      "agiota",
      "agitado",
      "agora",
      "agradar",
      "agreste",
      "agrupar",
      "aguardar",
      "agulha",
      "ajoelhar",
      "ajudar",
      "ajustar",
      "alameda",
      "alarme",
      "alastrar",
      "alavanca",
      "albergue",
      "albino",
      "alcatra",
      "aldeia",
      "alecrim",
      "alegria",
      "alertar",
      "alface",
      "alfinete",
      "algum",
      "alheio",
      "aliar",
      "alicate",
      "alienar",
      "alinhar",
      "aliviar",
      "almofada",
      "alocar",
      "alpiste",
      "alterar",
      "altitude",
      "alucinar",
      "alugar",
      "aluno",
      "alusivo",
      "alvo",
      "amaciar",
      "amador",
      "amarelo",
      "amassar",
      "ambas",
      "ambiente",
      "ameixa",
      "amenizar",
      "amido",
      "amistoso",
      "amizade",
      "amolador",
      "amontoar",
      "amoroso",
      "amostra",
      "amparar",
      "ampliar",
      "ampola",
      "anagrama",
      "analisar",
      "anarquia",
      "anatomia",
      "andaime",
      "anel",
      "anexo",
      "angular",
      "animar",
      "anjo",
      "anomalia",
      "anotado",
      "ansioso",
      "anterior",
      "anuidade",
      "anunciar",
      "anzol",
      "apagador",
      "apalpar",
      "apanhado",
      "apego",
      "apelido",
      "apertada",
      "apesar",
      "apetite",
      "apito",
      "aplauso",
      "aplicada",
      "apoio",
      "apontar",
      "aposta",
      "aprendiz",
      "aprovar",
      "aquecer",
      "arame",
      "aranha",
      "arara",
      "arcada",
      "ardente",
      "areia",
      "arejar",
      "arenito",
      "aresta",
      "argiloso",
      "argola",
      "arma",
      "arquivo",
      "arraial",
      "arrebate",
      "arriscar",
      "arroba",
      "arrumar",
      "arsenal",
      "arterial",
      "artigo",
      "arvoredo",
      "asfaltar",
      "asilado",
      "aspirar",
      "assador",
      "assinar",
      "assoalho",
      "assunto",
      "astral",
      "atacado",
      "atadura",
      "atalho",
      "atarefar",
      "atear",
      "atender",
      "aterro",
      "ateu",
      "atingir",
      "atirador",
      "ativo",
      "atoleiro",
      "atracar",
      "atrevido",
      "atriz",
      "atual",
      "atum",
      "auditor",
      "aumentar",
      "aura",
      "aurora",
      "autismo",
      "autoria",
      "autuar",
      "avaliar",
      "avante",
      "avaria",
      "avental",
      "avesso",
      "aviador",
      "avisar",
      "avulso",
      "axila",
      "azarar",
      "azedo",
      "azeite",
      "azulejo",
      "babar",
      "babosa",
      "bacalhau",
      "bacharel",
      "bacia",
      "bagagem",
      "baiano",
      "bailar",
      "baioneta",
      "bairro",
      "baixista",
      "bajular",
      "baleia",
      "baliza",
      "balsa",
      "banal",
      "bandeira",
      "banho",
      "banir",
      "banquete",
      "barato",
      "barbado",
      "baronesa",
      "barraca",
      "barulho",
      "baseado",
      "bastante",
      "batata",
      "batedor",
      "batida",
      "batom",
      "batucar",
      "baunilha",
      "beber",
      "beijo",
      "beirada",
      "beisebol",
      "beldade",
      "beleza",
      "belga",
      "beliscar",
      "bendito",
      "bengala",
      "benzer",
      "berimbau",
      "berlinda",
      "berro",
      "besouro",
      "bexiga",
      "bezerro",
      "bico",
      "bicudo",
      "bienal",
      "bifocal",
      "bifurcar",
      "bigorna",
      "bilhete",
      "bimestre",
      "bimotor",
      "biologia",
      "biombo",
      "biosfera",
      "bipolar",
      "birrento",
      "biscoito",
      "bisneto",
      "bispo",
      "bissexto",
      "bitola",
      "bizarro",
      "blindado",
      "bloco",
      "bloquear",
      "boato",
      "bobagem",
      "bocado",
      "bocejo",
      "bochecha",
      "boicotar",
      "bolada",
      "boletim",
      "bolha",
      "bolo",
      "bombeiro",
      "bonde",
      "boneco",
      "bonita",
      "borbulha",
      "borda",
      "boreal",
      "borracha",
      "bovino",
      "boxeador",
      "branco",
      "brasa",
      "braveza",
      "breu",
      "briga",
      "brilho",
      "brincar",
      "broa",
      "brochura",
      "bronzear",
      "broto",
      "bruxo",
      "bucha",
      "budismo",
      "bufar",
      "bule",
      "buraco",
      "busca",
      "busto",
      "buzina",
      "cabana",
      "cabelo",
      "cabide",
      "cabo",
      "cabrito",
      "cacau",
      "cacetada",
      "cachorro",
      "cacique",
      "cadastro",
      "cadeado",
      "cafezal",
      "caiaque",
      "caipira",
      "caixote",
      "cajado",
      "caju",
      "calafrio",
      "calcular",
      "caldeira",
      "calibrar",
      "calmante",
      "calota",
      "camada",
      "cambista",
      "camisa",
      "camomila",
      "campanha",
      "camuflar",
      "canavial",
      "cancelar",
      "caneta",
      "canguru",
      "canhoto",
      "canivete",
      "canoa",
      "cansado",
      "cantar",
      "canudo",
      "capacho",
      "capela",
      "capinar",
      "capotar",
      "capricho",
      "captador",
      "capuz",
      "caracol",
      "carbono",
      "cardeal",
      "careca",
      "carimbar",
      "carneiro",
      "carpete",
      "carreira",
      "cartaz",
      "carvalho",
      "casaco",
      "casca",
      "casebre",
      "castelo",
      "casulo",
      "catarata",
      "cativar",
      "caule",
      "causador",
      "cautelar",
      "cavalo",
      "caverna",
      "cebola",
      "cedilha",
      "cegonha",
      "celebrar",
      "celular",
      "cenoura",
      "censo",
      "centeio",
      "cercar",
      "cerrado",
      "certeiro",
      "cerveja",
      "cetim",
      "cevada",
      "chacota",
      "chaleira",
      "chamado",
      "chapada",
      "charme",
      "chatice",
      "chave",
      "chefe",
      "chegada",
      "cheiro",
      "cheque",
      "chicote",
      "chifre",
      "chinelo",
      "chocalho",
      "chover",
      "chumbo",
      "chutar",
      "chuva",
      "cicatriz",
      "ciclone",
      "cidade",
      "cidreira",
      "ciente",
      "cigana",
      "cimento",
      "cinto",
      "cinza",
      "ciranda",
      "circuito",
      "cirurgia",
      "citar",
      "clareza",
      "clero",
      "clicar",
      "clone",
      "clube",
      "coado",
      "coagir",
      "cobaia",
      "cobertor",
      "cobrar",
      "cocada",
      "coelho",
      "coentro",
      "coeso",
      "cogumelo",
      "coibir",
      "coifa",
      "coiote",
      "colar",
      "coleira",
      "colher",
      "colidir",
      "colmeia",
      "colono",
      "coluna",
      "comando",
      "combinar",
      "comentar",
      "comitiva",
      "comover",
      "complexo",
      "comum",
      "concha",
      "condor",
      "conectar",
      "confuso",
      "congelar",
      "conhecer",
      "conjugar",
      "consumir",
      "contrato",
      "convite",
      "cooperar",
      "copeiro",
      "copiador",
      "copo",
      "coquetel",
      "coragem",
      "cordial",
      "corneta",
      "coronha",
      "corporal",
      "correio",
      "cortejo",
      "coruja",
      "corvo",
      "cosseno",
      "costela",
      "cotonete",
      "couro",
      "couve",
      "covil",
      "cozinha",
      "cratera",
      "cravo",
      "creche",
      "credor",
      "creme",
      "crer",
      "crespo",
      "criada",
      "criminal",
      "crioulo",
      "crise",
      "criticar",
      "crosta",
      "crua",
      "cruzeiro",
      "cubano",
      "cueca",
      "cuidado",
      "cujo",
      "culatra",
      "culminar",
      "culpar",
      "cultura",
      "cumprir",
      "cunhado",
      "cupido",
      "curativo",
      "curral",
      "cursar",
      "curto",
      "cuspir",
      "custear",
      "cutelo",
      "damasco",
      "datar",
      "debater",
      "debitar",
      "deboche",
      "debulhar",
      "decalque",
      "decimal",
      "declive",
      "decote",
      "decretar",
      "dedal",
      "dedicado",
      "deduzir",
      "defesa",
      "defumar",
      "degelo",
      "degrau",
      "degustar",
      "deitado",
      "deixar",
      "delator",
      "delegado",
      "delinear",
      "delonga",
      "demanda",
      "demitir",
      "demolido",
      "dentista",
      "depenado",
      "depilar",
      "depois",
      "depressa",
      "depurar",
      "deriva",
      "derramar",
      "desafio",
      "desbotar",
      "descanso",
      "desenho",
      "desfiado",
      "desgaste",
      "desigual",
      "deslize",
      "desmamar",
      "desova",
      "despesa",
      "destaque",
      "desviar",
      "detalhar",
      "detentor",
      "detonar",
      "detrito",
      "deusa",
      "dever",
      "devido",
      "devotado",
      "dezena",
      "diagrama",
      "dialeto",
      "didata",
      "difuso",
      "digitar",
      "dilatado",
      "diluente",
      "diminuir",
      "dinastia",
      "dinheiro",
      "diocese",
      "direto",
      "discreta",
      "disfarce",
      "disparo",
      "disquete",
      "dissipar",
      "distante",
      "ditador",
      "diurno",
      "diverso",
      "divisor",
      "divulgar",
      "dizer",
      "dobrador",
      "dolorido",
      "domador",
      "dominado",
      "donativo",
      "donzela",
      "dormente",
      "dorsal",
      "dosagem",
      "dourado",
      "doutor",
      "drenagem",
      "drible",
      "drogaria",
      "duelar",
      "duende",
      "dueto",
      "duplo",
      "duquesa",
      "durante",
      "duvidoso",
      "eclodir",
      "ecoar",
      "ecologia",
      "edificar",
      "edital",
      "educado",
      "efeito",
      "efetivar",
      "ejetar",
      "elaborar",
      "eleger",
      "eleitor",
      "elenco",
      "elevador",
      "eliminar",
      "elogiar",
      "embargo",
      "embolado",
      "embrulho",
      "embutido",
      "emenda",
      "emergir",
      "emissor",
      "empatia",
      "empenho",
      "empinado",
      "empolgar",
      "emprego",
      "empurrar",
      "emulador",
      "encaixe",
      "encenado",
      "enchente",
      "encontro",
      "endeusar",
      "endossar",
      "enfaixar",
      "enfeite",
      "enfim",
      "engajado",
      "engenho",
      "englobar",
      "engomado",
      "engraxar",
      "enguia",
      "enjoar",
      "enlatar",
      "enquanto",
      "enraizar",
      "enrolado",
      "enrugar",
      "ensaio",
      "enseada",
      "ensino",
      "ensopado",
      "entanto",
      "enteado",
      "entidade",
      "entortar",
      "entrada",
      "entulho",
      "envergar",
      "enviado",
      "envolver",
      "enxame",
      "enxerto",
      "enxofre",
      "enxuto",
      "epiderme",
      "equipar",
      "ereto",
      "erguido",
      "errata",
      "erva",
      "ervilha",
      "esbanjar",
      "esbelto",
      "escama",
      "escola",
      "escrita",
      "escuta",
      "esfinge",
      "esfolar",
      "esfregar",
      "esfumado",
      "esgrima",
      "esmalte",
      "espanto",
      "espelho",
      "espiga",
      "esponja",
      "espreita",
      "espumar",
      "esquerda",
      "estaca",
      "esteira",
      "esticar",
      "estofado",
      "estrela",
      "estudo",
      "esvaziar",
      "etanol",
      "etiqueta",
      "euforia",
      "europeu",
      "evacuar",
      "evaporar",
      "evasivo",
      "eventual",
      "evidente",
      "evoluir",
      "exagero",
      "exalar",
      "examinar",
      "exato",
      "exausto",
      "excesso",
      "excitar",
      "exclamar",
      "executar",
      "exemplo",
      "exibir",
      "exigente",
      "exonerar",
      "expandir",
      "expelir",
      "expirar",
      "explanar",
      "exposto",
      "expresso",
      "expulsar",
      "externo",
      "extinto",
      "extrato",
      "fabricar",
      "fabuloso",
      "faceta",
      "facial",
      "fada",
      "fadiga",
      "faixa",
      "falar",
      "falta",
      "familiar",
      "fandango",
      "fanfarra",
      "fantoche",
      "fardado",
      "farelo",
      "farinha",
      "farofa",
      "farpa",
      "fartura",
      "fatia",
      "fator",
      "favorita",
      "faxina",
      "fazenda",
      "fechado",
      "feijoada",
      "feirante",
      "felino",
      "feminino",
      "fenda",
      "feno",
      "fera",
      "feriado",
      "ferrugem",
      "ferver",
      "festejar",
      "fetal",
      "feudal",
      "fiapo",
      "fibrose",
      "ficar",
      "ficheiro",
      "figurado",
      "fileira",
      "filho",
      "filme",
      "filtrar",
      "firmeza",
      "fisgada",
      "fissura",
      "fita",
      "fivela",
      "fixador",
      "fixo",
      "flacidez",
      "flamingo",
      "flanela",
      "flechada",
      "flora",
      "flutuar",
      "fluxo",
      "focal",
      "focinho",
      "fofocar",
      "fogo",
      "foguete",
      "foice",
      "folgado",
      "folheto",
      "forjar",
      "formiga",
      "forno",
      "forte",
      "fosco",
      "fossa",
      "fragata",
      "fralda",
      "frango",
      "frasco",
      "fraterno",
      "freira",
      "frente",
      "fretar",
      "frieza",
      "friso",
      "fritura",
      "fronha",
      "frustrar",
      "fruteira",
      "fugir",
      "fulano",
      "fuligem",
      "fundar",
      "fungo",
      "funil",
      "furador",
      "furioso",
      "futebol",
      "gabarito",
      "gabinete",
      "gado",
      "gaiato",
      "gaiola",
      "gaivota",
      "galega",
      "galho",
      "galinha",
      "galocha",
      "ganhar",
      "garagem",
      "garfo",
      "gargalo",
      "garimpo",
      "garoupa",
      "garrafa",
      "gasoduto",
      "gasto",
      "gata",
      "gatilho",
      "gaveta",
      "gazela",
      "gelado",
      "geleia",
      "gelo",
      "gemada",
      "gemer",
      "gemido",
      "generoso",
      "gengiva",
      "genial",
      "genoma",
      "genro",
      "geologia",
      "gerador",
      "germinar",
      "gesso",
      "gestor",
      "ginasta",
      "gincana",
      "gingado",
      "girafa",
      "girino",
      "glacial",
      "glicose",
      "global",
      "glorioso",
      "goela",
      "goiaba",
      "golfe",
      "golpear",
      "gordura",
      "gorjeta",
      "gorro",
      "gostoso",
      "goteira",
      "governar",
      "gracejo",
      "gradual",
      "grafite",
      "gralha",
      "grampo",
      "granada",
      "gratuito",
      "graveto",
      "graxa",
      "grego",
      "grelhar",
      "greve",
      "grilo",
      "grisalho",
      "gritaria",
      "grosso",
      "grotesco",
      "grudado",
      "grunhido",
      "gruta",
      "guache",
      "guarani",
      "guaxinim",
      "guerrear",
      "guiar",
      "guincho",
      "guisado",
      "gula",
      "guloso",
      "guru",
      "habitar",
      "harmonia",
      "haste",
      "haver",
      "hectare",
      "herdar",
      "heresia",
      "hesitar",
      "hiato",
      "hibernar",
      "hidratar",
      "hiena",
      "hino",
      "hipismo",
      "hipnose",
      "hipoteca",
      "hoje",
      "holofote",
      "homem",
      "honesto",
      "honrado",
      "hormonal",
      "hospedar",
      "humorado",
      "iate",
      "ideia",
      "idoso",
      "ignorado",
      "igreja",
      "iguana",
      "ileso",
      "ilha",
      "iludido",
      "iluminar",
      "ilustrar",
      "imagem",
      "imediato",
      "imenso",
      "imersivo",
      "iminente",
      "imitador",
      "imortal",
      "impacto",
      "impedir",
      "implante",
      "impor",
      "imprensa",
      "impune",
      "imunizar",
      "inalador",
      "inapto",
      "inativo",
      "incenso",
      "inchar",
      "incidir",
      "incluir",
      "incolor",
      "indeciso",
      "indireto",
      "indutor",
      "ineficaz",
      "inerente",
      "infantil",
      "infestar",
      "infinito",
      "inflamar",
      "informal",
      "infrator",
      "ingerir",
      "inibido",
      "inicial",
      "inimigo",
      "injetar",
      "inocente",
      "inodoro",
      "inovador",
      "inox",
      "inquieto",
      "inscrito",
      "inseto",
      "insistir",
      "inspetor",
      "instalar",
      "insulto",
      "intacto",
      "integral",
      "intimar",
      "intocado",
      "intriga",
      "invasor",
      "inverno",
      "invicto",
      "invocar",
      "iogurte",
      "iraniano",
      "ironizar",
      "irreal",
      "irritado",
      "isca",
      "isento",
      "isolado",
      "isqueiro",
      "italiano",
      "janeiro",
      "jangada",
      "janta",
      "jararaca",
      "jardim",
      "jarro",
      "jasmim",
      "jato",
      "javali",
      "jazida",
      "jejum",
      "joaninha",
      "joelhada",
      "jogador",
      "joia",
      "jornal",
      "jorrar",
      "jovem",
      "juba",
      "judeu",
      "judoca",
      "juiz",
      "julgador",
      "julho",
      "jurado",
      "jurista",
      "juro",
      "justa",
      "labareda",
      "laboral",
      "lacre",
      "lactante",
      "ladrilho",
      "lagarta",
      "lagoa",
      "laje",
      "lamber",
      "lamentar",
      "laminar",
      "lampejo",
      "lanche",
      "lapidar",
      "lapso",
      "laranja",
      "lareira",
      "largura",
      "lasanha",
      "lastro",
      "lateral",
      "latido",
      "lavanda",
      "lavoura",
      "lavrador",
      "laxante",
      "lazer",
      "lealdade",
      "lebre",
      "legado",
      "legendar",
      "legista",
      "leigo",
      "leiloar",
      "leitura",
      "lembrete",
      "leme",
      "lenhador",
      "lentilha",
      "leoa",
      "lesma",
      "leste",
      "letivo",
      "letreiro",
      "levar",
      "leveza",
      "levitar",
      "liberal",
      "libido",
      "liderar",
      "ligar",
      "ligeiro",
      "limitar",
      "limoeiro",
      "limpador",
      "linda",
      "linear",
      "linhagem",
      "liquidez",
      "listagem",
      "lisura",
      "litoral",
      "livro",
      "lixa",
      "lixeira",
      "locador",
      "locutor",
      "lojista",
      "lombo",
      "lona",
      "longe",
      "lontra",
      "lorde",
      "lotado",
      "loteria",
      "loucura",
      "lousa",
      "louvar",
      "luar",
      "lucidez",
      "lucro",
      "luneta",
      "lustre",
      "lutador",
      "luva",
      "macaco",
      "macete",
      "machado",
      "macio",
      "madeira",
      "madrinha",
      "magnata",
      "magreza",
      "maior",
      "mais",
      "malandro",
      "malha",
      "malote",
      "maluco",
      "mamilo",
      "mamoeiro",
      "mamute",
      "manada",
      "mancha",
      "mandato",
      "manequim",
      "manhoso",
      "manivela",
      "manobrar",
      "mansa",
      "manter",
      "manusear",
      "mapeado",
      "maquinar",
      "marcador",
      "maresia",
      "marfim",
      "margem",
      "marinho",
      "marmita",
      "maroto",
      "marquise",
      "marreco",
      "martelo",
      "marujo",
      "mascote",
      "masmorra",
      "massagem",
      "mastigar",
      "matagal",
      "materno",
      "matinal",
      "matutar",
      "maxilar",
      "medalha",
      "medida",
      "medusa",
      "megafone",
      "meiga",
      "melancia",
      "melhor",
      "membro",
      "memorial",
      "menino",
      "menos",
      "mensagem",
      "mental",
      "merecer",
      "mergulho",
      "mesada",
      "mesclar",
      "mesmo",
      "mesquita",
      "mestre",
      "metade",
      "meteoro",
      "metragem",
      "mexer",
      "mexicano",
      "micro",
      "migalha",
      "migrar",
      "milagre",
      "milenar",
      "milhar",
      "mimado",
      "minerar",
      "minhoca",
      "ministro",
      "minoria",
      "miolo",
      "mirante",
      "mirtilo",
      "misturar",
      "mocidade",
      "moderno",
      "modular",
      "moeda",
      "moer",
      "moinho",
      "moita",
      "moldura",
      "moleza",
      "molho",
      "molinete",
      "molusco",
      "montanha",
      "moqueca",
      "morango",
      "morcego",
      "mordomo",
      "morena",
      "mosaico",
      "mosquete",
      "mostarda",
      "motel",
      "motim",
      "moto",
      "motriz",
      "muda",
      "muito",
      "mulata",
      "mulher",
      "multar",
      "mundial",
      "munido",
      "muralha",
      "murcho",
      "muscular",
      "museu",
      "musical",
      "nacional",
      "nadador",
      "naja",
      "namoro",
      "narina",
      "narrado",
      "nascer",
      "nativa",
      "natureza",
      "navalha",
      "navegar",
      "navio",
      "neblina",
      "nebuloso",
      "negativa",
      "negociar",
      "negrito",
      "nervoso",
      "neta",
      "neural",
      "nevasca",
      "nevoeiro",
      "ninar",
      "ninho",
      "nitidez",
      "nivelar",
      "nobreza",
      "noite",
      "noiva",
      "nomear",
      "nominal",
      "nordeste",
      "nortear",
      "notar",
      "noticiar",
      "noturno",
      "novelo",
      "novilho",
      "novo",
      "nublado",
      "nudez",
      "numeral",
      "nupcial",
      "nutrir",
      "nuvem",
      "obcecado",
      "obedecer",
      "objetivo",
      "obrigado",
      "obscuro",
      "obstetra",
      "obter",
      "obturar",
      "ocidente",
      "ocioso",
      "ocorrer",
      "oculista",
      "ocupado",
      "ofegante",
      "ofensiva",
      "oferenda",
      "oficina",
      "ofuscado",
      "ogiva",
      "olaria",
      "oleoso",
      "olhar",
      "oliveira",
      "ombro",
      "omelete",
      "omisso",
      "omitir",
      "ondulado",
      "oneroso",
      "ontem",
      "opcional",
      "operador",
      "oponente",
      "oportuno",
      "oposto",
      "orar",
      "orbitar",
      "ordem",
      "ordinal",
      "orfanato",
      "orgasmo",
      "orgulho",
      "oriental",
      "origem",
      "oriundo",
      "orla",
      "ortodoxo",
      "orvalho",
      "oscilar",
      "ossada",
      "osso",
      "ostentar",
      "otimismo",
      "ousadia",
      "outono",
      "outubro",
      "ouvido",
      "ovelha",
      "ovular",
      "oxidar",
      "oxigenar",
      "pacato",
      "paciente",
      "pacote",
      "pactuar",
      "padaria",
      "padrinho",
      "pagar",
      "pagode",
      "painel",
      "pairar",
      "paisagem",
      "palavra",
      "palestra",
      "palheta",
      "palito",
      "palmada",
      "palpitar",
      "pancada",
      "panela",
      "panfleto",
      "panqueca",
      "pantanal",
      "papagaio",
      "papelada",
      "papiro",
      "parafina",
      "parcial",
      "pardal",
      "parede",
      "partida",
      "pasmo",
      "passado",
      "pastel",
      "patamar",
      "patente",
      "patinar",
      "patrono",
      "paulada",
      "pausar",
      "peculiar",
      "pedalar",
      "pedestre",
      "pediatra",
      "pedra",
      "pegada",
      "peitoral",
      "peixe",
      "pele",
      "pelicano",
      "penca",
      "pendurar",
      "peneira",
      "penhasco",
      "pensador",
      "pente",
      "perceber",
      "perfeito",
      "pergunta",
      "perito",
      "permitir",
      "perna",
      "perplexo",
      "persiana",
      "pertence",
      "peruca",
      "pescado",
      "pesquisa",
      "pessoa",
      "petiscar",
      "piada",
      "picado",
      "piedade",
      "pigmento",
      "pilastra",
      "pilhado",
      "pilotar",
      "pimenta",
      "pincel",
      "pinguim",
      "pinha",
      "pinote",
      "pintar",
      "pioneiro",
      "pipoca",
      "piquete",
      "piranha",
      "pires",
      "pirueta",
      "piscar",
      "pistola",
      "pitanga",
      "pivete",
      "planta",
      "plaqueta",
      "platina",
      "plebeu",
      "plumagem",
      "pluvial",
      "pneu",
      "poda",
      "poeira",
      "poetisa",
      "polegada",
      "policiar",
      "poluente",
      "polvilho",
      "pomar",
      "pomba",
      "ponderar",
      "pontaria",
      "populoso",
      "porta",
      "possuir",
      "postal",
      "pote",
      "poupar",
      "pouso",
      "povoar",
      "praia",
      "prancha",
      "prato",
      "praxe",
      "prece",
      "predador",
      "prefeito",
      "premiar",
      "prensar",
      "preparar",
      "presilha",
      "pretexto",
      "prevenir",
      "prezar",
      "primata",
      "princesa",
      "prisma",
      "privado",
      "processo",
      "produto",
      "profeta",
      "proibido",
      "projeto",
      "prometer",
      "propagar",
      "prosa",
      "protetor",
      "provador",
      "publicar",
      "pudim",
      "pular",
      "pulmonar",
      "pulseira",
      "punhal",
      "punir",
      "pupilo",
      "pureza",
      "puxador",
      "quadra",
      "quantia",
      "quarto",
      "quase",
      "quebrar",
      "queda",
      "queijo",
      "quente",
      "querido",
      "quimono",
      "quina",
      "quiosque",
      "rabanada",
      "rabisco",
      "rachar",
      "racionar",
      "radial",
      "raiar",
      "rainha",
      "raio",
      "raiva",
      "rajada",
      "ralado",
      "ramal",
      "ranger",
      "ranhura",
      "rapadura",
      "rapel",
      "rapidez",
      "raposa",
      "raquete",
      "raridade",
      "rasante",
      "rascunho",
      "rasgar",
      "raspador",
      "rasteira",
      "rasurar",
      "ratazana",
      "ratoeira",
      "realeza",
      "reanimar",
      "reaver",
      "rebaixar",
      "rebelde",
      "rebolar",
      "recado",
      "recente",
      "recheio",
      "recibo",
      "recordar",
      "recrutar",
      "recuar",
      "rede",
      "redimir",
      "redonda",
      "reduzida",
      "reenvio",
      "refinar",
      "refletir",
      "refogar",
      "refresco",
      "refugiar",
      "regalia",
      "regime",
      "regra",
      "reinado",
      "reitor",
      "rejeitar",
      "relativo",
      "remador",
      "remendo",
      "remorso",
      "renovado",
      "reparo",
      "repelir",
      "repleto",
      "repolho",
      "represa",
      "repudiar",
      "requerer",
      "resenha",
      "resfriar",
      "resgatar",
      "residir",
      "resolver",
      "respeito",
      "ressaca",
      "restante",
      "resumir",
      "retalho",
      "reter",
      "retirar",
      "retomada",
      "retratar",
      "revelar",
      "revisor",
      "revolta",
      "riacho",
      "rica",
      "rigidez",
      "rigoroso",
      "rimar",
      "ringue",
      "risada",
      "risco",
      "risonho",
      "robalo",
      "rochedo",
      "rodada",
      "rodeio",
      "rodovia",
      "roedor",
      "roleta",
      "romano",
      "roncar",
      "rosado",
      "roseira",
      "rosto",
      "rota",
      "roteiro",
      "rotina",
      "rotular",
      "rouco",
      "roupa",
      "roxo",
      "rubro",
      "rugido",
      "rugoso",
      "ruivo",
      "rumo",
      "rupestre",
      "russo",
      "sabor",
      "saciar",
      "sacola",
      "sacudir",
      "sadio",
      "safira",
      "saga",
      "sagrada",
      "saibro",
      "salada",
      "saleiro",
      "salgado",
      "saliva",
      "salpicar",
      "salsicha",
      "saltar",
      "salvador",
      "sambar",
      "samurai",
      "sanar",
      "sanfona",
      "sangue",
      "sanidade",
      "sapato",
      "sarda",
      "sargento",
      "sarjeta",
      "saturar",
      "saudade",
      "saxofone",
      "sazonal",
      "secar",
      "secular",
      "seda",
      "sedento",
      "sediado",
      "sedoso",
      "sedutor",
      "segmento",
      "segredo",
      "segundo",
      "seiva",
      "seleto",
      "selvagem",
      "semanal",
      "semente",
      "senador",
      "senhor",
      "sensual",
      "sentado",
      "separado",
      "sereia",
      "seringa",
      "serra",
      "servo",
      "setembro",
      "setor",
      "sigilo",
      "silhueta",
      "silicone",
      "simetria",
      "simpatia",
      "simular",
      "sinal",
      "sincero",
      "singular",
      "sinopse",
      "sintonia",
      "sirene",
      "siri",
      "situado",
      "soberano",
      "sobra",
      "socorro",
      "sogro",
      "soja",
      "solda",
      "soletrar",
      "solteiro",
      "sombrio",
      "sonata",
      "sondar",
      "sonegar",
      "sonhador",
      "sono",
      "soprano",
      "soquete",
      "sorrir",
      "sorteio",
      "sossego",
      "sotaque",
      "soterrar",
      "sovado",
      "sozinho",
      "suavizar",
      "subida",
      "submerso",
      "subsolo",
      "subtrair",
      "sucata",
      "sucesso",
      "suco",
      "sudeste",
      "sufixo",
      "sugador",
      "sugerir",
      "sujeito",
      "sulfato",
      "sumir",
      "suor",
      "superior",
      "suplicar",
      "suposto",
      "suprimir",
      "surdina",
      "surfista",
      "surpresa",
      "surreal",
      "surtir",
      "suspiro",
      "sustento",
      "tabela",
      "tablete",
      "tabuada",
      "tacho",
      "tagarela",
      "talher",
      "talo",
      "talvez",
      "tamanho",
      "tamborim",
      "tampa",
      "tangente",
      "tanto",
      "tapar",
      "tapioca",
      "tardio",
      "tarefa",
      "tarja",
      "tarraxa",
      "tatuagem",
      "taurino",
      "taxativo",
      "taxista",
      "teatral",
      "tecer",
      "tecido",
      "teclado",
      "tedioso",
      "teia",
      "teimar",
      "telefone",
      "telhado",
      "tempero",
      "tenente",
      "tensor",
      "tentar",
      "termal",
      "terno",
      "terreno",
      "tese",
      "tesoura",
      "testado",
      "teto",
      "textura",
      "texugo",
      "tiara",
      "tigela",
      "tijolo",
      "timbrar",
      "timidez",
      "tingido",
      "tinteiro",
      "tiragem",
      "titular",
      "toalha",
      "tocha",
      "tolerar",
      "tolice",
      "tomada",
      "tomilho",
      "tonel",
      "tontura",
      "topete",
      "tora",
      "torcido",
      "torneio",
      "torque",
      "torrada",
      "torto",
      "tostar",
      "touca",
      "toupeira",
      "toxina",
      "trabalho",
      "tracejar",
      "tradutor",
      "trafegar",
      "trajeto",
      "trama",
      "trancar",
      "trapo",
      "traseiro",
      "tratador",
      "travar",
      "treino",
      "tremer",
      "trepidar",
      "trevo",
      "triagem",
      "tribo",
      "triciclo",
      "tridente",
      "trilogia",
      "trindade",
      "triplo",
      "triturar",
      "triunfal",
      "trocar",
      "trombeta",
      "trova",
      "trunfo",
      "truque",
      "tubular",
      "tucano",
      "tudo",
      "tulipa",
      "tupi",
      "turbo",
      "turma",
      "turquesa",
      "tutelar",
      "tutorial",
      "uivar",
      "umbigo",
      "unha",
      "unidade",
      "uniforme",
      "urologia",
      "urso",
      "urtiga",
      "urubu",
      "usado",
      "usina",
      "usufruir",
      "vacina",
      "vadiar",
      "vagaroso",
      "vaidoso",
      "vala",
      "valente",
      "validade",
      "valores",
      "vantagem",
      "vaqueiro",
      "varanda",
      "vareta",
      "varrer",
      "vascular",
      "vasilha",
      "vassoura",
      "vazar",
      "vazio",
      "veado",
      "vedar",
      "vegetar",
      "veicular",
      "veleiro",
      "velhice",
      "veludo",
      "vencedor",
      "vendaval",
      "venerar",
      "ventre",
      "verbal",
      "verdade",
      "vereador",
      "vergonha",
      "vermelho",
      "verniz",
      "versar",
      "vertente",
      "vespa",
      "vestido",
      "vetorial",
      "viaduto",
      "viagem",
      "viajar",
      "viatura",
      "vibrador",
      "videira",
      "vidraria",
      "viela",
      "viga",
      "vigente",
      "vigiar",
      "vigorar",
      "vilarejo",
      "vinco",
      "vinheta",
      "vinil",
      "violeta",
      "virada",
      "virtude",
      "visitar",
      "visto",
      "vitral",
      "viveiro",
      "vizinho",
      "voador",
      "voar",
      "vogal",
      "volante",
      "voleibol",
      "voltagem",
      "volumoso",
      "vontade",
      "vulto",
      "vuvuzela",
      "xadrez",
      "xarope",
      "xeque",
      "xeretar",
      "xerife",
      "xingar",
      "zangado",
      "zarpar",
      "zebu",
      "zelador",
      "zombar",
      "zoologia",
      "zumbido"
    ];
  }
});

// node_modules/bip39/src/wordlists/english.json
var require_english = __commonJS({
  "node_modules/bip39/src/wordlists/english.json"(exports2, module2) {
    module2.exports = [
      "abandon",
      "ability",
      "able",
      "about",
      "above",
      "absent",
      "absorb",
      "abstract",
      "absurd",
      "abuse",
      "access",
      "accident",
      "account",
      "accuse",
      "achieve",
      "acid",
      "acoustic",
      "acquire",
      "across",
      "act",
      "action",
      "actor",
      "actress",
      "actual",
      "adapt",
      "add",
      "addict",
      "address",
      "adjust",
      "admit",
      "adult",
      "advance",
      "advice",
      "aerobic",
      "affair",
      "afford",
      "afraid",
      "again",
      "age",
      "agent",
      "agree",
      "ahead",
      "aim",
      "air",
      "airport",
      "aisle",
      "alarm",
      "album",
      "alcohol",
      "alert",
      "alien",
      "all",
      "alley",
      "allow",
      "almost",
      "alone",
      "alpha",
      "already",
      "also",
      "alter",
      "always",
      "amateur",
      "amazing",
      "among",
      "amount",
      "amused",
      "analyst",
      "anchor",
      "ancient",
      "anger",
      "angle",
      "angry",
      "animal",
      "ankle",
      "announce",
      "annual",
      "another",
      "answer",
      "antenna",
      "antique",
      "anxiety",
      "any",
      "apart",
      "apology",
      "appear",
      "apple",
      "approve",
      "april",
      "arch",
      "arctic",
      "area",
      "arena",
      "argue",
      "arm",
      "armed",
      "armor",
      "army",
      "around",
      "arrange",
      "arrest",
      "arrive",
      "arrow",
      "art",
      "artefact",
      "artist",
      "artwork",
      "ask",
      "aspect",
      "assault",
      "asset",
      "assist",
      "assume",
      "asthma",
      "athlete",
      "atom",
      "attack",
      "attend",
      "attitude",
      "attract",
      "auction",
      "audit",
      "august",
      "aunt",
      "author",
      "auto",
      "autumn",
      "average",
      "avocado",
      "avoid",
      "awake",
      "aware",
      "away",
      "awesome",
      "awful",
      "awkward",
      "axis",
      "baby",
      "bachelor",
      "bacon",
      "badge",
      "bag",
      "balance",
      "balcony",
      "ball",
      "bamboo",
      "banana",
      "banner",
      "bar",
      "barely",
      "bargain",
      "barrel",
      "base",
      "basic",
      "basket",
      "battle",
      "beach",
      "bean",
      "beauty",
      "because",
      "become",
      "beef",
      "before",
      "begin",
      "behave",
      "behind",
      "believe",
      "below",
      "belt",
      "bench",
      "benefit",
      "best",
      "betray",
      "better",
      "between",
      "beyond",
      "bicycle",
      "bid",
      "bike",
      "bind",
      "biology",
      "bird",
      "birth",
      "bitter",
      "black",
      "blade",
      "blame",
      "blanket",
      "blast",
      "bleak",
      "bless",
      "blind",
      "blood",
      "blossom",
      "blouse",
      "blue",
      "blur",
      "blush",
      "board",
      "boat",
      "body",
      "boil",
      "bomb",
      "bone",
      "bonus",
      "book",
      "boost",
      "border",
      "boring",
      "borrow",
      "boss",
      "bottom",
      "bounce",
      "box",
      "boy",
      "bracket",
      "brain",
      "brand",
      "brass",
      "brave",
      "bread",
      "breeze",
      "brick",
      "bridge",
      "brief",
      "bright",
      "bring",
      "brisk",
      "broccoli",
      "broken",
      "bronze",
      "broom",
      "brother",
      "brown",
      "brush",
      "bubble",
      "buddy",
      "budget",
      "buffalo",
      "build",
      "bulb",
      "bulk",
      "bullet",
      "bundle",
      "bunker",
      "burden",
      "burger",
      "burst",
      "bus",
      "business",
      "busy",
      "butter",
      "buyer",
      "buzz",
      "cabbage",
      "cabin",
      "cable",
      "cactus",
      "cage",
      "cake",
      "call",
      "calm",
      "camera",
      "camp",
      "can",
      "canal",
      "cancel",
      "candy",
      "cannon",
      "canoe",
      "canvas",
      "canyon",
      "capable",
      "capital",
      "captain",
      "car",
      "carbon",
      "card",
      "cargo",
      "carpet",
      "carry",
      "cart",
      "case",
      "cash",
      "casino",
      "castle",
      "casual",
      "cat",
      "catalog",
      "catch",
      "category",
      "cattle",
      "caught",
      "cause",
      "caution",
      "cave",
      "ceiling",
      "celery",
      "cement",
      "census",
      "century",
      "cereal",
      "certain",
      "chair",
      "chalk",
      "champion",
      "change",
      "chaos",
      "chapter",
      "charge",
      "chase",
      "chat",
      "cheap",
      "check",
      "cheese",
      "chef",
      "cherry",
      "chest",
      "chicken",
      "chief",
      "child",
      "chimney",
      "choice",
      "choose",
      "chronic",
      "chuckle",
      "chunk",
      "churn",
      "cigar",
      "cinnamon",
      "circle",
      "citizen",
      "city",
      "civil",
      "claim",
      "clap",
      "clarify",
      "claw",
      "clay",
      "clean",
      "clerk",
      "clever",
      "click",
      "client",
      "cliff",
      "climb",
      "clinic",
      "clip",
      "clock",
      "clog",
      "close",
      "cloth",
      "cloud",
      "clown",
      "club",
      "clump",
      "cluster",
      "clutch",
      "coach",
      "coast",
      "coconut",
      "code",
      "coffee",
      "coil",
      "coin",
      "collect",
      "color",
      "column",
      "combine",
      "come",
      "comfort",
      "comic",
      "common",
      "company",
      "concert",
      "conduct",
      "confirm",
      "congress",
      "connect",
      "consider",
      "control",
      "convince",
      "cook",
      "cool",
      "copper",
      "copy",
      "coral",
      "core",
      "corn",
      "correct",
      "cost",
      "cotton",
      "couch",
      "country",
      "couple",
      "course",
      "cousin",
      "cover",
      "coyote",
      "crack",
      "cradle",
      "craft",
      "cram",
      "crane",
      "crash",
      "crater",
      "crawl",
      "crazy",
      "cream",
      "credit",
      "creek",
      "crew",
      "cricket",
      "crime",
      "crisp",
      "critic",
      "crop",
      "cross",
      "crouch",
      "crowd",
      "crucial",
      "cruel",
      "cruise",
      "crumble",
      "crunch",
      "crush",
      "cry",
      "crystal",
      "cube",
      "culture",
      "cup",
      "cupboard",
      "curious",
      "current",
      "curtain",
      "curve",
      "cushion",
      "custom",
      "cute",
      "cycle",
      "dad",
      "damage",
      "damp",
      "dance",
      "danger",
      "daring",
      "dash",
      "daughter",
      "dawn",
      "day",
      "deal",
      "debate",
      "debris",
      "decade",
      "december",
      "decide",
      "decline",
      "decorate",
      "decrease",
      "deer",
      "defense",
      "define",
      "defy",
      "degree",
      "delay",
      "deliver",
      "demand",
      "demise",
      "denial",
      "dentist",
      "deny",
      "depart",
      "depend",
      "deposit",
      "depth",
      "deputy",
      "derive",
      "describe",
      "desert",
      "design",
      "desk",
      "despair",
      "destroy",
      "detail",
      "detect",
      "develop",
      "device",
      "devote",
      "diagram",
      "dial",
      "diamond",
      "diary",
      "dice",
      "diesel",
      "diet",
      "differ",
      "digital",
      "dignity",
      "dilemma",
      "dinner",
      "dinosaur",
      "direct",
      "dirt",
      "disagree",
      "discover",
      "disease",
      "dish",
      "dismiss",
      "disorder",
      "display",
      "distance",
      "divert",
      "divide",
      "divorce",
      "dizzy",
      "doctor",
      "document",
      "dog",
      "doll",
      "dolphin",
      "domain",
      "donate",
      "donkey",
      "donor",
      "door",
      "dose",
      "double",
      "dove",
      "draft",
      "dragon",
      "drama",
      "drastic",
      "draw",
      "dream",
      "dress",
      "drift",
      "drill",
      "drink",
      "drip",
      "drive",
      "drop",
      "drum",
      "dry",
      "duck",
      "dumb",
      "dune",
      "during",
      "dust",
      "dutch",
      "duty",
      "dwarf",
      "dynamic",
      "eager",
      "eagle",
      "early",
      "earn",
      "earth",
      "easily",
      "east",
      "easy",
      "echo",
      "ecology",
      "economy",
      "edge",
      "edit",
      "educate",
      "effort",
      "egg",
      "eight",
      "either",
      "elbow",
      "elder",
      "electric",
      "elegant",
      "element",
      "elephant",
      "elevator",
      "elite",
      "else",
      "embark",
      "embody",
      "embrace",
      "emerge",
      "emotion",
      "employ",
      "empower",
      "empty",
      "enable",
      "enact",
      "end",
      "endless",
      "endorse",
      "enemy",
      "energy",
      "enforce",
      "engage",
      "engine",
      "enhance",
      "enjoy",
      "enlist",
      "enough",
      "enrich",
      "enroll",
      "ensure",
      "enter",
      "entire",
      "entry",
      "envelope",
      "episode",
      "equal",
      "equip",
      "era",
      "erase",
      "erode",
      "erosion",
      "error",
      "erupt",
      "escape",
      "essay",
      "essence",
      "estate",
      "eternal",
      "ethics",
      "evidence",
      "evil",
      "evoke",
      "evolve",
      "exact",
      "example",
      "excess",
      "exchange",
      "excite",
      "exclude",
      "excuse",
      "execute",
      "exercise",
      "exhaust",
      "exhibit",
      "exile",
      "exist",
      "exit",
      "exotic",
      "expand",
      "expect",
      "expire",
      "explain",
      "expose",
      "express",
      "extend",
      "extra",
      "eye",
      "eyebrow",
      "fabric",
      "face",
      "faculty",
      "fade",
      "faint",
      "faith",
      "fall",
      "false",
      "fame",
      "family",
      "famous",
      "fan",
      "fancy",
      "fantasy",
      "farm",
      "fashion",
      "fat",
      "fatal",
      "father",
      "fatigue",
      "fault",
      "favorite",
      "feature",
      "february",
      "federal",
      "fee",
      "feed",
      "feel",
      "female",
      "fence",
      "festival",
      "fetch",
      "fever",
      "few",
      "fiber",
      "fiction",
      "field",
      "figure",
      "file",
      "film",
      "filter",
      "final",
      "find",
      "fine",
      "finger",
      "finish",
      "fire",
      "firm",
      "first",
      "fiscal",
      "fish",
      "fit",
      "fitness",
      "fix",
      "flag",
      "flame",
      "flash",
      "flat",
      "flavor",
      "flee",
      "flight",
      "flip",
      "float",
      "flock",
      "floor",
      "flower",
      "fluid",
      "flush",
      "fly",
      "foam",
      "focus",
      "fog",
      "foil",
      "fold",
      "follow",
      "food",
      "foot",
      "force",
      "forest",
      "forget",
      "fork",
      "fortune",
      "forum",
      "forward",
      "fossil",
      "foster",
      "found",
      "fox",
      "fragile",
      "frame",
      "frequent",
      "fresh",
      "friend",
      "fringe",
      "frog",
      "front",
      "frost",
      "frown",
      "frozen",
      "fruit",
      "fuel",
      "fun",
      "funny",
      "furnace",
      "fury",
      "future",
      "gadget",
      "gain",
      "galaxy",
      "gallery",
      "game",
      "gap",
      "garage",
      "garbage",
      "garden",
      "garlic",
      "garment",
      "gas",
      "gasp",
      "gate",
      "gather",
      "gauge",
      "gaze",
      "general",
      "genius",
      "genre",
      "gentle",
      "genuine",
      "gesture",
      "ghost",
      "giant",
      "gift",
      "giggle",
      "ginger",
      "giraffe",
      "girl",
      "give",
      "glad",
      "glance",
      "glare",
      "glass",
      "glide",
      "glimpse",
      "globe",
      "gloom",
      "glory",
      "glove",
      "glow",
      "glue",
      "goat",
      "goddess",
      "gold",
      "good",
      "goose",
      "gorilla",
      "gospel",
      "gossip",
      "govern",
      "gown",
      "grab",
      "grace",
      "grain",
      "grant",
      "grape",
      "grass",
      "gravity",
      "great",
      "green",
      "grid",
      "grief",
      "grit",
      "grocery",
      "group",
      "grow",
      "grunt",
      "guard",
      "guess",
      "guide",
      "guilt",
      "guitar",
      "gun",
      "gym",
      "habit",
      "hair",
      "half",
      "hammer",
      "hamster",
      "hand",
      "happy",
      "harbor",
      "hard",
      "harsh",
      "harvest",
      "hat",
      "have",
      "hawk",
      "hazard",
      "head",
      "health",
      "heart",
      "heavy",
      "hedgehog",
      "height",
      "hello",
      "helmet",
      "help",
      "hen",
      "hero",
      "hidden",
      "high",
      "hill",
      "hint",
      "hip",
      "hire",
      "history",
      "hobby",
      "hockey",
      "hold",
      "hole",
      "holiday",
      "hollow",
      "home",
      "honey",
      "hood",
      "hope",
      "horn",
      "horror",
      "horse",
      "hospital",
      "host",
      "hotel",
      "hour",
      "hover",
      "hub",
      "huge",
      "human",
      "humble",
      "humor",
      "hundred",
      "hungry",
      "hunt",
      "hurdle",
      "hurry",
      "hurt",
      "husband",
      "hybrid",
      "ice",
      "icon",
      "idea",
      "identify",
      "idle",
      "ignore",
      "ill",
      "illegal",
      "illness",
      "image",
      "imitate",
      "immense",
      "immune",
      "impact",
      "impose",
      "improve",
      "impulse",
      "inch",
      "include",
      "income",
      "increase",
      "index",
      "indicate",
      "indoor",
      "industry",
      "infant",
      "inflict",
      "inform",
      "inhale",
      "inherit",
      "initial",
      "inject",
      "injury",
      "inmate",
      "inner",
      "innocent",
      "input",
      "inquiry",
      "insane",
      "insect",
      "inside",
      "inspire",
      "install",
      "intact",
      "interest",
      "into",
      "invest",
      "invite",
      "involve",
      "iron",
      "island",
      "isolate",
      "issue",
      "item",
      "ivory",
      "jacket",
      "jaguar",
      "jar",
      "jazz",
      "jealous",
      "jeans",
      "jelly",
      "jewel",
      "job",
      "join",
      "joke",
      "journey",
      "joy",
      "judge",
      "juice",
      "jump",
      "jungle",
      "junior",
      "junk",
      "just",
      "kangaroo",
      "keen",
      "keep",
      "ketchup",
      "key",
      "kick",
      "kid",
      "kidney",
      "kind",
      "kingdom",
      "kiss",
      "kit",
      "kitchen",
      "kite",
      "kitten",
      "kiwi",
      "knee",
      "knife",
      "knock",
      "know",
      "lab",
      "label",
      "labor",
      "ladder",
      "lady",
      "lake",
      "lamp",
      "language",
      "laptop",
      "large",
      "later",
      "latin",
      "laugh",
      "laundry",
      "lava",
      "law",
      "lawn",
      "lawsuit",
      "layer",
      "lazy",
      "leader",
      "leaf",
      "learn",
      "leave",
      "lecture",
      "left",
      "leg",
      "legal",
      "legend",
      "leisure",
      "lemon",
      "lend",
      "length",
      "lens",
      "leopard",
      "lesson",
      "letter",
      "level",
      "liar",
      "liberty",
      "library",
      "license",
      "life",
      "lift",
      "light",
      "like",
      "limb",
      "limit",
      "link",
      "lion",
      "liquid",
      "list",
      "little",
      "live",
      "lizard",
      "load",
      "loan",
      "lobster",
      "local",
      "lock",
      "logic",
      "lonely",
      "long",
      "loop",
      "lottery",
      "loud",
      "lounge",
      "love",
      "loyal",
      "lucky",
      "luggage",
      "lumber",
      "lunar",
      "lunch",
      "luxury",
      "lyrics",
      "machine",
      "mad",
      "magic",
      "magnet",
      "maid",
      "mail",
      "main",
      "major",
      "make",
      "mammal",
      "man",
      "manage",
      "mandate",
      "mango",
      "mansion",
      "manual",
      "maple",
      "marble",
      "march",
      "margin",
      "marine",
      "market",
      "marriage",
      "mask",
      "mass",
      "master",
      "match",
      "material",
      "math",
      "matrix",
      "matter",
      "maximum",
      "maze",
      "meadow",
      "mean",
      "measure",
      "meat",
      "mechanic",
      "medal",
      "media",
      "melody",
      "melt",
      "member",
      "memory",
      "mention",
      "menu",
      "mercy",
      "merge",
      "merit",
      "merry",
      "mesh",
      "message",
      "metal",
      "method",
      "middle",
      "midnight",
      "milk",
      "million",
      "mimic",
      "mind",
      "minimum",
      "minor",
      "minute",
      "miracle",
      "mirror",
      "misery",
      "miss",
      "mistake",
      "mix",
      "mixed",
      "mixture",
      "mobile",
      "model",
      "modify",
      "mom",
      "moment",
      "monitor",
      "monkey",
      "monster",
      "month",
      "moon",
      "moral",
      "more",
      "morning",
      "mosquito",
      "mother",
      "motion",
      "motor",
      "mountain",
      "mouse",
      "move",
      "movie",
      "much",
      "muffin",
      "mule",
      "multiply",
      "muscle",
      "museum",
      "mushroom",
      "music",
      "must",
      "mutual",
      "myself",
      "mystery",
      "myth",
      "naive",
      "name",
      "napkin",
      "narrow",
      "nasty",
      "nation",
      "nature",
      "near",
      "neck",
      "need",
      "negative",
      "neglect",
      "neither",
      "nephew",
      "nerve",
      "nest",
      "net",
      "network",
      "neutral",
      "never",
      "news",
      "next",
      "nice",
      "night",
      "noble",
      "noise",
      "nominee",
      "noodle",
      "normal",
      "north",
      "nose",
      "notable",
      "note",
      "nothing",
      "notice",
      "novel",
      "now",
      "nuclear",
      "number",
      "nurse",
      "nut",
      "oak",
      "obey",
      "object",
      "oblige",
      "obscure",
      "observe",
      "obtain",
      "obvious",
      "occur",
      "ocean",
      "october",
      "odor",
      "off",
      "offer",
      "office",
      "often",
      "oil",
      "okay",
      "old",
      "olive",
      "olympic",
      "omit",
      "once",
      "one",
      "onion",
      "online",
      "only",
      "open",
      "opera",
      "opinion",
      "oppose",
      "option",
      "orange",
      "orbit",
      "orchard",
      "order",
      "ordinary",
      "organ",
      "orient",
      "original",
      "orphan",
      "ostrich",
      "other",
      "outdoor",
      "outer",
      "output",
      "outside",
      "oval",
      "oven",
      "over",
      "own",
      "owner",
      "oxygen",
      "oyster",
      "ozone",
      "pact",
      "paddle",
      "page",
      "pair",
      "palace",
      "palm",
      "panda",
      "panel",
      "panic",
      "panther",
      "paper",
      "parade",
      "parent",
      "park",
      "parrot",
      "party",
      "pass",
      "patch",
      "path",
      "patient",
      "patrol",
      "pattern",
      "pause",
      "pave",
      "payment",
      "peace",
      "peanut",
      "pear",
      "peasant",
      "pelican",
      "pen",
      "penalty",
      "pencil",
      "people",
      "pepper",
      "perfect",
      "permit",
      "person",
      "pet",
      "phone",
      "photo",
      "phrase",
      "physical",
      "piano",
      "picnic",
      "picture",
      "piece",
      "pig",
      "pigeon",
      "pill",
      "pilot",
      "pink",
      "pioneer",
      "pipe",
      "pistol",
      "pitch",
      "pizza",
      "place",
      "planet",
      "plastic",
      "plate",
      "play",
      "please",
      "pledge",
      "pluck",
      "plug",
      "plunge",
      "poem",
      "poet",
      "point",
      "polar",
      "pole",
      "police",
      "pond",
      "pony",
      "pool",
      "popular",
      "portion",
      "position",
      "possible",
      "post",
      "potato",
      "pottery",
      "poverty",
      "powder",
      "power",
      "practice",
      "praise",
      "predict",
      "prefer",
      "prepare",
      "present",
      "pretty",
      "prevent",
      "price",
      "pride",
      "primary",
      "print",
      "priority",
      "prison",
      "private",
      "prize",
      "problem",
      "process",
      "produce",
      "profit",
      "program",
      "project",
      "promote",
      "proof",
      "property",
      "prosper",
      "protect",
      "proud",
      "provide",
      "public",
      "pudding",
      "pull",
      "pulp",
      "pulse",
      "pumpkin",
      "punch",
      "pupil",
      "puppy",
      "purchase",
      "purity",
      "purpose",
      "purse",
      "push",
      "put",
      "puzzle",
      "pyramid",
      "quality",
      "quantum",
      "quarter",
      "question",
      "quick",
      "quit",
      "quiz",
      "quote",
      "rabbit",
      "raccoon",
      "race",
      "rack",
      "radar",
      "radio",
      "rail",
      "rain",
      "raise",
      "rally",
      "ramp",
      "ranch",
      "random",
      "range",
      "rapid",
      "rare",
      "rate",
      "rather",
      "raven",
      "raw",
      "razor",
      "ready",
      "real",
      "reason",
      "rebel",
      "rebuild",
      "recall",
      "receive",
      "recipe",
      "record",
      "recycle",
      "reduce",
      "reflect",
      "reform",
      "refuse",
      "region",
      "regret",
      "regular",
      "reject",
      "relax",
      "release",
      "relief",
      "rely",
      "remain",
      "remember",
      "remind",
      "remove",
      "render",
      "renew",
      "rent",
      "reopen",
      "repair",
      "repeat",
      "replace",
      "report",
      "require",
      "rescue",
      "resemble",
      "resist",
      "resource",
      "response",
      "result",
      "retire",
      "retreat",
      "return",
      "reunion",
      "reveal",
      "review",
      "reward",
      "rhythm",
      "rib",
      "ribbon",
      "rice",
      "rich",
      "ride",
      "ridge",
      "rifle",
      "right",
      "rigid",
      "ring",
      "riot",
      "ripple",
      "risk",
      "ritual",
      "rival",
      "river",
      "road",
      "roast",
      "robot",
      "robust",
      "rocket",
      "romance",
      "roof",
      "rookie",
      "room",
      "rose",
      "rotate",
      "rough",
      "round",
      "route",
      "royal",
      "rubber",
      "rude",
      "rug",
      "rule",
      "run",
      "runway",
      "rural",
      "sad",
      "saddle",
      "sadness",
      "safe",
      "sail",
      "salad",
      "salmon",
      "salon",
      "salt",
      "salute",
      "same",
      "sample",
      "sand",
      "satisfy",
      "satoshi",
      "sauce",
      "sausage",
      "save",
      "say",
      "scale",
      "scan",
      "scare",
      "scatter",
      "scene",
      "scheme",
      "school",
      "science",
      "scissors",
      "scorpion",
      "scout",
      "scrap",
      "screen",
      "script",
      "scrub",
      "sea",
      "search",
      "season",
      "seat",
      "second",
      "secret",
      "section",
      "security",
      "seed",
      "seek",
      "segment",
      "select",
      "sell",
      "seminar",
      "senior",
      "sense",
      "sentence",
      "series",
      "service",
      "session",
      "settle",
      "setup",
      "seven",
      "shadow",
      "shaft",
      "shallow",
      "share",
      "shed",
      "shell",
      "sheriff",
      "shield",
      "shift",
      "shine",
      "ship",
      "shiver",
      "shock",
      "shoe",
      "shoot",
      "shop",
      "short",
      "shoulder",
      "shove",
      "shrimp",
      "shrug",
      "shuffle",
      "shy",
      "sibling",
      "sick",
      "side",
      "siege",
      "sight",
      "sign",
      "silent",
      "silk",
      "silly",
      "silver",
      "similar",
      "simple",
      "since",
      "sing",
      "siren",
      "sister",
      "situate",
      "six",
      "size",
      "skate",
      "sketch",
      "ski",
      "skill",
      "skin",
      "skirt",
      "skull",
      "slab",
      "slam",
      "sleep",
      "slender",
      "slice",
      "slide",
      "slight",
      "slim",
      "slogan",
      "slot",
      "slow",
      "slush",
      "small",
      "smart",
      "smile",
      "smoke",
      "smooth",
      "snack",
      "snake",
      "snap",
      "sniff",
      "snow",
      "soap",
      "soccer",
      "social",
      "sock",
      "soda",
      "soft",
      "solar",
      "soldier",
      "solid",
      "solution",
      "solve",
      "someone",
      "song",
      "soon",
      "sorry",
      "sort",
      "soul",
      "sound",
      "soup",
      "source",
      "south",
      "space",
      "spare",
      "spatial",
      "spawn",
      "speak",
      "special",
      "speed",
      "spell",
      "spend",
      "sphere",
      "spice",
      "spider",
      "spike",
      "spin",
      "spirit",
      "split",
      "spoil",
      "sponsor",
      "spoon",
      "sport",
      "spot",
      "spray",
      "spread",
      "spring",
      "spy",
      "square",
      "squeeze",
      "squirrel",
      "stable",
      "stadium",
      "staff",
      "stage",
      "stairs",
      "stamp",
      "stand",
      "start",
      "state",
      "stay",
      "steak",
      "steel",
      "stem",
      "step",
      "stereo",
      "stick",
      "still",
      "sting",
      "stock",
      "stomach",
      "stone",
      "stool",
      "story",
      "stove",
      "strategy",
      "street",
      "strike",
      "strong",
      "struggle",
      "student",
      "stuff",
      "stumble",
      "style",
      "subject",
      "submit",
      "subway",
      "success",
      "such",
      "sudden",
      "suffer",
      "sugar",
      "suggest",
      "suit",
      "summer",
      "sun",
      "sunny",
      "sunset",
      "super",
      "supply",
      "supreme",
      "sure",
      "surface",
      "surge",
      "surprise",
      "surround",
      "survey",
      "suspect",
      "sustain",
      "swallow",
      "swamp",
      "swap",
      "swarm",
      "swear",
      "sweet",
      "swift",
      "swim",
      "swing",
      "switch",
      "sword",
      "symbol",
      "symptom",
      "syrup",
      "system",
      "table",
      "tackle",
      "tag",
      "tail",
      "talent",
      "talk",
      "tank",
      "tape",
      "target",
      "task",
      "taste",
      "tattoo",
      "taxi",
      "teach",
      "team",
      "tell",
      "ten",
      "tenant",
      "tennis",
      "tent",
      "term",
      "test",
      "text",
      "thank",
      "that",
      "theme",
      "then",
      "theory",
      "there",
      "they",
      "thing",
      "this",
      "thought",
      "three",
      "thrive",
      "throw",
      "thumb",
      "thunder",
      "ticket",
      "tide",
      "tiger",
      "tilt",
      "timber",
      "time",
      "tiny",
      "tip",
      "tired",
      "tissue",
      "title",
      "toast",
      "tobacco",
      "today",
      "toddler",
      "toe",
      "together",
      "toilet",
      "token",
      "tomato",
      "tomorrow",
      "tone",
      "tongue",
      "tonight",
      "tool",
      "tooth",
      "top",
      "topic",
      "topple",
      "torch",
      "tornado",
      "tortoise",
      "toss",
      "total",
      "tourist",
      "toward",
      "tower",
      "town",
      "toy",
      "track",
      "trade",
      "traffic",
      "tragic",
      "train",
      "transfer",
      "trap",
      "trash",
      "travel",
      "tray",
      "treat",
      "tree",
      "trend",
      "trial",
      "tribe",
      "trick",
      "trigger",
      "trim",
      "trip",
      "trophy",
      "trouble",
      "truck",
      "true",
      "truly",
      "trumpet",
      "trust",
      "truth",
      "try",
      "tube",
      "tuition",
      "tumble",
      "tuna",
      "tunnel",
      "turkey",
      "turn",
      "turtle",
      "twelve",
      "twenty",
      "twice",
      "twin",
      "twist",
      "two",
      "type",
      "typical",
      "ugly",
      "umbrella",
      "unable",
      "unaware",
      "uncle",
      "uncover",
      "under",
      "undo",
      "unfair",
      "unfold",
      "unhappy",
      "uniform",
      "unique",
      "unit",
      "universe",
      "unknown",
      "unlock",
      "until",
      "unusual",
      "unveil",
      "update",
      "upgrade",
      "uphold",
      "upon",
      "upper",
      "upset",
      "urban",
      "urge",
      "usage",
      "use",
      "used",
      "useful",
      "useless",
      "usual",
      "utility",
      "vacant",
      "vacuum",
      "vague",
      "valid",
      "valley",
      "valve",
      "van",
      "vanish",
      "vapor",
      "various",
      "vast",
      "vault",
      "vehicle",
      "velvet",
      "vendor",
      "venture",
      "venue",
      "verb",
      "verify",
      "version",
      "very",
      "vessel",
      "veteran",
      "viable",
      "vibrant",
      "vicious",
      "victory",
      "video",
      "view",
      "village",
      "vintage",
      "violin",
      "virtual",
      "virus",
      "visa",
      "visit",
      "visual",
      "vital",
      "vivid",
      "vocal",
      "voice",
      "void",
      "volcano",
      "volume",
      "vote",
      "voyage",
      "wage",
      "wagon",
      "wait",
      "walk",
      "wall",
      "walnut",
      "want",
      "warfare",
      "warm",
      "warrior",
      "wash",
      "wasp",
      "waste",
      "water",
      "wave",
      "way",
      "wealth",
      "weapon",
      "wear",
      "weasel",
      "weather",
      "web",
      "wedding",
      "weekend",
      "weird",
      "welcome",
      "west",
      "wet",
      "whale",
      "what",
      "wheat",
      "wheel",
      "when",
      "where",
      "whip",
      "whisper",
      "wide",
      "width",
      "wife",
      "wild",
      "will",
      "win",
      "window",
      "wine",
      "wing",
      "wink",
      "winner",
      "winter",
      "wire",
      "wisdom",
      "wise",
      "wish",
      "witness",
      "wolf",
      "woman",
      "wonder",
      "wood",
      "wool",
      "word",
      "work",
      "world",
      "worry",
      "worth",
      "wrap",
      "wreck",
      "wrestle",
      "wrist",
      "write",
      "wrong",
      "yard",
      "year",
      "yellow",
      "you",
      "young",
      "youth",
      "zebra",
      "zero",
      "zone",
      "zoo"
    ];
  }
});

// node_modules/bip39/src/_wordlists.js
var require_wordlists = __commonJS({
  "node_modules/bip39/src/_wordlists.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var wordlists = {};
    exports2.wordlists = wordlists;
    var _default;
    exports2._default = _default;
    try {
      exports2._default = _default = require_czech();
      wordlists.czech = _default;
    } catch (err) {
    }
    try {
      exports2._default = _default = require_chinese_simplified();
      wordlists.chinese_simplified = _default;
    } catch (err) {
    }
    try {
      exports2._default = _default = require_chinese_traditional();
      wordlists.chinese_traditional = _default;
    } catch (err) {
    }
    try {
      exports2._default = _default = require_korean();
      wordlists.korean = _default;
    } catch (err) {
    }
    try {
      exports2._default = _default = require_french();
      wordlists.french = _default;
    } catch (err) {
    }
    try {
      exports2._default = _default = require_italian();
      wordlists.italian = _default;
    } catch (err) {
    }
    try {
      exports2._default = _default = require_spanish();
      wordlists.spanish = _default;
    } catch (err) {
    }
    try {
      exports2._default = _default = require_japanese();
      wordlists.japanese = _default;
      wordlists.JA = _default;
    } catch (err) {
    }
    try {
      exports2._default = _default = require_portuguese();
      wordlists.portuguese = _default;
    } catch (err) {
    }
    try {
      exports2._default = _default = require_english();
      wordlists.english = _default;
      wordlists.EN = _default;
    } catch (err) {
    }
  }
});

// node_modules/bip39/src/index.js
var require_src = __commonJS({
  "node_modules/bip39/src/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var sha256_1 = require_sha256();
    var sha512_1 = require_sha512();
    var pbkdf2_1 = require_pbkdf2();
    var utils_1 = require_utils();
    var _wordlists_1 = require_wordlists();
    var DEFAULT_WORDLIST = _wordlists_1._default;
    var INVALID_MNEMONIC = "Invalid mnemonic";
    var INVALID_ENTROPY = "Invalid entropy";
    var INVALID_CHECKSUM = "Invalid mnemonic checksum";
    var WORDLIST_REQUIRED = "A wordlist is required but a default could not be found.\nPlease pass a 2048 word array explicitly.";
    function normalize(str) {
      return (str || "").normalize("NFKD");
    }
    function lpad(str, padString, length11) {
      while (str.length < length11) {
        str = padString + str;
      }
      return str;
    }
    function binaryToByte(bin) {
      return parseInt(bin, 2);
    }
    function bytesToBinary(bytes) {
      return bytes.map((x) => lpad(x.toString(2), "0", 8)).join("");
    }
    function deriveChecksumBits(entropyBuffer) {
      const ENT = entropyBuffer.length * 8;
      const CS = ENT / 32;
      const hash = sha256_1.sha256(Uint8Array.from(entropyBuffer));
      return bytesToBinary(Array.from(hash)).slice(0, CS);
    }
    function salt(password) {
      return "mnemonic" + (password || "");
    }
    function mnemonicToSeedSync3(mnemonic, password) {
      const mnemonicBuffer = Uint8Array.from(Buffer.from(normalize(mnemonic), "utf8"));
      const saltBuffer = Uint8Array.from(Buffer.from(salt(normalize(password)), "utf8"));
      const res = pbkdf2_1.pbkdf2(sha512_1.sha512, mnemonicBuffer, saltBuffer, {
        c: 2048,
        dkLen: 64
      });
      return Buffer.from(res);
    }
    exports2.mnemonicToSeedSync = mnemonicToSeedSync3;
    function mnemonicToSeed2(mnemonic, password) {
      const mnemonicBuffer = Uint8Array.from(Buffer.from(normalize(mnemonic), "utf8"));
      const saltBuffer = Uint8Array.from(Buffer.from(salt(normalize(password)), "utf8"));
      return pbkdf2_1.pbkdf2Async(sha512_1.sha512, mnemonicBuffer, saltBuffer, {
        c: 2048,
        dkLen: 64
      }).then((res) => Buffer.from(res));
    }
    exports2.mnemonicToSeed = mnemonicToSeed2;
    function mnemonicToEntropy2(mnemonic, wordlist) {
      wordlist = wordlist || DEFAULT_WORDLIST;
      if (!wordlist) {
        throw new Error(WORDLIST_REQUIRED);
      }
      const words = normalize(mnemonic).split(" ");
      if (words.length % 3 !== 0) {
        throw new Error(INVALID_MNEMONIC);
      }
      const bits = words.map((word) => {
        const index = wordlist.indexOf(word);
        if (index === -1) {
          throw new Error(INVALID_MNEMONIC);
        }
        return lpad(index.toString(2), "0", 11);
      }).join("");
      const dividerIndex = Math.floor(bits.length / 33) * 32;
      const entropyBits = bits.slice(0, dividerIndex);
      const checksumBits = bits.slice(dividerIndex);
      const entropyBytes = entropyBits.match(/(.{1,8})/g).map(binaryToByte);
      if (entropyBytes.length < 16) {
        throw new Error(INVALID_ENTROPY);
      }
      if (entropyBytes.length > 32) {
        throw new Error(INVALID_ENTROPY);
      }
      if (entropyBytes.length % 4 !== 0) {
        throw new Error(INVALID_ENTROPY);
      }
      const entropy = Buffer.from(entropyBytes);
      const newChecksum = deriveChecksumBits(entropy);
      if (newChecksum !== checksumBits) {
        throw new Error(INVALID_CHECKSUM);
      }
      return entropy.toString("hex");
    }
    exports2.mnemonicToEntropy = mnemonicToEntropy2;
    function entropyToMnemonic2(entropy, wordlist) {
      if (!Buffer.isBuffer(entropy)) {
        entropy = Buffer.from(entropy, "hex");
      }
      wordlist = wordlist || DEFAULT_WORDLIST;
      if (!wordlist) {
        throw new Error(WORDLIST_REQUIRED);
      }
      if (entropy.length < 16) {
        throw new TypeError(INVALID_ENTROPY);
      }
      if (entropy.length > 32) {
        throw new TypeError(INVALID_ENTROPY);
      }
      if (entropy.length % 4 !== 0) {
        throw new TypeError(INVALID_ENTROPY);
      }
      const entropyBits = bytesToBinary(Array.from(entropy));
      const checksumBits = deriveChecksumBits(entropy);
      const bits = entropyBits + checksumBits;
      const chunks = bits.match(/(.{1,11})/g);
      const words = chunks.map((binary) => {
        const index = binaryToByte(binary);
        return wordlist[index];
      });
      return wordlist[0] === "\u3042\u3044\u3053\u304F\u3057\u3093" ? words.join("\u3000") : words.join(" ");
    }
    exports2.entropyToMnemonic = entropyToMnemonic2;
    function generateMnemonic3(strength, rng2, wordlist) {
      strength = strength || 128;
      if (strength % 32 !== 0) {
        throw new TypeError(INVALID_ENTROPY);
      }
      rng2 = rng2 || ((size) => Buffer.from(utils_1.randomBytes(size)));
      return entropyToMnemonic2(rng2(strength / 8), wordlist);
    }
    exports2.generateMnemonic = generateMnemonic3;
    function validateMnemonic2(mnemonic, wordlist) {
      try {
        mnemonicToEntropy2(mnemonic, wordlist);
      } catch (e) {
        return false;
      }
      return true;
    }
    exports2.validateMnemonic = validateMnemonic2;
    function setDefaultWordlist(language) {
      const result = _wordlists_1.wordlists[language];
      if (result) {
        DEFAULT_WORDLIST = result;
      } else {
        throw new Error('Could not find wordlist for language "' + language + '"');
      }
    }
    exports2.setDefaultWordlist = setDefaultWordlist;
    function getDefaultWordlist() {
      if (!DEFAULT_WORDLIST) {
        throw new Error("No Default Wordlist set");
      }
      return Object.keys(_wordlists_1.wordlists).filter((lang) => {
        if (lang === "JA" || lang === "EN") {
          return false;
        }
        return _wordlists_1.wordlists[lang].every((word, index) => word === DEFAULT_WORDLIST[index]);
      })[0];
    }
    exports2.getDefaultWordlist = getDefaultWordlist;
    var _wordlists_2 = require_wordlists();
    exports2.wordlists = _wordlists_2.wordlists;
  }
});

// (disabled):crypto
var require_crypto2 = __commonJS({
  "(disabled):crypto"() {
  }
});

// (disabled):node_modules/buffer/index.js
var require_buffer = __commonJS({
  "(disabled):node_modules/buffer/index.js"() {
  }
});

// node_modules/js-md5/src/md5.js
var require_md5 = __commonJS({
  "node_modules/js-md5/src/md5.js"(exports2, module2) {
    (function() {
      "use strict";
      var INPUT_ERROR = "input is invalid type";
      var FINALIZE_ERROR = "finalize already called";
      var WINDOW = typeof window === "object";
      var root = WINDOW ? window : {};
      if (root.JS_MD5_NO_WINDOW) {
        WINDOW = false;
      }
      var WEB_WORKER = !WINDOW && typeof self === "object";
      var NODE_JS = !root.JS_MD5_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS) {
        root = global;
      } else if (WEB_WORKER) {
        root = self;
      }
      var COMMON_JS = !root.JS_MD5_NO_COMMON_JS && typeof module2 === "object" && module2.exports;
      var AMD = typeof define === "function" && define.amd;
      var ARRAY_BUFFER = !root.JS_MD5_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
      var HEX_CHARS = "0123456789abcdef".split("");
      var EXTRA = [128, 32768, 8388608, -2147483648];
      var SHIFT = [0, 8, 16, 24];
      var OUTPUT_TYPES = ["hex", "array", "digest", "buffer", "arrayBuffer", "base64"];
      var BASE64_ENCODE_CHAR = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
      var blocks = [], buffer8;
      if (ARRAY_BUFFER) {
        var buffer2 = new ArrayBuffer(68);
        buffer8 = new Uint8Array(buffer2);
        blocks = new Uint32Array(buffer2);
      }
      var isArray = Array.isArray;
      if (root.JS_MD5_NO_NODE_JS || !isArray) {
        isArray = function(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        };
      }
      var isView = ArrayBuffer.isView;
      if (ARRAY_BUFFER && (root.JS_MD5_NO_ARRAY_BUFFER_IS_VIEW || !isView)) {
        isView = function(obj) {
          return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
        };
      }
      var formatMessage = function(message) {
        var type = typeof message;
        if (type === "string") {
          return [message, true];
        }
        if (type !== "object" || message === null) {
          throw new Error(INPUT_ERROR);
        }
        if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
          return [new Uint8Array(message), false];
        }
        if (!isArray(message) && !isView(message)) {
          throw new Error(INPUT_ERROR);
        }
        return [message, false];
      };
      var createOutputMethod = function(outputType) {
        return function(message) {
          return new Md5(true).update(message)[outputType]();
        };
      };
      var createMethod = function() {
        var method = createOutputMethod("hex");
        if (NODE_JS) {
          method = nodeWrap(method);
        }
        method.create = function() {
          return new Md5();
        };
        method.update = function(message) {
          return method.create().update(message);
        };
        for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
          var type = OUTPUT_TYPES[i];
          method[type] = createOutputMethod(type);
        }
        return method;
      };
      var nodeWrap = function(method) {
        var crypto3 = require_crypto2();
        var Buffer3 = require_buffer().Buffer;
        var bufferFrom;
        if (Buffer3.from && !root.JS_MD5_NO_BUFFER_FROM) {
          bufferFrom = Buffer3.from;
        } else {
          bufferFrom = function(message) {
            return new Buffer3(message);
          };
        }
        var nodeMethod = function(message) {
          if (typeof message === "string") {
            return crypto3.createHash("md5").update(message, "utf8").digest("hex");
          } else {
            if (message === null || message === void 0) {
              throw new Error(INPUT_ERROR);
            } else if (message.constructor === ArrayBuffer) {
              message = new Uint8Array(message);
            }
          }
          if (isArray(message) || isView(message) || message.constructor === Buffer3) {
            return crypto3.createHash("md5").update(bufferFrom(message)).digest("hex");
          } else {
            return method(message);
          }
        };
        return nodeMethod;
      };
      var createHmacOutputMethod = function(outputType) {
        return function(key, message) {
          return new HmacMd5(key, true).update(message)[outputType]();
        };
      };
      var createHmacMethod = function() {
        var method = createHmacOutputMethod("hex");
        method.create = function(key) {
          return new HmacMd5(key);
        };
        method.update = function(key, message) {
          return method.create(key).update(message);
        };
        for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
          var type = OUTPUT_TYPES[i];
          method[type] = createHmacOutputMethod(type);
        }
        return method;
      };
      function Md5(sharedMemory) {
        if (sharedMemory) {
          blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
          this.blocks = blocks;
          this.buffer8 = buffer8;
        } else {
          if (ARRAY_BUFFER) {
            var buffer3 = new ArrayBuffer(68);
            this.buffer8 = new Uint8Array(buffer3);
            this.blocks = new Uint32Array(buffer3);
          } else {
            this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
          }
        }
        this.h0 = this.h1 = this.h2 = this.h3 = this.start = this.bytes = this.hBytes = 0;
        this.finalized = this.hashed = false;
        this.first = true;
      }
      Md5.prototype.update = function(message) {
        if (this.finalized) {
          throw new Error(FINALIZE_ERROR);
        }
        var result = formatMessage(message);
        message = result[0];
        var isString = result[1];
        var code12, index = 0, i, length11 = message.length, blocks2 = this.blocks;
        var buffer82 = this.buffer8;
        while (index < length11) {
          if (this.hashed) {
            this.hashed = false;
            blocks2[0] = blocks2[16];
            blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
          }
          if (isString) {
            if (ARRAY_BUFFER) {
              for (i = this.start; index < length11 && i < 64; ++index) {
                code12 = message.charCodeAt(index);
                if (code12 < 128) {
                  buffer82[i++] = code12;
                } else if (code12 < 2048) {
                  buffer82[i++] = 192 | code12 >>> 6;
                  buffer82[i++] = 128 | code12 & 63;
                } else if (code12 < 55296 || code12 >= 57344) {
                  buffer82[i++] = 224 | code12 >>> 12;
                  buffer82[i++] = 128 | code12 >>> 6 & 63;
                  buffer82[i++] = 128 | code12 & 63;
                } else {
                  code12 = 65536 + ((code12 & 1023) << 10 | message.charCodeAt(++index) & 1023);
                  buffer82[i++] = 240 | code12 >>> 18;
                  buffer82[i++] = 128 | code12 >>> 12 & 63;
                  buffer82[i++] = 128 | code12 >>> 6 & 63;
                  buffer82[i++] = 128 | code12 & 63;
                }
              }
            } else {
              for (i = this.start; index < length11 && i < 64; ++index) {
                code12 = message.charCodeAt(index);
                if (code12 < 128) {
                  blocks2[i >>> 2] |= code12 << SHIFT[i++ & 3];
                } else if (code12 < 2048) {
                  blocks2[i >>> 2] |= (192 | code12 >>> 6) << SHIFT[i++ & 3];
                  blocks2[i >>> 2] |= (128 | code12 & 63) << SHIFT[i++ & 3];
                } else if (code12 < 55296 || code12 >= 57344) {
                  blocks2[i >>> 2] |= (224 | code12 >>> 12) << SHIFT[i++ & 3];
                  blocks2[i >>> 2] |= (128 | code12 >>> 6 & 63) << SHIFT[i++ & 3];
                  blocks2[i >>> 2] |= (128 | code12 & 63) << SHIFT[i++ & 3];
                } else {
                  code12 = 65536 + ((code12 & 1023) << 10 | message.charCodeAt(++index) & 1023);
                  blocks2[i >>> 2] |= (240 | code12 >>> 18) << SHIFT[i++ & 3];
                  blocks2[i >>> 2] |= (128 | code12 >>> 12 & 63) << SHIFT[i++ & 3];
                  blocks2[i >>> 2] |= (128 | code12 >>> 6 & 63) << SHIFT[i++ & 3];
                  blocks2[i >>> 2] |= (128 | code12 & 63) << SHIFT[i++ & 3];
                }
              }
            }
          } else {
            if (ARRAY_BUFFER) {
              for (i = this.start; index < length11 && i < 64; ++index) {
                buffer82[i++] = message[index];
              }
            } else {
              for (i = this.start; index < length11 && i < 64; ++index) {
                blocks2[i >>> 2] |= message[index] << SHIFT[i++ & 3];
              }
            }
          }
          this.lastByteIndex = i;
          this.bytes += i - this.start;
          if (i >= 64) {
            this.start = i - 64;
            this.hash();
            this.hashed = true;
          } else {
            this.start = i;
          }
        }
        if (this.bytes > 4294967295) {
          this.hBytes += this.bytes / 4294967296 << 0;
          this.bytes = this.bytes % 4294967296;
        }
        return this;
      };
      Md5.prototype.finalize = function() {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks2 = this.blocks, i = this.lastByteIndex;
        blocks2[i >>> 2] |= EXTRA[i & 3];
        if (i >= 56) {
          if (!this.hashed) {
            this.hash();
          }
          blocks2[0] = blocks2[16];
          blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
        }
        blocks2[14] = this.bytes << 3;
        blocks2[15] = this.hBytes << 3 | this.bytes >>> 29;
        this.hash();
      };
      Md5.prototype.hash = function() {
        var a, b, c, d, bc, da, blocks2 = this.blocks;
        if (this.first) {
          a = blocks2[0] - 680876937;
          a = (a << 7 | a >>> 25) - 271733879 << 0;
          d = (-1732584194 ^ a & 2004318071) + blocks2[1] - 117830708;
          d = (d << 12 | d >>> 20) + a << 0;
          c = (-271733879 ^ d & (a ^ -271733879)) + blocks2[2] - 1126478375;
          c = (c << 17 | c >>> 15) + d << 0;
          b = (a ^ c & (d ^ a)) + blocks2[3] - 1316259209;
          b = (b << 22 | b >>> 10) + c << 0;
        } else {
          a = this.h0;
          b = this.h1;
          c = this.h2;
          d = this.h3;
          a += (d ^ b & (c ^ d)) + blocks2[0] - 680876936;
          a = (a << 7 | a >>> 25) + b << 0;
          d += (c ^ a & (b ^ c)) + blocks2[1] - 389564586;
          d = (d << 12 | d >>> 20) + a << 0;
          c += (b ^ d & (a ^ b)) + blocks2[2] + 606105819;
          c = (c << 17 | c >>> 15) + d << 0;
          b += (a ^ c & (d ^ a)) + blocks2[3] - 1044525330;
          b = (b << 22 | b >>> 10) + c << 0;
        }
        a += (d ^ b & (c ^ d)) + blocks2[4] - 176418897;
        a = (a << 7 | a >>> 25) + b << 0;
        d += (c ^ a & (b ^ c)) + blocks2[5] + 1200080426;
        d = (d << 12 | d >>> 20) + a << 0;
        c += (b ^ d & (a ^ b)) + blocks2[6] - 1473231341;
        c = (c << 17 | c >>> 15) + d << 0;
        b += (a ^ c & (d ^ a)) + blocks2[7] - 45705983;
        b = (b << 22 | b >>> 10) + c << 0;
        a += (d ^ b & (c ^ d)) + blocks2[8] + 1770035416;
        a = (a << 7 | a >>> 25) + b << 0;
        d += (c ^ a & (b ^ c)) + blocks2[9] - 1958414417;
        d = (d << 12 | d >>> 20) + a << 0;
        c += (b ^ d & (a ^ b)) + blocks2[10] - 42063;
        c = (c << 17 | c >>> 15) + d << 0;
        b += (a ^ c & (d ^ a)) + blocks2[11] - 1990404162;
        b = (b << 22 | b >>> 10) + c << 0;
        a += (d ^ b & (c ^ d)) + blocks2[12] + 1804603682;
        a = (a << 7 | a >>> 25) + b << 0;
        d += (c ^ a & (b ^ c)) + blocks2[13] - 40341101;
        d = (d << 12 | d >>> 20) + a << 0;
        c += (b ^ d & (a ^ b)) + blocks2[14] - 1502002290;
        c = (c << 17 | c >>> 15) + d << 0;
        b += (a ^ c & (d ^ a)) + blocks2[15] + 1236535329;
        b = (b << 22 | b >>> 10) + c << 0;
        a += (c ^ d & (b ^ c)) + blocks2[1] - 165796510;
        a = (a << 5 | a >>> 27) + b << 0;
        d += (b ^ c & (a ^ b)) + blocks2[6] - 1069501632;
        d = (d << 9 | d >>> 23) + a << 0;
        c += (a ^ b & (d ^ a)) + blocks2[11] + 643717713;
        c = (c << 14 | c >>> 18) + d << 0;
        b += (d ^ a & (c ^ d)) + blocks2[0] - 373897302;
        b = (b << 20 | b >>> 12) + c << 0;
        a += (c ^ d & (b ^ c)) + blocks2[5] - 701558691;
        a = (a << 5 | a >>> 27) + b << 0;
        d += (b ^ c & (a ^ b)) + blocks2[10] + 38016083;
        d = (d << 9 | d >>> 23) + a << 0;
        c += (a ^ b & (d ^ a)) + blocks2[15] - 660478335;
        c = (c << 14 | c >>> 18) + d << 0;
        b += (d ^ a & (c ^ d)) + blocks2[4] - 405537848;
        b = (b << 20 | b >>> 12) + c << 0;
        a += (c ^ d & (b ^ c)) + blocks2[9] + 568446438;
        a = (a << 5 | a >>> 27) + b << 0;
        d += (b ^ c & (a ^ b)) + blocks2[14] - 1019803690;
        d = (d << 9 | d >>> 23) + a << 0;
        c += (a ^ b & (d ^ a)) + blocks2[3] - 187363961;
        c = (c << 14 | c >>> 18) + d << 0;
        b += (d ^ a & (c ^ d)) + blocks2[8] + 1163531501;
        b = (b << 20 | b >>> 12) + c << 0;
        a += (c ^ d & (b ^ c)) + blocks2[13] - 1444681467;
        a = (a << 5 | a >>> 27) + b << 0;
        d += (b ^ c & (a ^ b)) + blocks2[2] - 51403784;
        d = (d << 9 | d >>> 23) + a << 0;
        c += (a ^ b & (d ^ a)) + blocks2[7] + 1735328473;
        c = (c << 14 | c >>> 18) + d << 0;
        b += (d ^ a & (c ^ d)) + blocks2[12] - 1926607734;
        b = (b << 20 | b >>> 12) + c << 0;
        bc = b ^ c;
        a += (bc ^ d) + blocks2[5] - 378558;
        a = (a << 4 | a >>> 28) + b << 0;
        d += (bc ^ a) + blocks2[8] - 2022574463;
        d = (d << 11 | d >>> 21) + a << 0;
        da = d ^ a;
        c += (da ^ b) + blocks2[11] + 1839030562;
        c = (c << 16 | c >>> 16) + d << 0;
        b += (da ^ c) + blocks2[14] - 35309556;
        b = (b << 23 | b >>> 9) + c << 0;
        bc = b ^ c;
        a += (bc ^ d) + blocks2[1] - 1530992060;
        a = (a << 4 | a >>> 28) + b << 0;
        d += (bc ^ a) + blocks2[4] + 1272893353;
        d = (d << 11 | d >>> 21) + a << 0;
        da = d ^ a;
        c += (da ^ b) + blocks2[7] - 155497632;
        c = (c << 16 | c >>> 16) + d << 0;
        b += (da ^ c) + blocks2[10] - 1094730640;
        b = (b << 23 | b >>> 9) + c << 0;
        bc = b ^ c;
        a += (bc ^ d) + blocks2[13] + 681279174;
        a = (a << 4 | a >>> 28) + b << 0;
        d += (bc ^ a) + blocks2[0] - 358537222;
        d = (d << 11 | d >>> 21) + a << 0;
        da = d ^ a;
        c += (da ^ b) + blocks2[3] - 722521979;
        c = (c << 16 | c >>> 16) + d << 0;
        b += (da ^ c) + blocks2[6] + 76029189;
        b = (b << 23 | b >>> 9) + c << 0;
        bc = b ^ c;
        a += (bc ^ d) + blocks2[9] - 640364487;
        a = (a << 4 | a >>> 28) + b << 0;
        d += (bc ^ a) + blocks2[12] - 421815835;
        d = (d << 11 | d >>> 21) + a << 0;
        da = d ^ a;
        c += (da ^ b) + blocks2[15] + 530742520;
        c = (c << 16 | c >>> 16) + d << 0;
        b += (da ^ c) + blocks2[2] - 995338651;
        b = (b << 23 | b >>> 9) + c << 0;
        a += (c ^ (b | ~d)) + blocks2[0] - 198630844;
        a = (a << 6 | a >>> 26) + b << 0;
        d += (b ^ (a | ~c)) + blocks2[7] + 1126891415;
        d = (d << 10 | d >>> 22) + a << 0;
        c += (a ^ (d | ~b)) + blocks2[14] - 1416354905;
        c = (c << 15 | c >>> 17) + d << 0;
        b += (d ^ (c | ~a)) + blocks2[5] - 57434055;
        b = (b << 21 | b >>> 11) + c << 0;
        a += (c ^ (b | ~d)) + blocks2[12] + 1700485571;
        a = (a << 6 | a >>> 26) + b << 0;
        d += (b ^ (a | ~c)) + blocks2[3] - 1894986606;
        d = (d << 10 | d >>> 22) + a << 0;
        c += (a ^ (d | ~b)) + blocks2[10] - 1051523;
        c = (c << 15 | c >>> 17) + d << 0;
        b += (d ^ (c | ~a)) + blocks2[1] - 2054922799;
        b = (b << 21 | b >>> 11) + c << 0;
        a += (c ^ (b | ~d)) + blocks2[8] + 1873313359;
        a = (a << 6 | a >>> 26) + b << 0;
        d += (b ^ (a | ~c)) + blocks2[15] - 30611744;
        d = (d << 10 | d >>> 22) + a << 0;
        c += (a ^ (d | ~b)) + blocks2[6] - 1560198380;
        c = (c << 15 | c >>> 17) + d << 0;
        b += (d ^ (c | ~a)) + blocks2[13] + 1309151649;
        b = (b << 21 | b >>> 11) + c << 0;
        a += (c ^ (b | ~d)) + blocks2[4] - 145523070;
        a = (a << 6 | a >>> 26) + b << 0;
        d += (b ^ (a | ~c)) + blocks2[11] - 1120210379;
        d = (d << 10 | d >>> 22) + a << 0;
        c += (a ^ (d | ~b)) + blocks2[2] + 718787259;
        c = (c << 15 | c >>> 17) + d << 0;
        b += (d ^ (c | ~a)) + blocks2[9] - 343485551;
        b = (b << 21 | b >>> 11) + c << 0;
        if (this.first) {
          this.h0 = a + 1732584193 << 0;
          this.h1 = b - 271733879 << 0;
          this.h2 = c - 1732584194 << 0;
          this.h3 = d + 271733878 << 0;
          this.first = false;
        } else {
          this.h0 = this.h0 + a << 0;
          this.h1 = this.h1 + b << 0;
          this.h2 = this.h2 + c << 0;
          this.h3 = this.h3 + d << 0;
        }
      };
      Md5.prototype.hex = function() {
        this.finalize();
        var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3;
        return HEX_CHARS[h0 >>> 4 & 15] + HEX_CHARS[h0 & 15] + HEX_CHARS[h0 >>> 12 & 15] + HEX_CHARS[h0 >>> 8 & 15] + HEX_CHARS[h0 >>> 20 & 15] + HEX_CHARS[h0 >>> 16 & 15] + HEX_CHARS[h0 >>> 28 & 15] + HEX_CHARS[h0 >>> 24 & 15] + HEX_CHARS[h1 >>> 4 & 15] + HEX_CHARS[h1 & 15] + HEX_CHARS[h1 >>> 12 & 15] + HEX_CHARS[h1 >>> 8 & 15] + HEX_CHARS[h1 >>> 20 & 15] + HEX_CHARS[h1 >>> 16 & 15] + HEX_CHARS[h1 >>> 28 & 15] + HEX_CHARS[h1 >>> 24 & 15] + HEX_CHARS[h2 >>> 4 & 15] + HEX_CHARS[h2 & 15] + HEX_CHARS[h2 >>> 12 & 15] + HEX_CHARS[h2 >>> 8 & 15] + HEX_CHARS[h2 >>> 20 & 15] + HEX_CHARS[h2 >>> 16 & 15] + HEX_CHARS[h2 >>> 28 & 15] + HEX_CHARS[h2 >>> 24 & 15] + HEX_CHARS[h3 >>> 4 & 15] + HEX_CHARS[h3 & 15] + HEX_CHARS[h3 >>> 12 & 15] + HEX_CHARS[h3 >>> 8 & 15] + HEX_CHARS[h3 >>> 20 & 15] + HEX_CHARS[h3 >>> 16 & 15] + HEX_CHARS[h3 >>> 28 & 15] + HEX_CHARS[h3 >>> 24 & 15];
      };
      Md5.prototype.toString = Md5.prototype.hex;
      Md5.prototype.digest = function() {
        this.finalize();
        var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3;
        return [
          h0 & 255,
          h0 >>> 8 & 255,
          h0 >>> 16 & 255,
          h0 >>> 24 & 255,
          h1 & 255,
          h1 >>> 8 & 255,
          h1 >>> 16 & 255,
          h1 >>> 24 & 255,
          h2 & 255,
          h2 >>> 8 & 255,
          h2 >>> 16 & 255,
          h2 >>> 24 & 255,
          h3 & 255,
          h3 >>> 8 & 255,
          h3 >>> 16 & 255,
          h3 >>> 24 & 255
        ];
      };
      Md5.prototype.array = Md5.prototype.digest;
      Md5.prototype.arrayBuffer = function() {
        this.finalize();
        var buffer3 = new ArrayBuffer(16);
        var blocks2 = new Uint32Array(buffer3);
        blocks2[0] = this.h0;
        blocks2[1] = this.h1;
        blocks2[2] = this.h2;
        blocks2[3] = this.h3;
        return buffer3;
      };
      Md5.prototype.buffer = Md5.prototype.arrayBuffer;
      Md5.prototype.base64 = function() {
        var v1, v2, v3, base64Str = "", bytes = this.array();
        for (var i = 0; i < 15; ) {
          v1 = bytes[i++];
          v2 = bytes[i++];
          v3 = bytes[i++];
          base64Str += BASE64_ENCODE_CHAR[v1 >>> 2] + BASE64_ENCODE_CHAR[(v1 << 4 | v2 >>> 4) & 63] + BASE64_ENCODE_CHAR[(v2 << 2 | v3 >>> 6) & 63] + BASE64_ENCODE_CHAR[v3 & 63];
        }
        v1 = bytes[i];
        base64Str += BASE64_ENCODE_CHAR[v1 >>> 2] + BASE64_ENCODE_CHAR[v1 << 4 & 63] + "==";
        return base64Str;
      };
      function HmacMd5(key, sharedMemory) {
        var i, result = formatMessage(key);
        key = result[0];
        if (result[1]) {
          var bytes = [], length11 = key.length, index = 0, code12;
          for (i = 0; i < length11; ++i) {
            code12 = key.charCodeAt(i);
            if (code12 < 128) {
              bytes[index++] = code12;
            } else if (code12 < 2048) {
              bytes[index++] = 192 | code12 >>> 6;
              bytes[index++] = 128 | code12 & 63;
            } else if (code12 < 55296 || code12 >= 57344) {
              bytes[index++] = 224 | code12 >>> 12;
              bytes[index++] = 128 | code12 >>> 6 & 63;
              bytes[index++] = 128 | code12 & 63;
            } else {
              code12 = 65536 + ((code12 & 1023) << 10 | key.charCodeAt(++i) & 1023);
              bytes[index++] = 240 | code12 >>> 18;
              bytes[index++] = 128 | code12 >>> 12 & 63;
              bytes[index++] = 128 | code12 >>> 6 & 63;
              bytes[index++] = 128 | code12 & 63;
            }
          }
          key = bytes;
        }
        if (key.length > 64) {
          key = new Md5(true).update(key).array();
        }
        var oKeyPad = [], iKeyPad = [];
        for (i = 0; i < 64; ++i) {
          var b = key[i] || 0;
          oKeyPad[i] = 92 ^ b;
          iKeyPad[i] = 54 ^ b;
        }
        Md5.call(this, sharedMemory);
        this.update(iKeyPad);
        this.oKeyPad = oKeyPad;
        this.inner = true;
        this.sharedMemory = sharedMemory;
      }
      HmacMd5.prototype = new Md5();
      HmacMd5.prototype.finalize = function() {
        Md5.prototype.finalize.call(this);
        if (this.inner) {
          this.inner = false;
          var innerHash = this.array();
          Md5.call(this, this.sharedMemory);
          this.update(this.oKeyPad);
          this.update(innerHash);
          Md5.prototype.finalize.call(this);
        }
      };
      var exports3 = createMethod();
      exports3.md5 = exports3;
      exports3.md5.hmac = createHmacMethod();
      if (COMMON_JS) {
        module2.exports = exports3;
      } else {
        root.md5 = exports3;
        if (AMD) {
          define(function() {
            return exports3;
          });
        }
      }
    })();
  }
});

// node_modules/varint/encode.js
var require_encode = __commonJS({
  "node_modules/varint/encode.js"(exports2, module2) {
    module2.exports = encode42;
    var MSB12 = 128;
    var REST12 = 127;
    var MSBALL11 = ~REST12;
    var INT11 = Math.pow(2, 31);
    function encode42(num, out, offset) {
      if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {
        encode42.bytes = 0;
        throw new RangeError("Could not encode varint");
      }
      out = out || [];
      offset = offset || 0;
      var oldOffset = offset;
      while (num >= INT11) {
        out[offset++] = num & 255 | MSB12;
        num /= 128;
      }
      while (num & MSBALL11) {
        out[offset++] = num & 255 | MSB12;
        num >>>= 7;
      }
      out[offset] = num | 0;
      encode42.bytes = offset - oldOffset + 1;
      return out;
    }
  }
});

// node_modules/varint/decode.js
var require_decode = __commonJS({
  "node_modules/varint/decode.js"(exports2, module2) {
    module2.exports = read11;
    var MSB12 = 128;
    var REST12 = 127;
    function read11(buf2, offset) {
      var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
      do {
        if (counter >= l || shift > 49) {
          read11.bytes = 0;
          throw new RangeError("Could not decode varint");
        }
        b = buf2[counter++];
        res += shift < 28 ? (b & REST12) << shift : (b & REST12) * Math.pow(2, shift);
        shift += 7;
      } while (b >= MSB12);
      read11.bytes = counter - offset;
      return res;
    }
  }
});

// node_modules/varint/length.js
var require_length = __commonJS({
  "node_modules/varint/length.js"(exports2, module2) {
    var N112 = Math.pow(2, 7);
    var N212 = Math.pow(2, 14);
    var N312 = Math.pow(2, 21);
    var N412 = Math.pow(2, 28);
    var N512 = Math.pow(2, 35);
    var N612 = Math.pow(2, 42);
    var N712 = Math.pow(2, 49);
    var N811 = Math.pow(2, 56);
    var N911 = Math.pow(2, 63);
    module2.exports = function(value) {
      return value < N112 ? 1 : value < N212 ? 2 : value < N312 ? 3 : value < N412 ? 4 : value < N512 ? 5 : value < N612 ? 6 : value < N712 ? 7 : value < N811 ? 8 : value < N911 ? 9 : 10;
    };
  }
});

// node_modules/varint/index.js
var require_varint = __commonJS({
  "node_modules/varint/index.js"(exports2, module2) {
    module2.exports = {
      encode: require_encode(),
      decode: require_decode(),
      encodingLength: require_length()
    };
  }
});

// node_modules/err-code/index.js
var require_err_code = __commonJS({
  "node_modules/err-code/index.js"(exports2, module2) {
    "use strict";
    function assign(obj, props) {
      for (const key in props) {
        Object.defineProperty(obj, key, {
          value: props[key],
          enumerable: true,
          configurable: true
        });
      }
      return obj;
    }
    function createError(err, code12, props) {
      if (!err || typeof err === "string") {
        throw new TypeError("Please pass an Error to err-code");
      }
      if (!props) {
        props = {};
      }
      if (typeof code12 === "object") {
        props = code12;
        code12 = "";
      }
      if (code12) {
        props.code = code12;
      }
      try {
        return assign(err, props);
      } catch (_) {
        props.message = err.message;
        props.stack = err.stack;
        const ErrClass = function() {
        };
        ErrClass.prototype = Object.create(Object.getPrototypeOf(err));
        const output = assign(new ErrClass(), props);
        return output;
      }
    }
    module2.exports = createError;
  }
});

// node_modules/is-electron/index.js
var require_is_electron = __commonJS({
  "node_modules/is-electron/index.js"(exports2, module2) {
    function isElectron() {
      if (typeof window !== "undefined" && typeof window.process === "object" && window.process.type === "renderer") {
        return true;
      }
      if (typeof process !== "undefined" && typeof process.versions === "object" && !!process.versions.electron) {
        return true;
      }
      if (typeof navigator === "object" && typeof navigator.userAgent === "string" && navigator.userAgent.indexOf("Electron") >= 0) {
        return true;
      }
      return false;
    }
    module2.exports = isElectron;
  }
});

// node_modules/ipfs-utils/src/env.js
var require_env = __commonJS({
  "node_modules/ipfs-utils/src/env.js"(exports2, module2) {
    "use strict";
    var isElectron = require_is_electron();
    var IS_ENV_WITH_DOM = typeof window === "object" && typeof document === "object" && document.nodeType === 9;
    var IS_ELECTRON = isElectron();
    var IS_BROWSER = IS_ENV_WITH_DOM && !IS_ELECTRON;
    var IS_ELECTRON_MAIN = IS_ELECTRON && !IS_ENV_WITH_DOM;
    var IS_ELECTRON_RENDERER = IS_ELECTRON && IS_ENV_WITH_DOM;
    var IS_NODE = typeof __require === "function" && typeof process !== "undefined" && typeof process.release !== "undefined" && process.release.name === "node" && !IS_ELECTRON;
    var IS_WEBWORKER = typeof importScripts === "function" && typeof self !== "undefined" && typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope;
    var IS_TEST = typeof process !== "undefined" && typeof process.env !== "undefined" && false;
    var IS_REACT_NATIVE = typeof navigator !== "undefined" && navigator.product === "ReactNative";
    module2.exports = {
      isTest: IS_TEST,
      isElectron: IS_ELECTRON,
      isElectronMain: IS_ELECTRON_MAIN,
      isElectronRenderer: IS_ELECTRON_RENDERER,
      isNode: IS_NODE,
      /**
       * Detects browser main thread  **NOT** web worker or service worker
       */
      isBrowser: IS_BROWSER,
      isWebWorker: IS_WEBWORKER,
      isEnvWithDom: IS_ENV_WITH_DOM,
      isReactNative: IS_REACT_NATIVE
    };
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse3(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse3(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name12) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name12 + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports2, module2) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce12;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug2(...args) {
          if (!debug2.enabled) {
            return;
          }
          const self2 = debug2;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format12) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format12];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug2.namespace = namespace;
        debug2.useColors = createDebug.useColors();
        debug2.color = createDebug.selectColor(namespace);
        debug2.extend = extend;
        debug2.destroy = createDebug.destroy;
        Object.defineProperty(debug2, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug2);
        }
        return debug2;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split2 = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
        for (const ns of split2) {
          if (ns[0] === "-") {
            createDebug.skips.push(ns.slice(1));
          } else {
            createDebug.names.push(ns);
          }
        }
      }
      function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search.length) {
          if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
            if (template[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template.length && template[templateIndex] === "*") {
          templateIndex++;
        }
        return templateIndex === template.length;
      }
      function disable() {
        const namespaces = [
          ...createDebug.names,
          ...createDebug.skips.map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name12) {
        for (const skip of createDebug.skips) {
          if (matchesTemplate(name12, skip)) {
            return false;
          }
        }
        for (const ns of createDebug.names) {
          if (matchesTemplate(name12, ns)) {
            return true;
          }
        }
        return false;
      }
      function coerce12(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports2, module2) {
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug") || exports2.storage.getItem("DEBUG");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/ipfs-utils/src/http/error.js
var require_error = __commonJS({
  "node_modules/ipfs-utils/src/http/error.js"(exports2) {
    "use strict";
    var TimeoutError = class extends Error {
      constructor(message = "Request timed out") {
        super(message);
        this.name = "TimeoutError";
      }
    };
    exports2.TimeoutError = TimeoutError;
    var AbortError = class extends Error {
      constructor(message = "The operation was aborted.") {
        super(message);
        this.name = "AbortError";
      }
    };
    exports2.AbortError = AbortError;
    var HTTPError2 = class extends Error {
      /**
       * @param {Response} response
       */
      constructor(response) {
        super(response.statusText);
        this.name = "HTTPError";
        this.response = response;
      }
    };
    exports2.HTTPError = HTTPError2;
  }
});

// (disabled):node_modules/node-fetch/browser.js
var require_browser2 = __commonJS({
  "(disabled):node_modules/node-fetch/browser.js"() {
  }
});

// node_modules/ipfs-utils/node_modules/native-fetch/src/index.js
var require_src2 = __commonJS({
  "node_modules/ipfs-utils/node_modules/native-fetch/src/index.js"(exports2, module2) {
    "use strict";
    if (globalThis.fetch && globalThis.Headers && globalThis.Request && globalThis.Response) {
      module2.exports = {
        default: globalThis.fetch,
        Headers: globalThis.Headers,
        Request: globalThis.Request,
        Response: globalThis.Response
      };
    } else {
      module2.exports = {
        default: require_browser2().default,
        Headers: require_browser2().Headers,
        Request: require_browser2().Request,
        Response: require_browser2().Response
      };
    }
  }
});

// node_modules/ipfs-utils/src/fetch.browser.js
var require_fetch_browser = __commonJS({
  "node_modules/ipfs-utils/src/fetch.browser.js"(exports2, module2) {
    "use strict";
    module2.exports = require_src2();
  }
});

// node_modules/ipfs-utils/src/http/fetch.browser.js
var require_fetch_browser2 = __commonJS({
  "node_modules/ipfs-utils/src/http/fetch.browser.js"(exports2, module2) {
    "use strict";
    var { TimeoutError, AbortError } = require_error();
    var { Response: Response2, Request, Headers, default: fetch2 } = require_fetch_browser();
    var fetchWithProgress = (url, options = {}) => {
      const request = new XMLHttpRequest();
      request.open(options.method || "GET", url.toString(), true);
      const { timeout, headers } = options;
      if (timeout && timeout > 0 && timeout < Infinity) {
        request.timeout = timeout;
      }
      if (options.overrideMimeType != null) {
        request.overrideMimeType(options.overrideMimeType);
      }
      if (headers) {
        for (const [name12, value] of new Headers(headers)) {
          request.setRequestHeader(name12, value);
        }
      }
      if (options.signal) {
        options.signal.onabort = () => request.abort();
      }
      if (options.onUploadProgress) {
        request.upload.onprogress = options.onUploadProgress;
      }
      request.responseType = "arraybuffer";
      return new Promise((resolve2, reject) => {
        const handleEvent = (event) => {
          switch (event.type) {
            case "error": {
              resolve2(Response2.error());
              break;
            }
            case "load": {
              resolve2(
                new ResponseWithURL(request.responseURL, request.response, {
                  status: request.status,
                  statusText: request.statusText,
                  headers: parseHeaders(request.getAllResponseHeaders())
                })
              );
              break;
            }
            case "timeout": {
              reject(new TimeoutError());
              break;
            }
            case "abort": {
              reject(new AbortError());
              break;
            }
            default: {
              break;
            }
          }
        };
        request.onerror = handleEvent;
        request.onload = handleEvent;
        request.ontimeout = handleEvent;
        request.onabort = handleEvent;
        request.send(options.body);
      });
    };
    var fetchWithStreaming = fetch2;
    var fetchWith = (url, options = {}) => options.onUploadProgress != null ? fetchWithProgress(url, options) : fetchWithStreaming(url, options);
    var parseHeaders = (input) => {
      const headers = new Headers();
      for (const line of input.trim().split(/[\r\n]+/)) {
        const index = line.indexOf(": ");
        if (index > 0) {
          headers.set(line.slice(0, index), line.slice(index + 1));
        }
      }
      return headers;
    };
    var ResponseWithURL = class extends Response2 {
      /**
       * @param {string} url
       * @param {BodyInit} body
       * @param {ResponseInit} options
       */
      constructor(url, body, options) {
        super(body, options);
        Object.defineProperty(this, "url", { value: url });
      }
    };
    module2.exports = {
      fetch: fetchWith,
      Request,
      Headers
    };
  }
});

// node_modules/is-plain-obj/index.js
var require_is_plain_obj = __commonJS({
  "node_modules/is-plain-obj/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (value) => {
      if (Object.prototype.toString.call(value) !== "[object Object]") {
        return false;
      }
      const prototype = Object.getPrototypeOf(value);
      return prototype === null || prototype === Object.prototype;
    };
  }
});

// node_modules/merge-options/index.js
var require_merge_options = __commonJS({
  "node_modules/merge-options/index.js"(exports2, module2) {
    "use strict";
    var isOptionObject = require_is_plain_obj();
    var { hasOwnProperty } = Object.prototype;
    var { propertyIsEnumerable } = Object;
    var defineProperty = (object, name12, value) => Object.defineProperty(object, name12, {
      value,
      writable: true,
      enumerable: true,
      configurable: true
    });
    var globalThis2 = exports2;
    var defaultMergeOptions = {
      concatArrays: false,
      ignoreUndefined: false
    };
    var getEnumerableOwnPropertyKeys = (value) => {
      const keys = [];
      for (const key in value) {
        if (hasOwnProperty.call(value, key)) {
          keys.push(key);
        }
      }
      if (Object.getOwnPropertySymbols) {
        const symbols = Object.getOwnPropertySymbols(value);
        for (const symbol4 of symbols) {
          if (propertyIsEnumerable.call(value, symbol4)) {
            keys.push(symbol4);
          }
        }
      }
      return keys;
    };
    function clone(value) {
      if (Array.isArray(value)) {
        return cloneArray(value);
      }
      if (isOptionObject(value)) {
        return cloneOptionObject(value);
      }
      return value;
    }
    function cloneArray(array) {
      const result = array.slice(0, 0);
      getEnumerableOwnPropertyKeys(array).forEach((key) => {
        defineProperty(result, key, clone(array[key]));
      });
      return result;
    }
    function cloneOptionObject(object) {
      const result = Object.getPrototypeOf(object) === null ? /* @__PURE__ */ Object.create(null) : {};
      getEnumerableOwnPropertyKeys(object).forEach((key) => {
        defineProperty(result, key, clone(object[key]));
      });
      return result;
    }
    var mergeKeys = (merged, source, keys, config) => {
      keys.forEach((key) => {
        if (typeof source[key] === "undefined" && config.ignoreUndefined) {
          return;
        }
        if (key in merged && merged[key] !== Object.getPrototypeOf(merged)) {
          defineProperty(merged, key, merge2(merged[key], source[key], config));
        } else {
          defineProperty(merged, key, clone(source[key]));
        }
      });
      return merged;
    };
    var concatArrays = (merged, source, config) => {
      let result = merged.slice(0, 0);
      let resultIndex = 0;
      [merged, source].forEach((array) => {
        const indices = [];
        for (let k = 0; k < array.length; k++) {
          if (!hasOwnProperty.call(array, k)) {
            continue;
          }
          indices.push(String(k));
          if (array === merged) {
            defineProperty(result, resultIndex++, array[k]);
          } else {
            defineProperty(result, resultIndex++, clone(array[k]));
          }
        }
        result = mergeKeys(result, array, getEnumerableOwnPropertyKeys(array).filter((key) => !indices.includes(key)), config);
      });
      return result;
    };
    function merge2(merged, source, config) {
      if (config.concatArrays && Array.isArray(merged) && Array.isArray(source)) {
        return concatArrays(merged, source, config);
      }
      if (!isOptionObject(source) || !isOptionObject(merged)) {
        return clone(source);
      }
      return mergeKeys(merged, source, getEnumerableOwnPropertyKeys(source), config);
    }
    module2.exports = function(...options) {
      const config = merge2(clone(defaultMergeOptions), this !== globalThis2 && this || {}, defaultMergeOptions);
      let merged = { _: {} };
      for (const option of options) {
        if (option === void 0) {
          continue;
        }
        if (!isOptionObject(option)) {
          throw new TypeError("`" + option + "` is not an Option Object");
        }
        merged = merge2(merged, { _: option }, config);
      }
      return merged._;
    };
  }
});

// node_modules/iso-url/src/url-browser.js
var require_url_browser = __commonJS({
  "node_modules/iso-url/src/url-browser.js"(exports2, module2) {
    "use strict";
    var isReactNative = typeof navigator !== "undefined" && navigator.product === "ReactNative";
    function getDefaultBase() {
      if (isReactNative) {
        return "http://localhost";
      }
      if (!self.location) {
        return "";
      }
      return self.location.protocol + "//" + self.location.host;
    }
    var URL2 = self.URL;
    var defaultBase = getDefaultBase();
    var URLWithLegacySupport = class {
      constructor(url = "", base14 = defaultBase) {
        this.super = new URL2(url, base14);
        this.path = this.pathname + this.search;
        this.auth = this.username && this.password ? this.username + ":" + this.password : null;
        this.query = this.search && this.search.startsWith("?") ? this.search.slice(1) : null;
      }
      get hash() {
        return this.super.hash;
      }
      get host() {
        return this.super.host;
      }
      get hostname() {
        return this.super.hostname;
      }
      get href() {
        return this.super.href;
      }
      get origin() {
        return this.super.origin;
      }
      get password() {
        return this.super.password;
      }
      get pathname() {
        return this.super.pathname;
      }
      get port() {
        return this.super.port;
      }
      get protocol() {
        return this.super.protocol;
      }
      get search() {
        return this.super.search;
      }
      get searchParams() {
        return this.super.searchParams;
      }
      get username() {
        return this.super.username;
      }
      set hash(hash) {
        this.super.hash = hash;
      }
      set host(host) {
        this.super.host = host;
      }
      set hostname(hostname) {
        this.super.hostname = hostname;
      }
      set href(href) {
        this.super.href = href;
      }
      set password(password) {
        this.super.password = password;
      }
      set pathname(pathname) {
        this.super.pathname = pathname;
      }
      set port(port) {
        this.super.port = port;
      }
      set protocol(protocol) {
        this.super.protocol = protocol;
      }
      set search(search) {
        this.super.search = search;
      }
      set username(username) {
        this.super.username = username;
      }
      /**
       * @param {any} o
       */
      static createObjectURL(o) {
        return URL2.createObjectURL(o);
      }
      /**
       * @param {string} o
       */
      static revokeObjectURL(o) {
        URL2.revokeObjectURL(o);
      }
      toJSON() {
        return this.super.toJSON();
      }
      toString() {
        return this.super.toString();
      }
      format() {
        return this.toString();
      }
    };
    function format12(obj) {
      if (typeof obj === "string") {
        const url = new URL2(obj);
        return url.toString();
      }
      if (!(obj instanceof URL2)) {
        const userPass = (
          // @ts-ignore its not supported in node but we normalise
          obj.username && obj.password ? `${obj.username}:${obj.password}@` : ""
        );
        const auth = obj.auth ? obj.auth + "@" : "";
        const port = obj.port ? ":" + obj.port : "";
        const protocol = obj.protocol ? obj.protocol + "//" : "";
        const host = obj.host || "";
        const hostname = obj.hostname || "";
        const search = obj.search || (obj.query ? "?" + obj.query : "");
        const hash = obj.hash || "";
        const pathname = obj.pathname || "";
        const path = obj.path || pathname + search;
        return `${protocol}${userPass || auth}${host || hostname + port}${path}${hash}`;
      }
    }
    module2.exports = {
      URLWithLegacySupport,
      URLSearchParams: self.URLSearchParams,
      defaultBase,
      format: format12
    };
  }
});

// node_modules/iso-url/src/relative.js
var require_relative = __commonJS({
  "node_modules/iso-url/src/relative.js"(exports2, module2) {
    "use strict";
    var { URLWithLegacySupport, format: format12 } = require_url_browser();
    module2.exports = (url, location2 = {}, protocolMap = {}, defaultProtocol) => {
      let protocol = location2.protocol ? location2.protocol.replace(":", "") : "http";
      protocol = (protocolMap[protocol] || defaultProtocol || protocol) + ":";
      let urlParsed;
      try {
        urlParsed = new URLWithLegacySupport(url);
      } catch (err) {
        urlParsed = {};
      }
      const base14 = Object.assign({}, location2, {
        protocol: protocol || urlParsed.protocol,
        host: location2.host || urlParsed.host
      });
      return new URLWithLegacySupport(url, format12(base14)).toString();
    };
  }
});

// node_modules/iso-url/index.js
var require_iso_url = __commonJS({
  "node_modules/iso-url/index.js"(exports2, module2) {
    "use strict";
    var {
      URLWithLegacySupport,
      format: format12,
      URLSearchParams: URLSearchParams2,
      defaultBase
    } = require_url_browser();
    var relative = require_relative();
    module2.exports = {
      URL: URLWithLegacySupport,
      URLSearchParams: URLSearchParams2,
      format: format12,
      relative,
      defaultBase
    };
  }
});

// node_modules/any-signal/index.js
var require_any_signal = __commonJS({
  "node_modules/any-signal/index.js"(exports2, module2) {
    function anySignal2(signals) {
      const controller = new globalThis.AbortController();
      function onAbort() {
        controller.abort();
        for (const signal of signals) {
          if (!signal || !signal.removeEventListener) continue;
          signal.removeEventListener("abort", onAbort);
        }
      }
      for (const signal of signals) {
        if (!signal || !signal.addEventListener) continue;
        if (signal.aborted) {
          onAbort();
          break;
        }
        signal.addEventListener("abort", onAbort);
      }
      return controller.signal;
    }
    module2.exports = anySignal2;
    module2.exports.anySignal = anySignal2;
  }
});

// node_modules/ipfs-utils/node_modules/browser-readablestream-to-it/index.js
var require_browser_readablestream_to_it = __commonJS({
  "node_modules/ipfs-utils/node_modules/browser-readablestream-to-it/index.js"(exports2, module2) {
    "use strict";
    async function* browserReadableStreamToIt2(stream, options = {}) {
      const reader = stream.getReader();
      try {
        while (true) {
          const result = await reader.read();
          if (result.done) {
            return;
          }
          yield result.value;
        }
      } finally {
        if (options.preventCancel !== true) {
          reader.cancel();
        }
        reader.releaseLock();
      }
    }
    module2.exports = browserReadableStreamToIt2;
  }
});

// node_modules/ipfs-utils/node_modules/it-all/index.js
var require_it_all = __commonJS({
  "node_modules/ipfs-utils/node_modules/it-all/index.js"(exports2, module2) {
    "use strict";
    var all2 = async (source) => {
      const arr = [];
      for await (const entry of source) {
        arr.push(entry);
      }
      return arr;
    };
    module2.exports = all2;
  }
});

// node_modules/ipfs-utils/src/http.js
var require_http = __commonJS({
  "node_modules/ipfs-utils/src/http.js"(exports2, module2) {
    "use strict";
    var { fetch: fetch2, Request, Headers } = require_fetch_browser2();
    var { TimeoutError, HTTPError: HTTPError2 } = require_error();
    var merge2 = require_merge_options().bind({ ignoreUndefined: true });
    var { URL: URL2, URLSearchParams: URLSearchParams2 } = require_iso_url();
    var anySignal2 = require_any_signal();
    var browserReableStreamToIt = require_browser_readablestream_to_it();
    var { isBrowser: isBrowser2, isWebWorker: isWebWorker2 } = require_env();
    var all2 = require_it_all();
    var timeout = (promise, ms, abortController) => {
      if (ms === void 0) {
        return promise;
      }
      const start = Date.now();
      const timedOut = () => {
        const time = Date.now() - start;
        return time >= ms;
      };
      return new Promise((resolve2, reject) => {
        const timeoutID = setTimeout(() => {
          if (timedOut()) {
            reject(new TimeoutError());
            abortController.abort();
          }
        }, ms);
        const after = (next) => {
          const fn = (res) => {
            clearTimeout(timeoutID);
            if (timedOut()) {
              reject(new TimeoutError());
              return;
            }
            next(res);
          };
          return fn;
        };
        promise.then(after(resolve2), after(reject));
      });
    };
    var defaults = {
      throwHttpErrors: true,
      credentials: "same-origin"
    };
    var HTTP3 = class {
      /**
       *
       * @param {HTTPOptions} options
       */
      constructor(options = {}) {
        this.opts = merge2(defaults, options);
      }
      /**
       * Fetch
       *
       * @param {string | Request} resource
       * @param {HTTPOptions} options
       * @returns {Promise<ExtendedResponse>}
       */
      async fetch(resource, options = {}) {
        const opts = merge2(this.opts, options);
        const headers = new Headers(opts.headers);
        if (typeof resource !== "string" && !(resource instanceof URL2 || resource instanceof Request)) {
          throw new TypeError("`resource` must be a string, URL, or Request");
        }
        const url = new URL2(resource.toString(), opts.base);
        const {
          searchParams,
          transformSearchParams,
          json
        } = opts;
        if (searchParams) {
          if (typeof transformSearchParams === "function") {
            url.search = transformSearchParams(new URLSearchParams2(opts.searchParams));
          } else {
            url.search = new URLSearchParams2(opts.searchParams);
          }
        }
        if (json) {
          opts.body = JSON.stringify(opts.json);
          headers.set("content-type", "application/json");
        }
        const abortController = new AbortController();
        const signal = anySignal2([abortController.signal, opts.signal]);
        if (globalThis.ReadableStream != null && opts.body instanceof globalThis.ReadableStream && (isBrowser2 || isWebWorker2)) {
          opts.body = new Blob(await all2(browserReableStreamToIt(opts.body)));
        }
        const response = await timeout(
          fetch2(
            url.toString(),
            {
              ...opts,
              signal,
              // @ts-expect-error non-browser fetch implementations may take extra options
              timeout: void 0,
              headers,
              // https://fetch.spec.whatwg.org/#dom-requestinit-duplex
              // https://github.com/whatwg/fetch/issues/1254
              duplex: "half"
            }
          ),
          opts.timeout,
          abortController
        );
        if (!response.ok && opts.throwHttpErrors) {
          if (opts.handleError) {
            await opts.handleError(response);
          }
          throw new HTTPError2(response);
        }
        response.iterator = async function* () {
          yield* fromStream(response.body);
        };
        response.ndjson = async function* () {
          for await (const chunk of ndjson(response.iterator())) {
            if (options.transform) {
              yield options.transform(chunk);
            } else {
              yield chunk;
            }
          }
        };
        return response;
      }
      /**
       * @param {string | Request} resource
       * @param {HTTPOptions} options
       */
      post(resource, options = {}) {
        return this.fetch(resource, { ...options, method: "POST" });
      }
      /**
       * @param {string | Request} resource
       * @param {HTTPOptions} options
       */
      get(resource, options = {}) {
        return this.fetch(resource, { ...options, method: "GET" });
      }
      /**
       * @param {string | Request} resource
       * @param {HTTPOptions} options
       */
      put(resource, options = {}) {
        return this.fetch(resource, { ...options, method: "PUT" });
      }
      /**
       * @param {string | Request} resource
       * @param {HTTPOptions} options
       */
      delete(resource, options = {}) {
        return this.fetch(resource, { ...options, method: "DELETE" });
      }
      /**
       * @param {string | Request} resource
       * @param {HTTPOptions} options
       */
      options(resource, options = {}) {
        return this.fetch(resource, { ...options, method: "OPTIONS" });
      }
    };
    var ndjson = async function* (source) {
      const decoder = new TextDecoder();
      let buf2 = "";
      for await (const chunk of source) {
        buf2 += decoder.decode(chunk, { stream: true });
        const lines = buf2.split(/\r?\n/);
        for (let i = 0; i < lines.length - 1; i++) {
          const l = lines[i].trim();
          if (l.length > 0) {
            yield JSON.parse(l);
          }
        }
        buf2 = lines[lines.length - 1];
      }
      buf2 += decoder.decode();
      buf2 = buf2.trim();
      if (buf2.length !== 0) {
        yield JSON.parse(buf2);
      }
    };
    var fromStream = (source) => {
      if (isAsyncIterable2(source)) {
        return source;
      }
      if (isNodeReadableStream(source)) {
        const iter = source[Symbol.asyncIterator]();
        return {
          [Symbol.asyncIterator]() {
            return {
              next: iter.next.bind(iter),
              return(value) {
                source.destroy();
                if (typeof iter.return === "function") {
                  return iter.return();
                }
                return Promise.resolve({ done: true, value });
              }
            };
          }
        };
      }
      if (isWebReadableStream(source)) {
        const reader = source.getReader();
        return (async function* () {
          try {
            while (true) {
              const { done, value } = await reader.read();
              if (done) return;
              if (value) {
                yield value;
              }
            }
          } finally {
            reader.releaseLock();
          }
        })();
      }
      throw new TypeError("Body can't be converted to AsyncIterable");
    };
    var isAsyncIterable2 = (value) => {
      return typeof value === "object" && value !== null && typeof /** @type {any} */
      value[Symbol.asyncIterator] === "function";
    };
    var isWebReadableStream = (value) => {
      return value && typeof /** @type {any} */
      value.getReader === "function";
    };
    var isNodeReadableStream = (value) => Object.prototype.hasOwnProperty.call(value, "readable") && Object.prototype.hasOwnProperty.call(value, "writable");
    HTTP3.HTTPError = HTTPError2;
    HTTP3.TimeoutError = TimeoutError;
    HTTP3.streamToAsyncIterator = fromStream;
    HTTP3.post = (resource, options) => new HTTP3(options).post(resource, options);
    HTTP3.get = (resource, options) => new HTTP3(options).get(resource, options);
    HTTP3.put = (resource, options) => new HTTP3(options).put(resource, options);
    HTTP3.delete = (resource, options) => new HTTP3(options).delete(resource, options);
    HTTP3.options = (resource, options) => new HTTP3(options).options(resource, options);
    module2.exports = HTTP3;
  }
});

// node_modules/@protobufjs/aspromise/index.js
var require_aspromise = __commonJS({
  "node_modules/@protobufjs/aspromise/index.js"(exports2, module2) {
    "use strict";
    module2.exports = asPromise;
    function asPromise(fn, ctx) {
      var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
      while (index < arguments.length)
        params[offset++] = arguments[index++];
      return new Promise(function executor(resolve2, reject) {
        params[offset] = function callback(err) {
          if (pending) {
            pending = false;
            if (err)
              reject(err);
            else {
              var params2 = new Array(arguments.length - 1), offset2 = 0;
              while (offset2 < params2.length)
                params2[offset2++] = arguments[offset2];
              resolve2.apply(null, params2);
            }
          }
        };
        try {
          fn.apply(ctx || null, params);
        } catch (err) {
          if (pending) {
            pending = false;
            reject(err);
          }
        }
      });
    }
  }
});

// node_modules/@protobufjs/base64/index.js
var require_base64 = __commonJS({
  "node_modules/@protobufjs/base64/index.js"(exports2) {
    "use strict";
    var base649 = exports2;
    base649.length = function length11(string3) {
      var p = string3.length;
      if (!p)
        return 0;
      var n = 0;
      while (--p % 4 > 1 && string3.charAt(p) === "=")
        ++n;
      return Math.ceil(string3.length * 3) / 4 - n;
    };
    var b64 = new Array(64);
    var s64 = new Array(123);
    for (i = 0; i < 64; )
      s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
    var i;
    base649.encode = function encode42(buffer2, start, end) {
      var parts = null, chunk = [];
      var i2 = 0, j = 0, t;
      while (start < end) {
        var b = buffer2[start++];
        switch (j) {
          case 0:
            chunk[i2++] = b64[b >> 2];
            t = (b & 3) << 4;
            j = 1;
            break;
          case 1:
            chunk[i2++] = b64[t | b >> 4];
            t = (b & 15) << 2;
            j = 2;
            break;
          case 2:
            chunk[i2++] = b64[t | b >> 6];
            chunk[i2++] = b64[b & 63];
            j = 0;
            break;
        }
        if (i2 > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i2 = 0;
        }
      }
      if (j) {
        chunk[i2++] = b64[t];
        chunk[i2++] = 61;
        if (j === 1)
          chunk[i2++] = 61;
      }
      if (parts) {
        if (i2)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i2));
    };
    var invalidEncoding = "invalid encoding";
    base649.decode = function decode58(string3, buffer2, offset) {
      var start = offset;
      var j = 0, t;
      for (var i2 = 0; i2 < string3.length; ) {
        var c = string3.charCodeAt(i2++);
        if (c === 61 && j > 1)
          break;
        if ((c = s64[c]) === void 0)
          throw Error(invalidEncoding);
        switch (j) {
          case 0:
            t = c;
            j = 1;
            break;
          case 1:
            buffer2[offset++] = t << 2 | (c & 48) >> 4;
            t = c;
            j = 2;
            break;
          case 2:
            buffer2[offset++] = (t & 15) << 4 | (c & 60) >> 2;
            t = c;
            j = 3;
            break;
          case 3:
            buffer2[offset++] = (t & 3) << 6 | c;
            j = 0;
            break;
        }
      }
      if (j === 1)
        throw Error(invalidEncoding);
      return offset - start;
    };
    base649.test = function test(string3) {
      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string3);
    };
  }
});

// node_modules/@protobufjs/eventemitter/index.js
var require_eventemitter = __commonJS({
  "node_modules/@protobufjs/eventemitter/index.js"(exports2, module2) {
    "use strict";
    module2.exports = EventEmitter;
    function EventEmitter() {
      this._listeners = {};
    }
    EventEmitter.prototype.on = function on(evt, fn, ctx) {
      (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn,
        ctx: ctx || this
      });
      return this;
    };
    EventEmitter.prototype.off = function off(evt, fn) {
      if (evt === void 0)
        this._listeners = {};
      else {
        if (fn === void 0)
          this._listeners[evt] = [];
        else {
          var listeners = this._listeners[evt];
          for (var i = 0; i < listeners.length; )
            if (listeners[i].fn === fn)
              listeners.splice(i, 1);
            else
              ++i;
        }
      }
      return this;
    };
    EventEmitter.prototype.emit = function emit(evt) {
      var listeners = this._listeners[evt];
      if (listeners) {
        var args = [], i = 1;
        for (; i < arguments.length; )
          args.push(arguments[i++]);
        for (i = 0; i < listeners.length; )
          listeners[i].fn.apply(listeners[i++].ctx, args);
      }
      return this;
    };
  }
});

// node_modules/@protobufjs/float/index.js
var require_float = __commonJS({
  "node_modules/@protobufjs/float/index.js"(exports2, module2) {
    "use strict";
    module2.exports = factory(factory);
    function factory(exports3) {
      if (typeof Float32Array !== "undefined") (function() {
        var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
        function writeFloat_f32_cpy(val, buf2, pos) {
          f32[0] = val;
          buf2[pos] = f8b[0];
          buf2[pos + 1] = f8b[1];
          buf2[pos + 2] = f8b[2];
          buf2[pos + 3] = f8b[3];
        }
        function writeFloat_f32_rev(val, buf2, pos) {
          f32[0] = val;
          buf2[pos] = f8b[3];
          buf2[pos + 1] = f8b[2];
          buf2[pos + 2] = f8b[1];
          buf2[pos + 3] = f8b[0];
        }
        exports3.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        exports3.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
        function readFloat_f32_cpy(buf2, pos) {
          f8b[0] = buf2[pos];
          f8b[1] = buf2[pos + 1];
          f8b[2] = buf2[pos + 2];
          f8b[3] = buf2[pos + 3];
          return f32[0];
        }
        function readFloat_f32_rev(buf2, pos) {
          f8b[3] = buf2[pos];
          f8b[2] = buf2[pos + 1];
          f8b[1] = buf2[pos + 2];
          f8b[0] = buf2[pos + 3];
          return f32[0];
        }
        exports3.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        exports3.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
      })();
      else (function() {
        function writeFloat_ieee754(writeUint, val, buf2, pos) {
          var sign = val < 0 ? 1 : 0;
          if (sign)
            val = -val;
          if (val === 0)
            writeUint(1 / val > 0 ? (
              /* positive */
              0
            ) : (
              /* negative 0 */
              2147483648
            ), buf2, pos);
          else if (isNaN(val))
            writeUint(2143289344, buf2, pos);
          else if (val > 34028234663852886e22)
            writeUint((sign << 31 | 2139095040) >>> 0, buf2, pos);
          else if (val < 11754943508222875e-54)
            writeUint((sign << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf2, pos);
          else {
            var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
            writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf2, pos);
          }
        }
        exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
        function readFloat_ieee754(readUint, buf2, pos) {
          var uint = readUint(buf2, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
          return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 1401298464324817e-60 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }
        exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
      })();
      if (typeof Float64Array !== "undefined") (function() {
        var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
        function writeDouble_f64_cpy(val, buf2, pos) {
          f64[0] = val;
          buf2[pos] = f8b[0];
          buf2[pos + 1] = f8b[1];
          buf2[pos + 2] = f8b[2];
          buf2[pos + 3] = f8b[3];
          buf2[pos + 4] = f8b[4];
          buf2[pos + 5] = f8b[5];
          buf2[pos + 6] = f8b[6];
          buf2[pos + 7] = f8b[7];
        }
        function writeDouble_f64_rev(val, buf2, pos) {
          f64[0] = val;
          buf2[pos] = f8b[7];
          buf2[pos + 1] = f8b[6];
          buf2[pos + 2] = f8b[5];
          buf2[pos + 3] = f8b[4];
          buf2[pos + 4] = f8b[3];
          buf2[pos + 5] = f8b[2];
          buf2[pos + 6] = f8b[1];
          buf2[pos + 7] = f8b[0];
        }
        exports3.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
        exports3.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
        function readDouble_f64_cpy(buf2, pos) {
          f8b[0] = buf2[pos];
          f8b[1] = buf2[pos + 1];
          f8b[2] = buf2[pos + 2];
          f8b[3] = buf2[pos + 3];
          f8b[4] = buf2[pos + 4];
          f8b[5] = buf2[pos + 5];
          f8b[6] = buf2[pos + 6];
          f8b[7] = buf2[pos + 7];
          return f64[0];
        }
        function readDouble_f64_rev(buf2, pos) {
          f8b[7] = buf2[pos];
          f8b[6] = buf2[pos + 1];
          f8b[5] = buf2[pos + 2];
          f8b[4] = buf2[pos + 3];
          f8b[3] = buf2[pos + 4];
          f8b[2] = buf2[pos + 5];
          f8b[1] = buf2[pos + 6];
          f8b[0] = buf2[pos + 7];
          return f64[0];
        }
        exports3.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
        exports3.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
      })();
      else (function() {
        function writeDouble_ieee754(writeUint, off0, off1, val, buf2, pos) {
          var sign = val < 0 ? 1 : 0;
          if (sign)
            val = -val;
          if (val === 0) {
            writeUint(0, buf2, pos + off0);
            writeUint(1 / val > 0 ? (
              /* positive */
              0
            ) : (
              /* negative 0 */
              2147483648
            ), buf2, pos + off1);
          } else if (isNaN(val)) {
            writeUint(0, buf2, pos + off0);
            writeUint(2146959360, buf2, pos + off1);
          } else if (val > 17976931348623157e292) {
            writeUint(0, buf2, pos + off0);
            writeUint((sign << 31 | 2146435072) >>> 0, buf2, pos + off1);
          } else {
            var mantissa;
            if (val < 22250738585072014e-324) {
              mantissa = val / 5e-324;
              writeUint(mantissa >>> 0, buf2, pos + off0);
              writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf2, pos + off1);
            } else {
              var exponent = Math.floor(Math.log(val) / Math.LN2);
              if (exponent === 1024)
                exponent = 1023;
              mantissa = val * Math.pow(2, -exponent);
              writeUint(mantissa * 4503599627370496 >>> 0, buf2, pos + off0);
              writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf2, pos + off1);
            }
          }
        }
        exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
        exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
        function readDouble_ieee754(readUint, off0, off1, buf2, pos) {
          var lo = readUint(buf2, pos + off0), hi = readUint(buf2, pos + off1);
          var sign = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
          return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
        }
        exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
        exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
      })();
      return exports3;
    }
    function writeUintLE(val, buf2, pos) {
      buf2[pos] = val & 255;
      buf2[pos + 1] = val >>> 8 & 255;
      buf2[pos + 2] = val >>> 16 & 255;
      buf2[pos + 3] = val >>> 24;
    }
    function writeUintBE(val, buf2, pos) {
      buf2[pos] = val >>> 24;
      buf2[pos + 1] = val >>> 16 & 255;
      buf2[pos + 2] = val >>> 8 & 255;
      buf2[pos + 3] = val & 255;
    }
    function readUintLE(buf2, pos) {
      return (buf2[pos] | buf2[pos + 1] << 8 | buf2[pos + 2] << 16 | buf2[pos + 3] << 24) >>> 0;
    }
    function readUintBE(buf2, pos) {
      return (buf2[pos] << 24 | buf2[pos + 1] << 16 | buf2[pos + 2] << 8 | buf2[pos + 3]) >>> 0;
    }
  }
});

// node_modules/@protobufjs/inquire/index.js
var require_inquire = __commonJS({
  "node_modules/@protobufjs/inquire/index.js"(exports, module) {
    "use strict";
    module.exports = inquire;
    function inquire(moduleName) {
      try {
        var mod = eval("quire".replace(/^/, "re"))(moduleName);
        if (mod && (mod.length || Object.keys(mod).length))
          return mod;
      } catch (e) {
      }
      return null;
    }
  }
});

// node_modules/@protobufjs/utf8/index.js
var require_utf8 = __commonJS({
  "node_modules/@protobufjs/utf8/index.js"(exports2) {
    "use strict";
    var utf8 = exports2;
    utf8.length = function utf8_length(string3) {
      var len = 0, c = 0;
      for (var i = 0; i < string3.length; ++i) {
        c = string3.charCodeAt(i);
        if (c < 128)
          len += 1;
        else if (c < 2048)
          len += 2;
        else if ((c & 64512) === 55296 && (string3.charCodeAt(i + 1) & 64512) === 56320) {
          ++i;
          len += 4;
        } else
          len += 3;
      }
      return len;
    };
    utf8.read = function utf8_read(buffer2, start, end) {
      var len = end - start;
      if (len < 1)
        return "";
      var parts = null, chunk = [], i = 0, t;
      while (start < end) {
        t = buffer2[start++];
        if (t < 128)
          chunk[i++] = t;
        else if (t > 191 && t < 224)
          chunk[i++] = (t & 31) << 6 | buffer2[start++] & 63;
        else if (t > 239 && t < 365) {
          t = ((t & 7) << 18 | (buffer2[start++] & 63) << 12 | (buffer2[start++] & 63) << 6 | buffer2[start++] & 63) - 65536;
          chunk[i++] = 55296 + (t >> 10);
          chunk[i++] = 56320 + (t & 1023);
        } else
          chunk[i++] = (t & 15) << 12 | (buffer2[start++] & 63) << 6 | buffer2[start++] & 63;
        if (i > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i = 0;
        }
      }
      if (parts) {
        if (i)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i));
    };
    utf8.write = function utf8_write(string3, buffer2, offset) {
      var start = offset, c1, c2;
      for (var i = 0; i < string3.length; ++i) {
        c1 = string3.charCodeAt(i);
        if (c1 < 128) {
          buffer2[offset++] = c1;
        } else if (c1 < 2048) {
          buffer2[offset++] = c1 >> 6 | 192;
          buffer2[offset++] = c1 & 63 | 128;
        } else if ((c1 & 64512) === 55296 && ((c2 = string3.charCodeAt(i + 1)) & 64512) === 56320) {
          c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
          ++i;
          buffer2[offset++] = c1 >> 18 | 240;
          buffer2[offset++] = c1 >> 12 & 63 | 128;
          buffer2[offset++] = c1 >> 6 & 63 | 128;
          buffer2[offset++] = c1 & 63 | 128;
        } else {
          buffer2[offset++] = c1 >> 12 | 224;
          buffer2[offset++] = c1 >> 6 & 63 | 128;
          buffer2[offset++] = c1 & 63 | 128;
        }
      }
      return offset - start;
    };
  }
});

// node_modules/@protobufjs/pool/index.js
var require_pool = __commonJS({
  "node_modules/@protobufjs/pool/index.js"(exports2, module2) {
    "use strict";
    module2.exports = pool;
    function pool(alloc2, slice2, size) {
      var SIZE = size || 8192;
      var MAX = SIZE >>> 1;
      var slab = null;
      var offset = SIZE;
      return function pool_alloc(size2) {
        if (size2 < 1 || size2 > MAX)
          return alloc2(size2);
        if (offset + size2 > SIZE) {
          slab = alloc2(SIZE);
          offset = 0;
        }
        var buf2 = slice2.call(slab, offset, offset += size2);
        if (offset & 7)
          offset = (offset | 7) + 1;
        return buf2;
      };
    }
  }
});

// node_modules/protobufjs/src/util/longbits.js
var require_longbits = __commonJS({
  "node_modules/protobufjs/src/util/longbits.js"(exports2, module2) {
    "use strict";
    module2.exports = LongBits;
    var util = require_minimal();
    function LongBits(lo, hi) {
      this.lo = lo >>> 0;
      this.hi = hi >>> 0;
    }
    var zero = LongBits.zero = new LongBits(0, 0);
    zero.toNumber = function() {
      return 0;
    };
    zero.zzEncode = zero.zzDecode = function() {
      return this;
    };
    zero.length = function() {
      return 1;
    };
    var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
    LongBits.fromNumber = function fromNumber(value) {
      if (value === 0)
        return zero;
      var sign = value < 0;
      if (sign)
        value = -value;
      var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
      if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
          lo = 0;
          if (++hi > 4294967295)
            hi = 0;
        }
      }
      return new LongBits(lo, hi);
    };
    LongBits.from = function from17(value) {
      if (typeof value === "number")
        return LongBits.fromNumber(value);
      if (util.isString(value)) {
        if (util.Long)
          value = util.Long.fromString(value);
        else
          return LongBits.fromNumber(parseInt(value, 10));
      }
      return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
    };
    LongBits.prototype.toNumber = function toNumber(unsigned) {
      if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
        if (!lo)
          hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
    };
    LongBits.prototype.toLong = function toLong(unsigned) {
      return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
    };
    var charCodeAt = String.prototype.charCodeAt;
    LongBits.fromHash = function fromHash(hash) {
      if (hash === zeroHash)
        return zero;
      return new LongBits(
        (charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0,
        (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0
      );
    };
    LongBits.prototype.toHash = function toHash() {
      return String.fromCharCode(
        this.lo & 255,
        this.lo >>> 8 & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24,
        this.hi & 255,
        this.hi >>> 8 & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
      );
    };
    LongBits.prototype.zzEncode = function zzEncode() {
      var mask = this.hi >> 31;
      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
      this.lo = (this.lo << 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.zzDecode = function zzDecode() {
      var mask = -(this.lo & 1);
      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
      this.hi = (this.hi >>> 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.length = function length11() {
      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    };
  }
});

// node_modules/protobufjs/src/util/minimal.js
var require_minimal = __commonJS({
  "node_modules/protobufjs/src/util/minimal.js"(exports2) {
    "use strict";
    var util = exports2;
    util.asPromise = require_aspromise();
    util.base64 = require_base64();
    util.EventEmitter = require_eventemitter();
    util.float = require_float();
    util.inquire = require_inquire();
    util.utf8 = require_utf8();
    util.pool = require_pool();
    util.LongBits = require_longbits();
    util.isNode = Boolean(typeof global !== "undefined" && global && global.process && global.process.versions && global.process.versions.node);
    util.global = util.isNode && global || typeof window !== "undefined" && window || typeof self !== "undefined" && self || exports2;
    util.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    );
    util.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    );
    util.isInteger = Number.isInteger || /* istanbul ignore next */
    function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    };
    util.isString = function isString(value) {
      return typeof value === "string" || value instanceof String;
    };
    util.isObject = function isObject(value) {
      return value && typeof value === "object";
    };
    util.isset = /**
     * Checks if a property on a message is considered to be present.
     * @param {Object} obj Plain object or message instance
     * @param {string} prop Property name
     * @returns {boolean} `true` if considered to be present, otherwise `false`
     */
    util.isSet = function isSet(obj, prop) {
      var value = obj[prop];
      if (value != null && obj.hasOwnProperty(prop))
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
      return false;
    };
    util.Buffer = (function() {
      try {
        var Buffer3 = util.inquire("buffer").Buffer;
        return Buffer3.prototype.utf8Write ? Buffer3 : (
          /* istanbul ignore next */
          null
        );
      } catch (e) {
        return null;
      }
    })();
    util._Buffer_from = null;
    util._Buffer_allocUnsafe = null;
    util.newBuffer = function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    };
    util.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util.Long = /* istanbul ignore next */
    util.global.dcodeIO && /* istanbul ignore next */
    util.global.dcodeIO.Long || /* istanbul ignore next */
    util.global.Long || util.inquire("long");
    util.key2Re = /^true|false|0|1$/;
    util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util.longToHash = function longToHash(value) {
      return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
    };
    util.longFromHash = function longFromHash(hash, unsigned) {
      var bits = util.LongBits.fromHash(hash);
      if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
      return bits.toNumber(Boolean(unsigned));
    };
    function merge2(dst, src12, ifNotSet) {
      for (var keys = Object.keys(src12), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === void 0 || !ifNotSet)
          dst[keys[i]] = src12[keys[i]];
      return dst;
    }
    util.merge = merge2;
    util.lcFirst = function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    };
    function newError(name12) {
      function CustomError(message, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message, properties);
        Object.defineProperty(this, "message", { get: function() {
          return message;
        } });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge2(this, properties);
      }
      CustomError.prototype = Object.create(Error.prototype, {
        constructor: {
          value: CustomError,
          writable: true,
          enumerable: false,
          configurable: true
        },
        name: {
          get: function get() {
            return name12;
          },
          set: void 0,
          enumerable: false,
          // configurable: false would accurately preserve the behavior of
          // the original, but I'm guessing that was not intentional.
          // For an actual error subclass, this property would
          // be configurable.
          configurable: true
        },
        toString: {
          value: function value() {
            return this.name + ": " + this.message;
          },
          writable: true,
          enumerable: false,
          configurable: true
        }
      });
      return CustomError;
    }
    util.newError = newError;
    util.ProtocolError = newError("ProtocolError");
    util.oneOfGetter = function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;
      return function() {
        for (var keys = Object.keys(this), i2 = keys.length - 1; i2 > -1; --i2)
          if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== void 0 && this[keys[i2]] !== null)
            return keys[i2];
      };
    };
    util.oneOfSetter = function setOneOf(fieldNames) {
      return function(name12) {
        for (var i = 0; i < fieldNames.length; ++i)
          if (fieldNames[i] !== name12)
            delete this[fieldNames[i]];
      };
    };
    util.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util._configure = function() {
      var Buffer3 = util.Buffer;
      if (!Buffer3) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
      }
      util._Buffer_from = Buffer3.from !== Uint8Array.from && Buffer3.from || /* istanbul ignore next */
      function Buffer_from(value, encoding) {
        return new Buffer3(value, encoding);
      };
      util._Buffer_allocUnsafe = Buffer3.allocUnsafe || /* istanbul ignore next */
      function Buffer_allocUnsafe(size) {
        return new Buffer3(size);
      };
    };
  }
});

// node_modules/protobufjs/src/writer.js
var require_writer = __commonJS({
  "node_modules/protobufjs/src/writer.js"(exports2, module2) {
    "use strict";
    module2.exports = Writer;
    var util = require_minimal();
    var BufferWriter;
    var LongBits = util.LongBits;
    var base649 = util.base64;
    var utf8 = util.utf8;
    function Op(fn, len, val) {
      this.fn = fn;
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    function noop() {
    }
    function State(writer) {
      this.head = writer.head;
      this.tail = writer.tail;
      this.len = writer.len;
      this.next = writer.states;
    }
    function Writer() {
      this.len = 0;
      this.head = new Op(noop, 0, 0);
      this.tail = this.head;
      this.states = null;
    }
    var create12 = function create13() {
      return util.Buffer ? function create_buffer_setup() {
        return (Writer.create = function create_buffer() {
          return new BufferWriter();
        })();
      } : function create_array() {
        return new Writer();
      };
    };
    Writer.create = create12();
    Writer.alloc = function alloc2(size) {
      return new util.Array(size);
    };
    if (util.Array !== Array)
      Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);
    Writer.prototype._push = function push(fn, len, val) {
      this.tail = this.tail.next = new Op(fn, len, val);
      this.len += len;
      return this;
    };
    function writeByte(val, buf2, pos) {
      buf2[pos] = val & 255;
    }
    function writeVarint32(val, buf2, pos) {
      while (val > 127) {
        buf2[pos++] = val & 127 | 128;
        val >>>= 7;
      }
      buf2[pos] = val;
    }
    function VarintOp(len, val) {
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    VarintOp.prototype = Object.create(Op.prototype);
    VarintOp.prototype.fn = writeVarint32;
    Writer.prototype.uint32 = function write_uint32(value) {
      this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,
        value
      )).len;
      return this;
    };
    Writer.prototype.int32 = function write_int32(value) {
      return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
    };
    Writer.prototype.sint32 = function write_sint32(value) {
      return this.uint32((value << 1 ^ value >> 31) >>> 0);
    };
    function writeVarint64(val, buf2, pos) {
      while (val.hi) {
        buf2[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
      }
      while (val.lo > 127) {
        buf2[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
      }
      buf2[pos++] = val.lo;
    }
    Writer.prototype.uint64 = function write_uint64(value) {
      var bits = LongBits.from(value);
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.int64 = Writer.prototype.uint64;
    Writer.prototype.sint64 = function write_sint64(value) {
      var bits = LongBits.from(value).zzEncode();
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.bool = function write_bool(value) {
      return this._push(writeByte, 1, value ? 1 : 0);
    };
    function writeFixed32(val, buf2, pos) {
      buf2[pos] = val & 255;
      buf2[pos + 1] = val >>> 8 & 255;
      buf2[pos + 2] = val >>> 16 & 255;
      buf2[pos + 3] = val >>> 24;
    }
    Writer.prototype.fixed32 = function write_fixed32(value) {
      return this._push(writeFixed32, 4, value >>> 0);
    };
    Writer.prototype.sfixed32 = Writer.prototype.fixed32;
    Writer.prototype.fixed64 = function write_fixed64(value) {
      var bits = LongBits.from(value);
      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
    };
    Writer.prototype.sfixed64 = Writer.prototype.fixed64;
    Writer.prototype.float = function write_float(value) {
      return this._push(util.float.writeFloatLE, 4, value);
    };
    Writer.prototype.double = function write_double(value) {
      return this._push(util.float.writeDoubleLE, 8, value);
    };
    var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf2, pos) {
      buf2.set(val, pos);
    } : function writeBytes_for(val, buf2, pos) {
      for (var i = 0; i < val.length; ++i)
        buf2[pos + i] = val[i];
    };
    Writer.prototype.bytes = function write_bytes(value) {
      var len = value.length >>> 0;
      if (!len)
        return this._push(writeByte, 1, 0);
      if (util.isString(value)) {
        var buf2 = Writer.alloc(len = base649.length(value));
        base649.decode(value, buf2, 0);
        value = buf2;
      }
      return this.uint32(len)._push(writeBytes, len, value);
    };
    Writer.prototype.string = function write_string(value) {
      var len = utf8.length(value);
      return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
    };
    Writer.prototype.fork = function fork() {
      this.states = new State(this);
      this.head = this.tail = new Op(noop, 0, 0);
      this.len = 0;
      return this;
    };
    Writer.prototype.reset = function reset() {
      if (this.states) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
      } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len = 0;
      }
      return this;
    };
    Writer.prototype.ldelim = function ldelim() {
      var head = this.head, tail = this.tail, len = this.len;
      this.reset().uint32(len);
      if (len) {
        this.tail.next = head.next;
        this.tail = tail;
        this.len += len;
      }
      return this;
    };
    Writer.prototype.finish = function finish() {
      var head = this.head.next, buf2 = this.constructor.alloc(this.len), pos = 0;
      while (head) {
        head.fn(head.val, buf2, pos);
        pos += head.len;
        head = head.next;
      }
      return buf2;
    };
    Writer._configure = function(BufferWriter_) {
      BufferWriter = BufferWriter_;
      Writer.create = create12();
      BufferWriter._configure();
    };
  }
});

// node_modules/protobufjs/src/writer_buffer.js
var require_writer_buffer = __commonJS({
  "node_modules/protobufjs/src/writer_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferWriter;
    var Writer = require_writer();
    (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
    var util = require_minimal();
    function BufferWriter() {
      Writer.call(this);
    }
    BufferWriter._configure = function() {
      BufferWriter.alloc = util._Buffer_allocUnsafe;
      BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf2, pos) {
        buf2.set(val, pos);
      } : function writeBytesBuffer_copy(val, buf2, pos) {
        if (val.copy)
          val.copy(buf2, pos, 0, val.length);
        else for (var i = 0; i < val.length; )
          buf2[pos++] = val[i++];
      };
    };
    BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
      if (util.isString(value))
        value = util._Buffer_from(value, "base64");
      var len = value.length >>> 0;
      this.uint32(len);
      if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
      return this;
    };
    function writeStringBuffer(val, buf2, pos) {
      if (val.length < 40)
        util.utf8.write(val, buf2, pos);
      else if (buf2.utf8Write)
        buf2.utf8Write(val, pos);
      else
        buf2.write(val, pos);
    }
    BufferWriter.prototype.string = function write_string_buffer(value) {
      var len = util.Buffer.byteLength(value);
      this.uint32(len);
      if (len)
        this._push(writeStringBuffer, len, value);
      return this;
    };
    BufferWriter._configure();
  }
});

// node_modules/protobufjs/src/reader.js
var require_reader = __commonJS({
  "node_modules/protobufjs/src/reader.js"(exports2, module2) {
    "use strict";
    module2.exports = Reader;
    var util = require_minimal();
    var BufferReader;
    var LongBits = util.LongBits;
    var utf8 = util.utf8;
    function indexOutOfRange(reader, writeLength) {
      return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
    }
    function Reader(buffer2) {
      this.buf = buffer2;
      this.pos = 0;
      this.len = buffer2.length;
    }
    var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer2) {
      if (buffer2 instanceof Uint8Array || Array.isArray(buffer2))
        return new Reader(buffer2);
      throw Error("illegal buffer");
    } : function create_array2(buffer2) {
      if (Array.isArray(buffer2))
        return new Reader(buffer2);
      throw Error("illegal buffer");
    };
    var create12 = function create13() {
      return util.Buffer ? function create_buffer_setup(buffer2) {
        return (Reader.create = function create_buffer(buffer3) {
          return util.Buffer.isBuffer(buffer3) ? new BufferReader(buffer3) : create_array(buffer3);
        })(buffer2);
      } : create_array;
    };
    Reader.create = create12();
    Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */
    util.Array.prototype.slice;
    Reader.prototype.uint32 = /* @__PURE__ */ (function read_uint32_setup() {
      var value = 4294967295;
      return function read_uint32() {
        value = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        if ((this.pos += 5) > this.len) {
          this.pos = this.len;
          throw indexOutOfRange(this, 10);
        }
        return value;
      };
    })();
    Reader.prototype.int32 = function read_int32() {
      return this.uint32() | 0;
    };
    Reader.prototype.sint32 = function read_sint32() {
      var value = this.uint32();
      return value >>> 1 ^ -(value & 1) | 0;
    };
    function readLongVarint() {
      var bits = new LongBits(0, 0);
      var i = 0;
      if (this.len - this.pos > 4) {
        for (; i < 4; ++i) {
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
        i = 0;
      } else {
        for (; i < 3; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
      }
      if (this.len - this.pos > 4) {
        for (; i < 5; ++i) {
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      } else {
        for (; i < 5; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      }
      throw Error("invalid varint encoding");
    }
    Reader.prototype.bool = function read_bool() {
      return this.uint32() !== 0;
    };
    function readFixed32_end(buf2, end) {
      return (buf2[end - 4] | buf2[end - 3] << 8 | buf2[end - 2] << 16 | buf2[end - 1] << 24) >>> 0;
    }
    Reader.prototype.fixed32 = function read_fixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4);
    };
    Reader.prototype.sfixed32 = function read_sfixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4) | 0;
    };
    function readFixed64() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);
      return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
    }
    Reader.prototype.float = function read_float() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readFloatLE(this.buf, this.pos);
      this.pos += 4;
      return value;
    };
    Reader.prototype.double = function read_double() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readDoubleLE(this.buf, this.pos);
      this.pos += 8;
      return value;
    };
    Reader.prototype.bytes = function read_bytes() {
      var length11 = this.uint32(), start = this.pos, end = this.pos + length11;
      if (end > this.len)
        throw indexOutOfRange(this, length11);
      this.pos += length11;
      if (Array.isArray(this.buf))
        return this.buf.slice(start, end);
      if (start === end) {
        var nativeBuffer = util.Buffer;
        return nativeBuffer ? nativeBuffer.alloc(0) : new this.buf.constructor(0);
      }
      return this._slice.call(this.buf, start, end);
    };
    Reader.prototype.string = function read_string() {
      var bytes = this.bytes();
      return utf8.read(bytes, 0, bytes.length);
    };
    Reader.prototype.skip = function skip(length11) {
      if (typeof length11 === "number") {
        if (this.pos + length11 > this.len)
          throw indexOutOfRange(this, length11);
        this.pos += length11;
      } else {
        do {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
      }
      return this;
    };
    Reader.prototype.skipType = function(wireType) {
      switch (wireType) {
        case 0:
          this.skip();
          break;
        case 1:
          this.skip(8);
          break;
        case 2:
          this.skip(this.uint32());
          break;
        case 3:
          while ((wireType = this.uint32() & 7) !== 4) {
            this.skipType(wireType);
          }
          break;
        case 5:
          this.skip(4);
          break;
        /* istanbul ignore next */
        default:
          throw Error("invalid wire type " + wireType + " at offset " + this.pos);
      }
      return this;
    };
    Reader._configure = function(BufferReader_) {
      BufferReader = BufferReader_;
      Reader.create = create12();
      BufferReader._configure();
      var fn = util.Long ? "toLong" : (
        /* istanbul ignore next */
        "toNumber"
      );
      util.merge(Reader.prototype, {
        int64: function read_int64() {
          return readLongVarint.call(this)[fn](false);
        },
        uint64: function read_uint64() {
          return readLongVarint.call(this)[fn](true);
        },
        sint64: function read_sint64() {
          return readLongVarint.call(this).zzDecode()[fn](false);
        },
        fixed64: function read_fixed64() {
          return readFixed64.call(this)[fn](true);
        },
        sfixed64: function read_sfixed64() {
          return readFixed64.call(this)[fn](false);
        }
      });
    };
  }
});

// node_modules/protobufjs/src/reader_buffer.js
var require_reader_buffer = __commonJS({
  "node_modules/protobufjs/src/reader_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferReader;
    var Reader = require_reader();
    (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
    var util = require_minimal();
    function BufferReader(buffer2) {
      Reader.call(this, buffer2);
    }
    BufferReader._configure = function() {
      if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
    };
    BufferReader.prototype.string = function read_string_buffer() {
      var len = this.uint32();
      return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
    };
    BufferReader._configure();
  }
});

// node_modules/protobufjs/src/rpc/service.js
var require_service = __commonJS({
  "node_modules/protobufjs/src/rpc/service.js"(exports2, module2) {
    "use strict";
    module2.exports = Service;
    var util = require_minimal();
    (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
    function Service(rpcImpl, requestDelimited, responseDelimited) {
      if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");
      util.EventEmitter.call(this);
      this.rpcImpl = rpcImpl;
      this.requestDelimited = Boolean(requestDelimited);
      this.responseDelimited = Boolean(responseDelimited);
    }
    Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
      if (!request)
        throw TypeError("request must be specified");
      var self2 = this;
      if (!callback)
        return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
      if (!self2.rpcImpl) {
        setTimeout(function() {
          callback(Error("already ended"));
        }, 0);
        return void 0;
      }
      try {
        return self2.rpcImpl(
          method,
          requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
          function rpcCallback(err, response) {
            if (err) {
              self2.emit("error", err, method);
              return callback(err);
            }
            if (response === null) {
              self2.end(
                /* endedByRPC */
                true
              );
              return void 0;
            }
            if (!(response instanceof responseCtor)) {
              try {
                response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
              } catch (err2) {
                self2.emit("error", err2, method);
                return callback(err2);
              }
            }
            self2.emit("data", response, method);
            return callback(null, response);
          }
        );
      } catch (err) {
        self2.emit("error", err, method);
        setTimeout(function() {
          callback(err);
        }, 0);
        return void 0;
      }
    };
    Service.prototype.end = function end(endedByRPC) {
      if (this.rpcImpl) {
        if (!endedByRPC)
          this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
      }
      return this;
    };
  }
});

// node_modules/protobufjs/src/rpc.js
var require_rpc = __commonJS({
  "node_modules/protobufjs/src/rpc.js"(exports2) {
    "use strict";
    var rpc = exports2;
    rpc.Service = require_service();
  }
});

// node_modules/protobufjs/src/roots.js
var require_roots = __commonJS({
  "node_modules/protobufjs/src/roots.js"(exports2, module2) {
    "use strict";
    module2.exports = {};
  }
});

// node_modules/protobufjs/src/index-minimal.js
var require_index_minimal = __commonJS({
  "node_modules/protobufjs/src/index-minimal.js"(exports2) {
    "use strict";
    var protobuf = exports2;
    protobuf.build = "minimal";
    protobuf.Writer = require_writer();
    protobuf.BufferWriter = require_writer_buffer();
    protobuf.Reader = require_reader();
    protobuf.BufferReader = require_reader_buffer();
    protobuf.util = require_minimal();
    protobuf.rpc = require_rpc();
    protobuf.roots = require_roots();
    protobuf.configure = configure2;
    function configure2() {
      protobuf.util._configure();
      protobuf.Writer._configure(protobuf.BufferWriter);
      protobuf.Reader._configure(protobuf.BufferReader);
    }
    configure2();
  }
});

// node_modules/protobufjs/minimal.js
var require_minimal2 = __commonJS({
  "node_modules/protobufjs/minimal.js"(exports2, module2) {
    "use strict";
    module2.exports = require_index_minimal();
  }
});

// node_modules/stream-to-it/source.js
var require_source = __commonJS({
  "node_modules/stream-to-it/source.js"(exports2, module2) {
    module2.exports = (readable) => {
      if (readable[Symbol.asyncIterator]) return readable;
      if (readable.getReader) {
        return (async function* () {
          const reader = readable.getReader();
          try {
            while (true) {
              const { done, value } = await reader.read();
              if (done) return;
              yield value;
            }
          } finally {
            reader.releaseLock();
          }
        })();
      }
      throw new Error("unknown stream");
    };
  }
});

// node_modules/ipfs-utils/src/files/url-source.js
var require_url_source = __commonJS({
  "node_modules/ipfs-utils/src/files/url-source.js"(exports2, module2) {
    "use strict";
    var HTTP3 = require_http();
    var urlSource = (url, options) => {
      return {
        path: decodeURIComponent(new URL(url).pathname.split("/").pop() || ""),
        content: readURLContent(url, options)
      };
    };
    async function* readURLContent(url, options) {
      const http = new HTTP3();
      const response = await http.get(url, options);
      yield* response.iterator();
    }
    module2.exports = urlSource;
  }
});

// node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "node_modules/base64-js/index.js"(exports2) {
    "use strict";
    exports2.byteLength = byteLength;
    exports2.toByteArray = toByteArray;
    exports2.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code12 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code12.length; i < len; ++i) {
      lookup[i] = code12[i];
      revLookup[code12.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1) validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports2) {
    exports2.read = function(buffer2, offset, isLE3, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE3 ? nBytes - 1 : 0;
      var d = isLE3 ? -1 : 1;
      var s = buffer2[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer2[offset + i], i += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer2[offset + i], i += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports2.write = function(buffer2, value, offset, isLE3, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE3 ? 0 : nBytes - 1;
      var d = isLE3 ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer2[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer2[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
      }
      buffer2[offset + i - d] |= s * 128;
    };
  }
});

// node_modules/buffer/index.js
var require_buffer2 = __commonJS({
  "node_modules/buffer/index.js"(exports2) {
    "use strict";
    var base649 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports2.Buffer = Buffer3;
    exports2.SlowBuffer = SlowBuffer;
    exports2.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports2.kMaxLength = K_MAX_LENGTH;
    Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer3.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this)) return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer3.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this)) return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length11) {
      if (length11 > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length11 + '" is invalid for option "size"');
      }
      const buf2 = new Uint8Array(length11);
      Object.setPrototypeOf(buf2, Buffer3.prototype);
      return buf2;
    }
    function Buffer3(arg, encodingOrOffset, length11) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe4(arg);
      }
      return from17(arg, encodingOrOffset, length11);
    }
    Buffer3.poolSize = 8192;
    function from17(value, encodingOrOffset, length11) {
      if (typeof value === "string") {
        return fromString10(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length11);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length11);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer3.from(valueOf, encodingOrOffset, length11);
      }
      const b = fromObject(value);
      if (b) return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer3.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length11);
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    Buffer3.from = function(value, encodingOrOffset, length11) {
      return from17(value, encodingOrOffset, length11);
    };
    Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer3, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc2(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer3.alloc = function(size, fill, encoding) {
      return alloc2(size, fill, encoding);
    };
    function allocUnsafe4(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer3.allocUnsafe = function(size) {
      return allocUnsafe4(size);
    };
    Buffer3.allocUnsafeSlow = function(size) {
      return allocUnsafe4(size);
    };
    function fromString10(string3, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer3.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length11 = byteLength(string3, encoding) | 0;
      let buf2 = createBuffer(length11);
      const actual = buf2.write(string3, encoding);
      if (actual !== length11) {
        buf2 = buf2.slice(0, actual);
      }
      return buf2;
    }
    function fromArrayLike(array) {
      const length11 = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf2 = createBuffer(length11);
      for (let i = 0; i < length11; i += 1) {
        buf2[i] = array[i] & 255;
      }
      return buf2;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length11) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length11 || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf2;
      if (byteOffset === void 0 && length11 === void 0) {
        buf2 = new Uint8Array(array);
      } else if (length11 === void 0) {
        buf2 = new Uint8Array(array, byteOffset);
      } else {
        buf2 = new Uint8Array(array, byteOffset, length11);
      }
      Object.setPrototypeOf(buf2, Buffer3.prototype);
      return buf2;
    }
    function fromObject(obj) {
      if (Buffer3.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf2 = createBuffer(len);
        if (buf2.length === 0) {
          return buf2;
        }
        obj.copy(buf2, 0, 0, len);
        return buf2;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length11) {
      if (length11 >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length11 | 0;
    }
    function SlowBuffer(length11) {
      if (+length11 != length11) {
        length11 = 0;
      }
      return Buffer3.alloc(+length11);
    }
    Buffer3.isBuffer = function isBuffer3(b) {
      return b != null && b._isBuffer === true && b !== Buffer3.prototype;
    };
    Buffer3.compare = function compare2(a, b) {
      if (isInstance(a, Uint8Array)) a = Buffer3.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array)) b = Buffer3.from(b, b.offset, b.byteLength);
      if (!Buffer3.isBuffer(a) || !Buffer3.isBuffer(b)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a === b) return 0;
      let x = a.length;
      let y = b.length;
      for (let i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    };
    Buffer3.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer3.concat = function concat4(list, length11) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer3.alloc(0);
      }
      let i;
      if (length11 === void 0) {
        length11 = 0;
        for (i = 0; i < list.length; ++i) {
          length11 += list[i].length;
        }
      }
      const buffer2 = Buffer3.allocUnsafe(length11);
      let pos = 0;
      for (i = 0; i < list.length; ++i) {
        let buf2 = list[i];
        if (isInstance(buf2, Uint8Array)) {
          if (pos + buf2.length > buffer2.length) {
            if (!Buffer3.isBuffer(buf2)) buf2 = Buffer3.from(buf2);
            buf2.copy(buffer2, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer2,
              buf2,
              pos
            );
          }
        } else if (!Buffer3.isBuffer(buf2)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf2.copy(buffer2, pos);
        }
        pos += buf2.length;
      }
      return buffer2;
    };
    function byteLength(string3, encoding) {
      if (Buffer3.isBuffer(string3)) {
        return string3.length;
      }
      if (ArrayBuffer.isView(string3) || isInstance(string3, ArrayBuffer)) {
        return string3.byteLength;
      }
      if (typeof string3 !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string3
        );
      }
      const len = string3.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0) return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes3(string3).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string3).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes3(string3).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding) encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice2(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.prototype._isBuffer = true;
    function swap(b, n, m) {
      const i = b[n];
      b[n] = b[m];
      b[m] = i;
    }
    Buffer3.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer3.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer3.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer3.prototype.toString = function toString10() {
      const length11 = this.length;
      if (length11 === 0) return "";
      if (arguments.length === 0) return utf8Slice2(this, 0, length11);
      return slowToString.apply(this, arguments);
    };
    Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
    Buffer3.prototype.equals = function equals23(b) {
      if (!Buffer3.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
      if (this === b) return true;
      return Buffer3.compare(this, b) === 0;
    };
    Buffer3.prototype.inspect = function inspect4() {
      let str = "";
      const max = exports2.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max) str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
    }
    Buffer3.prototype.compare = function compare2(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer3.from(target, target.offset, target.byteLength);
      }
      if (!Buffer3.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target) return 0;
      let x = thisEnd - thisStart;
      let y = end - start;
      const len = Math.min(x, y);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
      if (buffer2.length === 0) return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer2.length - 1;
      }
      if (byteOffset < 0) byteOffset = buffer2.length + byteOffset;
      if (byteOffset >= buffer2.length) {
        if (dir) return -1;
        else byteOffset = buffer2.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
      }
      if (typeof val === "string") {
        val = Buffer3.from(val, encoding);
      }
      if (Buffer3.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read11(buf2, i2) {
        if (indexSize === 1) {
          return buf2[i2];
        } else {
          return buf2.readUInt16BE(i2 * indexSize);
        }
      }
      let i;
      if (dir) {
        let foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read11(arr, i) === read11(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          let found = true;
          for (let j = 0; j < valLength; j++) {
            if (read11(arr, i + j) !== read11(val, j)) {
              found = false;
              break;
            }
          }
          if (found) return i;
        }
      }
      return -1;
    }
    Buffer3.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf2, string3, offset, length11) {
      offset = Number(offset) || 0;
      const remaining = buf2.length - offset;
      if (!length11) {
        length11 = remaining;
      } else {
        length11 = Number(length11);
        if (length11 > remaining) {
          length11 = remaining;
        }
      }
      const strLen = string3.length;
      if (length11 > strLen / 2) {
        length11 = strLen / 2;
      }
      let i;
      for (i = 0; i < length11; ++i) {
        const parsed = parseInt(string3.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf2[offset + i] = parsed;
      }
      return i;
    }
    function utf8Write(buf2, string3, offset, length11) {
      return blitBuffer(utf8ToBytes3(string3, buf2.length - offset), buf2, offset, length11);
    }
    function asciiWrite(buf2, string3, offset, length11) {
      return blitBuffer(asciiToBytes(string3), buf2, offset, length11);
    }
    function base64Write(buf2, string3, offset, length11) {
      return blitBuffer(base64ToBytes(string3), buf2, offset, length11);
    }
    function ucs2Write(buf2, string3, offset, length11) {
      return blitBuffer(utf16leToBytes(string3, buf2.length - offset), buf2, offset, length11);
    }
    Buffer3.prototype.write = function write(string3, offset, length11, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length11 = this.length;
        offset = 0;
      } else if (length11 === void 0 && typeof offset === "string") {
        encoding = offset;
        length11 = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length11)) {
          length11 = length11 >>> 0;
          if (encoding === void 0) encoding = "utf8";
        } else {
          encoding = length11;
          length11 = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      const remaining = this.length - offset;
      if (length11 === void 0 || length11 > remaining) length11 = remaining;
      if (string3.length > 0 && (length11 < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding) encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string3, offset, length11);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string3, offset, length11);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string3, offset, length11);
          case "base64":
            return base64Write(this, string3, offset, length11);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string3, offset, length11);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer3.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf2, start, end) {
      if (start === 0 && end === buf2.length) {
        return base649.fromByteArray(buf2);
      } else {
        return base649.fromByteArray(buf2.slice(start, end));
      }
    }
    function utf8Slice2(buf2, start, end) {
      end = Math.min(buf2.length, end);
      const res = [];
      let i = start;
      while (i < end) {
        const firstByte = buf2[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf2[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf2[i + 1];
              thirdByte = buf2[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf2[i + 1];
              thirdByte = buf2[i + 2];
              fourthByte = buf2[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray2(res);
    }
    var MAX_ARGUMENTS_LENGTH2 = 4096;
    function decodeCodePointsArray2(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH2) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH2)
        );
      }
      return res;
    }
    function asciiSlice(buf2, start, end) {
      let ret = "";
      end = Math.min(buf2.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf2[i] & 127);
      }
      return ret;
    }
    function latin1Slice(buf2, start, end) {
      let ret = "";
      end = Math.min(buf2.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf2[i]);
      }
      return ret;
    }
    function hexSlice(buf2, start, end) {
      const len = buf2.length;
      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len) end = len;
      let out = "";
      for (let i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf2[i]];
      }
      return out;
    }
    function utf16leSlice(buf2, start, end) {
      const bytes = buf2.slice(start, end);
      let res = "";
      for (let i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res;
    }
    Buffer3.prototype.slice = function slice2(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0) end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start) end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer3.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length11) {
      if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
      if (offset + ext > length11) throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul3 = 1;
      let i = 0;
      while (++i < byteLength2 && (mul3 *= 256)) {
        val += this[offset + i] * mul3;
      }
      return val;
    };
    Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      let val = this[offset + --byteLength2];
      let mul3 = 1;
      while (byteLength2 > 0 && (mul3 *= 256)) {
        val += this[offset + --byteLength2] * mul3;
      }
      return val;
    };
    Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer3.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first2 = this[offset];
      const last2 = this[offset + 7];
      if (first2 === void 0 || last2 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first2 + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last2 * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer3.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first2 = this[offset];
      const last2 = this[offset + 7];
      if (first2 === void 0 || last2 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first2 * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last2;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });
    Buffer3.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul3 = 1;
      let i = 0;
      while (++i < byteLength2 && (mul3 *= 256)) {
        val += this[offset + i] * mul3;
      }
      mul3 *= 128;
      if (val >= mul3) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let i = byteLength2;
      let mul3 = 1;
      let val = this[offset + --i];
      while (i > 0 && (mul3 *= 256)) {
        val += this[offset + --i] * mul3;
      }
      mul3 *= 128;
      if (val >= mul3) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128)) return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer3.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer3.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer3.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first2 = this[offset];
      const last2 = this[offset + 7];
      if (first2 === void 0 || last2 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last2 << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first2 + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    });
    Buffer3.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first2 = this[offset];
      const last2 = this[offset + 7];
      if (first2 === void 0 || last2 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first2 << 24) + // Overflow
      this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last2);
    });
    Buffer3.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer3.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer3.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer3.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf2, value, offset, ext, max, min) {
      if (!Buffer3.isBuffer(buf2)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf2.length) throw new RangeError("Index out of range");
    }
    Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let mul3 = 1;
      let i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul3 *= 256)) {
        this[offset + i] = value / mul3 & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let i = byteLength2 - 1;
      let mul3 = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul3 *= 256)) {
        this[offset + i] = value / mul3 & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf2, value, offset, min, max) {
      checkIntBI(value, min, max, buf2, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf2[offset++] = lo;
      lo = lo >> 8;
      buf2[offset++] = lo;
      lo = lo >> 8;
      buf2[offset++] = lo;
      lo = lo >> 8;
      buf2[offset++] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf2[offset++] = hi;
      hi = hi >> 8;
      buf2[offset++] = hi;
      hi = hi >> 8;
      buf2[offset++] = hi;
      hi = hi >> 8;
      buf2[offset++] = hi;
      return offset;
    }
    function wrtBigUInt64BE(buf2, value, offset, min, max) {
      checkIntBI(value, min, max, buf2, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf2[offset + 7] = lo;
      lo = lo >> 8;
      buf2[offset + 6] = lo;
      lo = lo >> 8;
      buf2[offset + 5] = lo;
      lo = lo >> 8;
      buf2[offset + 4] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf2[offset + 3] = hi;
      hi = hi >> 8;
      buf2[offset + 2] = hi;
      hi = hi >> 8;
      buf2[offset + 1] = hi;
      hi = hi >> 8;
      buf2[offset] = hi;
      return offset + 8;
    }
    Buffer3.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer3.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer3.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = 0;
      let mul3 = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul3 *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul3 >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = byteLength2 - 1;
      let mul3 = 1;
      let sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul3 *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul3 >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
      if (value < 0) value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0) value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer3.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf2, value, offset, ext, max, min) {
      if (offset + ext > buf2.length) throw new RangeError("Index out of range");
      if (offset < 0) throw new RangeError("Index out of range");
    }
    function writeFloat(buf2, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf2, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf2, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf2, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf2, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf2, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer3.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer3.isBuffer(target)) throw new TypeError("argument should be a Buffer");
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start;
      if (end === start) return 0;
      if (target.length === 0 || this.length === 0) return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
      if (end < 0) throw new RangeError("sourceEnd out of bounds");
      if (end > this.length) end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer3.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code12 = val.charCodeAt(0);
          if (encoding === "utf8" && code12 < 128 || encoding === "latin1") {
            val = code12;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val) val = 0;
      let i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        const bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    var errors = {};
    function E(sym, getMessage, Base) {
      errors[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(name12) {
        if (name12) {
          return `${name12} is outside of buffer bounds`;
        }
        return "Attempt to access memory outside buffer bounds";
      },
      RangeError
    );
    E(
      "ERR_INVALID_ARG_TYPE",
      function(name12, actual) {
        return `The "${name12}" argument must be of type number. Received type ${typeof actual}`;
      },
      TypeError
    );
    E(
      "ERR_OUT_OF_RANGE",
      function(str, range, input) {
        let msg = `The value of "${str}" is out of range.`;
        let received = input;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        }
        msg += ` It must be ${range}. Received ${received}`;
        return msg;
      },
      RangeError
    );
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`;
      }
      return `${val.slice(0, i)}${res}`;
    }
    function checkBounds(buf2, offset, byteLength2) {
      validateNumber(offset, "offset");
      if (buf2[offset] === void 0 || buf2[offset + byteLength2] === void 0) {
        boundsError(offset, buf2.length - (byteLength2 + 1));
      }
    }
    function checkIntBI(value, min, max, buf2, offset, byteLength2) {
      if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
          } else {
            range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
          }
        } else {
          range = `>= ${min}${n} and <= ${max}${n}`;
        }
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf2, offset, byteLength2);
    }
    function validateNumber(value, name12) {
      if (typeof value !== "number") {
        throw new errors.ERR_INVALID_ARG_TYPE(name12, "number", value);
      }
    }
    function boundsError(value, length11, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
      }
      if (length11 < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors.ERR_OUT_OF_RANGE(
        type || "offset",
        `>= ${type ? 1 : 0} and <= ${length11}`,
        value
      );
    }
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2) return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes3(string3, units) {
      units = units || Infinity;
      let codePoint;
      const length11 = string3.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i = 0; i < length11; ++i) {
        codePoint = string3.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            } else if (i + 1 === length11) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0) break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0) break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0) break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0) break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c, hi, lo;
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base649.toByteArray(base64clean(str));
    }
    function blitBuffer(src12, dst, offset, length11) {
      let i;
      for (i = 0; i < length11; ++i) {
        if (i + offset >= dst.length || i >= src12.length) break;
        dst[i + offset] = src12[i];
      }
      return i;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = (function() {
      const alphabet7 = "0123456789abcdef";
      const table2 = new Array(256);
      for (let i = 0; i < 16; ++i) {
        const i16 = i * 16;
        for (let j = 0; j < 16; ++j) {
          table2[i16 + j] = alphabet7[i] + alphabet7[j];
        }
      }
      return table2;
    })();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
  }
});

// src/core/wallet.ts
var bip39 = __toESM(require_src());

// node_modules/@noble/hashes/esm/crypto.js
var crypto2 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;

// node_modules/@noble/hashes/esm/utils.js
function isBytes(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function anumber(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error("positive integer expected, got " + n);
}
function abytes(b, ...lengths) {
  if (!isBytes(b))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
}
function ahash(h) {
  if (typeof h !== "function" || typeof h.create !== "function")
    throw new Error("Hash should be wrapped by utils.createHasher");
  anumber(h.outputLen);
  anumber(h.blockLen);
}
function aexists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput(out, instance) {
  abytes(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error("digestInto() expects output buffer of length at least " + min);
  }
}
function u32(arr) {
  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
}
function clean(...arrays) {
  for (let i = 0; i < arrays.length; i++) {
    arrays[i].fill(0);
  }
}
function createView(arr) {
  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
function rotr(word, shift) {
  return word << 32 - shift | word >>> shift;
}
function rotl(word, shift) {
  return word << shift | word >>> 32 - shift >>> 0;
}
var isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
function byteSwap(word) {
  return word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
}
function byteSwap32(arr) {
  for (let i = 0; i < arr.length; i++) {
    arr[i] = byteSwap(arr[i]);
  }
  return arr;
}
var swap32IfBE = isLE ? (u) => u : byteSwap32;
var hasHexBuiltin = /* @__PURE__ */ (() => (
  // @ts-ignore
  typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
))();
var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
function bytesToHex(bytes) {
  abytes(bytes);
  if (hasHexBuiltin)
    return bytes.toHex();
  let hex = "";
  for (let i = 0; i < bytes.length; i++) {
    hex += hexes[bytes[i]];
  }
  return hex;
}
var asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function asciiToBase16(ch) {
  if (ch >= asciis._0 && ch <= asciis._9)
    return ch - asciis._0;
  if (ch >= asciis.A && ch <= asciis.F)
    return ch - (asciis.A - 10);
  if (ch >= asciis.a && ch <= asciis.f)
    return ch - (asciis.a - 10);
  return;
}
function hexToBytes(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  if (hasHexBuiltin)
    return Uint8Array.fromHex(hex);
  const hl = hex.length;
  const al = hl / 2;
  if (hl % 2)
    throw new Error("hex string expected, got unpadded hex of length " + hl);
  const array = new Uint8Array(al);
  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
    const n1 = asciiToBase16(hex.charCodeAt(hi));
    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
    if (n1 === void 0 || n2 === void 0) {
      const char = hex[hi] + hex[hi + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
    }
    array[ai] = n1 * 16 + n2;
  }
  return array;
}
var nextTick = async () => {
};
async function asyncLoop(iters, tick, cb) {
  let ts = Date.now();
  for (let i = 0; i < iters; i++) {
    cb(i);
    const diff = Date.now() - ts;
    if (diff >= 0 && diff < tick)
      continue;
    await nextTick();
    ts += diff;
  }
}
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  abytes(data);
  return data;
}
function kdfInputToBytes(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  abytes(data);
  return data;
}
function concatBytes(...arrays) {
  let sum = 0;
  for (let i = 0; i < arrays.length; i++) {
    const a = arrays[i];
    abytes(a);
    sum += a.length;
  }
  const res = new Uint8Array(sum);
  for (let i = 0, pad = 0; i < arrays.length; i++) {
    const a = arrays[i];
    res.set(a, pad);
    pad += a.length;
  }
  return res;
}
function checkOpts(defaults, opts) {
  if (opts !== void 0 && {}.toString.call(opts) !== "[object Object]")
    throw new Error("options should be object or undefined");
  const merged = Object.assign(defaults, opts);
  return merged;
}
var Hash = class {
};
function createHasher(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function randomBytes(bytesLength = 32) {
  if (crypto2 && typeof crypto2.getRandomValues === "function") {
    return crypto2.getRandomValues(new Uint8Array(bytesLength));
  }
  if (crypto2 && typeof crypto2.randomBytes === "function") {
    return Uint8Array.from(crypto2.randomBytes(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}

// node_modules/@noble/hashes/esm/hmac.js
var HMAC = class extends Hash {
  constructor(hash, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    ahash(hash);
    const key = toBytes(_key);
    this.iHash = hash.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad = new Uint8Array(blockLen);
    pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
    for (let i = 0; i < pad.length; i++)
      pad[i] ^= 54;
    this.iHash.update(pad);
    this.oHash = hash.create();
    for (let i = 0; i < pad.length; i++)
      pad[i] ^= 54 ^ 92;
    this.oHash.update(pad);
    clean(pad);
  }
  update(buf2) {
    aexists(this);
    this.iHash.update(buf2);
    return this;
  }
  digestInto(out) {
    aexists(this);
    abytes(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  clone() {
    return this._cloneInto();
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
var hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();
hmac.create = (hash, key) => new HMAC(hash, key);

// node_modules/@noble/hashes/esm/pbkdf2.js
function pbkdf2Init(hash, _password, _salt, _opts) {
  ahash(hash);
  const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);
  const { c, dkLen, asyncTick } = opts;
  anumber(c);
  anumber(dkLen);
  anumber(asyncTick);
  if (c < 1)
    throw new Error("iterations (c) should be >= 1");
  const password = kdfInputToBytes(_password);
  const salt = kdfInputToBytes(_salt);
  const DK = new Uint8Array(dkLen);
  const PRF = hmac.create(hash, password);
  const PRFSalt = PRF._cloneInto().update(salt);
  return { c, dkLen, asyncTick, DK, PRF, PRFSalt };
}
function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
  PRF.destroy();
  PRFSalt.destroy();
  if (prfW)
    prfW.destroy();
  clean(u);
  return DK;
}
function pbkdf2(hash, password, salt, opts) {
  const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);
  let prfW;
  const arr = new Uint8Array(4);
  const view = createView(arr);
  const u = new Uint8Array(PRF.outputLen);
  for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
    const Ti = DK.subarray(pos, pos + PRF.outputLen);
    view.setInt32(0, ti, false);
    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
    Ti.set(u.subarray(0, Ti.length));
    for (let ui = 1; ui < c; ui++) {
      PRF._cloneInto(prfW).update(u).digestInto(u);
      for (let i = 0; i < Ti.length; i++)
        Ti[i] ^= u[i];
    }
  }
  return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
}
async function pbkdf2Async(hash, password, salt, opts) {
  const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);
  let prfW;
  const arr = new Uint8Array(4);
  const view = createView(arr);
  const u = new Uint8Array(PRF.outputLen);
  for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
    const Ti = DK.subarray(pos, pos + PRF.outputLen);
    view.setInt32(0, ti, false);
    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
    Ti.set(u.subarray(0, Ti.length));
    await asyncLoop(c - 1, asyncTick, () => {
      PRF._cloneInto(prfW).update(u).digestInto(u);
      for (let i = 0; i < Ti.length; i++)
        Ti[i] ^= u[i];
    });
  }
  return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
}

// node_modules/@noble/hashes/esm/_md.js
function setBigUint64(view, byteOffset, value, isLE3) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE3);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n2 & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE3 ? 4 : 0;
  const l = isLE3 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE3);
  view.setUint32(byteOffset + l, wl, isLE3);
}
function Chi(a, b, c) {
  return a & b ^ ~a & c;
}
function Maj(a, b, c) {
  return a & b ^ a & c ^ b & c;
}
var HashMD = class extends Hash {
  constructor(blockLen, outputLen, padOffset, isLE3) {
    super();
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE3;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data) {
    aexists(this);
    data = toBytes(data);
    abytes(data);
    const { view, buffer: buffer2, blockLen } = this;
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView2 = createView(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView2, pos);
        continue;
      }
      buffer2.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    aexists(this);
    aoutput(out, this);
    this.finished = true;
    const { buffer: buffer2, view, blockLen, isLE: isLE3 } = this;
    let { pos } = this;
    buffer2[pos++] = 128;
    clean(this.buffer.subarray(pos));
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i = pos; i < blockLen; i++)
      buffer2[i] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE3);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i = 0; i < outLen; i++)
      oview.setUint32(4 * i, state[i], isLE3);
  }
  digest() {
    const { buffer: buffer2, outputLen } = this;
    this.digestInto(buffer2);
    const res = buffer2.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer: buffer2, length: length11, finished, destroyed, pos } = this;
    to.destroyed = destroyed;
    to.finished = finished;
    to.length = length11;
    to.pos = pos;
    if (length11 % blockLen)
      to.buffer.set(buffer2);
    return to;
  }
  clone() {
    return this._cloneInto();
  }
};
var SHA256_IV = /* @__PURE__ */ Uint32Array.from([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA512_IV = /* @__PURE__ */ Uint32Array.from([
  1779033703,
  4089235720,
  3144134277,
  2227873595,
  1013904242,
  4271175723,
  2773480762,
  1595750129,
  1359893119,
  2917565137,
  2600822924,
  725511199,
  528734635,
  4215389547,
  1541459225,
  327033209
]);

// node_modules/@noble/hashes/esm/_u64.js
var U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
var _32n = /* @__PURE__ */ BigInt(32);
function fromBig(n, le = false) {
  if (le)
    return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
  return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
function split(lst, le = false) {
  const len = lst.length;
  let Ah = new Uint32Array(len);
  let Al = new Uint32Array(len);
  for (let i = 0; i < len; i++) {
    const { h, l } = fromBig(lst[i], le);
    [Ah[i], Al[i]] = [h, l];
  }
  return [Ah, Al];
}
var shrSH = (h, _l, s) => h >>> s;
var shrSL = (h, l, s) => h << 32 - s | l >>> s;
var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
function add(Ah, Al, Bh, Bl2) {
  const l = (Al >>> 0) + (Bl2 >>> 0);
  return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
}
var add3L = (Al, Bl2, Cl) => (Al >>> 0) + (Bl2 >>> 0) + (Cl >>> 0);
var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
var add4L = (Al, Bl2, Cl, Dl) => (Al >>> 0) + (Bl2 >>> 0) + (Cl >>> 0) + (Dl >>> 0);
var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
var add5L = (Al, Bl2, Cl, Dl, El) => (Al >>> 0) + (Bl2 >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;

// node_modules/@noble/hashes/esm/sha2.js
var SHA256_K = /* @__PURE__ */ Uint32Array.from([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var SHA256_W = /* @__PURE__ */ new Uint32Array(64);
var SHA256 = class extends HashMD {
  constructor(outputLen = 32) {
    super(64, outputLen, 8, false);
    this.A = SHA256_IV[0] | 0;
    this.B = SHA256_IV[1] | 0;
    this.C = SHA256_IV[2] | 0;
    this.D = SHA256_IV[3] | 0;
    this.E = SHA256_IV[4] | 0;
    this.F = SHA256_IV[5] | 0;
    this.G = SHA256_IV[6] | 0;
    this.H = SHA256_IV[7] | 0;
  }
  get() {
    const { A, B, C, D, E, F, G, H } = this;
    return [A, B, C, D, E, F, G, H];
  }
  // prettier-ignore
  set(A, B, C, D, E, F, G, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      SHA256_W[i] = view.getUint32(offset, false);
    for (let i = 16; i < 64; i++) {
      const W15 = SHA256_W[i - 15];
      const W2 = SHA256_W[i - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
      SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
    }
    let { A, B, C, D, E, F, G, H } = this;
    for (let i = 0; i < 64; i++) {
      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
      const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
      const T2 = sigma0 + Maj(A, B, C) | 0;
      H = G;
      G = F;
      F = E;
      E = D + T1 | 0;
      D = C;
      C = B;
      B = A;
      A = T1 + T2 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F = F + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F, G, H);
  }
  roundClean() {
    clean(SHA256_W);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    clean(this.buffer);
  }
};
var K512 = /* @__PURE__ */ (() => split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n) => BigInt(n))))();
var SHA512_Kh = /* @__PURE__ */ (() => K512[0])();
var SHA512_Kl = /* @__PURE__ */ (() => K512[1])();
var SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
var SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
var SHA512 = class extends HashMD {
  constructor(outputLen = 64) {
    super(128, outputLen, 16, false);
    this.Ah = SHA512_IV[0] | 0;
    this.Al = SHA512_IV[1] | 0;
    this.Bh = SHA512_IV[2] | 0;
    this.Bl = SHA512_IV[3] | 0;
    this.Ch = SHA512_IV[4] | 0;
    this.Cl = SHA512_IV[5] | 0;
    this.Dh = SHA512_IV[6] | 0;
    this.Dl = SHA512_IV[7] | 0;
    this.Eh = SHA512_IV[8] | 0;
    this.El = SHA512_IV[9] | 0;
    this.Fh = SHA512_IV[10] | 0;
    this.Fl = SHA512_IV[11] | 0;
    this.Gh = SHA512_IV[12] | 0;
    this.Gl = SHA512_IV[13] | 0;
    this.Hh = SHA512_IV[14] | 0;
    this.Hl = SHA512_IV[15] | 0;
  }
  // prettier-ignore
  get() {
    const { Ah, Al, Bh, Bl: Bl2, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    return [Ah, Al, Bh, Bl2, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
  }
  // prettier-ignore
  set(Ah, Al, Bh, Bl2, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
    this.Ah = Ah | 0;
    this.Al = Al | 0;
    this.Bh = Bh | 0;
    this.Bl = Bl2 | 0;
    this.Ch = Ch | 0;
    this.Cl = Cl | 0;
    this.Dh = Dh | 0;
    this.Dl = Dl | 0;
    this.Eh = Eh | 0;
    this.El = El | 0;
    this.Fh = Fh | 0;
    this.Fl = Fl | 0;
    this.Gh = Gh | 0;
    this.Gl = Gl | 0;
    this.Hh = Hh | 0;
    this.Hl = Hl | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4) {
      SHA512_W_H[i] = view.getUint32(offset);
      SHA512_W_L[i] = view.getUint32(offset += 4);
    }
    for (let i = 16; i < 80; i++) {
      const W15h = SHA512_W_H[i - 15] | 0;
      const W15l = SHA512_W_L[i - 15] | 0;
      const s0h = rotrSH(W15h, W15l, 1) ^ rotrSH(W15h, W15l, 8) ^ shrSH(W15h, W15l, 7);
      const s0l = rotrSL(W15h, W15l, 1) ^ rotrSL(W15h, W15l, 8) ^ shrSL(W15h, W15l, 7);
      const W2h = SHA512_W_H[i - 2] | 0;
      const W2l = SHA512_W_L[i - 2] | 0;
      const s1h = rotrSH(W2h, W2l, 19) ^ rotrBH(W2h, W2l, 61) ^ shrSH(W2h, W2l, 6);
      const s1l = rotrSL(W2h, W2l, 19) ^ rotrBL(W2h, W2l, 61) ^ shrSL(W2h, W2l, 6);
      const SUMl = add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
      const SUMh = add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
      SHA512_W_H[i] = SUMh | 0;
      SHA512_W_L[i] = SUMl | 0;
    }
    let { Ah, Al, Bh, Bl: Bl2, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    for (let i = 0; i < 80; i++) {
      const sigma1h = rotrSH(Eh, El, 14) ^ rotrSH(Eh, El, 18) ^ rotrBH(Eh, El, 41);
      const sigma1l = rotrSL(Eh, El, 14) ^ rotrSL(Eh, El, 18) ^ rotrBL(Eh, El, 41);
      const CHIh = Eh & Fh ^ ~Eh & Gh;
      const CHIl = El & Fl ^ ~El & Gl;
      const T1ll = add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
      const T1h = add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
      const T1l = T1ll | 0;
      const sigma0h = rotrSH(Ah, Al, 28) ^ rotrBH(Ah, Al, 34) ^ rotrBH(Ah, Al, 39);
      const sigma0l = rotrSL(Ah, Al, 28) ^ rotrBL(Ah, Al, 34) ^ rotrBL(Ah, Al, 39);
      const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
      const MAJl = Al & Bl2 ^ Al & Cl ^ Bl2 & Cl;
      Hh = Gh | 0;
      Hl = Gl | 0;
      Gh = Fh | 0;
      Gl = Fl | 0;
      Fh = Eh | 0;
      Fl = El | 0;
      ({ h: Eh, l: El } = add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
      Dh = Ch | 0;
      Dl = Cl | 0;
      Ch = Bh | 0;
      Cl = Bl2 | 0;
      Bh = Ah | 0;
      Bl2 = Al | 0;
      const All = add3L(T1l, sigma0l, MAJl);
      Ah = add3H(All, T1h, sigma0h, MAJh);
      Al = All | 0;
    }
    ({ h: Ah, l: Al } = add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
    ({ h: Bh, l: Bl2 } = add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl2 | 0));
    ({ h: Ch, l: Cl } = add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
    ({ h: Dh, l: Dl } = add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
    ({ h: Eh, l: El } = add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
    ({ h: Fh, l: Fl } = add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
    ({ h: Gh, l: Gl } = add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
    ({ h: Hh, l: Hl } = add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
    this.set(Ah, Al, Bh, Bl2, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
  }
  roundClean() {
    clean(SHA512_W_H, SHA512_W_L);
  }
  destroy() {
    clean(this.buffer);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var sha256 = /* @__PURE__ */ createHasher(() => new SHA256());
var sha512 = /* @__PURE__ */ createHasher(() => new SHA512());

// node_modules/@scure/base/lib/esm/index.js
function isBytes2(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function isArrayOf(isString, arr) {
  if (!Array.isArray(arr))
    return false;
  if (arr.length === 0)
    return true;
  if (isString) {
    return arr.every((item) => typeof item === "string");
  } else {
    return arr.every((item) => Number.isSafeInteger(item));
  }
}
function afn(input) {
  if (typeof input !== "function")
    throw new Error("function expected");
  return true;
}
function astr(label, input) {
  if (typeof input !== "string")
    throw new Error(`${label}: string expected`);
  return true;
}
function anumber2(n) {
  if (!Number.isSafeInteger(n))
    throw new Error(`invalid integer: ${n}`);
}
function aArr(input) {
  if (!Array.isArray(input))
    throw new Error("array expected");
}
function astrArr(label, input) {
  if (!isArrayOf(true, input))
    throw new Error(`${label}: array of strings expected`);
}
function anumArr(label, input) {
  if (!isArrayOf(false, input))
    throw new Error(`${label}: array of numbers expected`);
}
// @__NO_SIDE_EFFECTS__
function chain(...args) {
  const id = (a) => a;
  const wrap = (a, b) => (c) => a(b(c));
  const encode42 = args.map((x) => x.encode).reduceRight(wrap, id);
  const decode58 = args.map((x) => x.decode).reduce(wrap, id);
  return { encode: encode42, decode: decode58 };
}
// @__NO_SIDE_EFFECTS__
function alphabet(letters) {
  const lettersA = typeof letters === "string" ? letters.split("") : letters;
  const len = lettersA.length;
  astrArr("alphabet", lettersA);
  const indexes = new Map(lettersA.map((l, i) => [l, i]));
  return {
    encode: (digits) => {
      aArr(digits);
      return digits.map((i) => {
        if (!Number.isSafeInteger(i) || i < 0 || i >= len)
          throw new Error(`alphabet.encode: digit index outside alphabet "${i}". Allowed: ${letters}`);
        return lettersA[i];
      });
    },
    decode: (input) => {
      aArr(input);
      return input.map((letter) => {
        astr("alphabet.decode", letter);
        const i = indexes.get(letter);
        if (i === void 0)
          throw new Error(`Unknown letter: "${letter}". Allowed: ${letters}`);
        return i;
      });
    }
  };
}
// @__NO_SIDE_EFFECTS__
function join(separator = "") {
  astr("join", separator);
  return {
    encode: (from17) => {
      astrArr("join.decode", from17);
      return from17.join(separator);
    },
    decode: (to) => {
      astr("join.decode", to);
      return to.split(separator);
    }
  };
}
function convertRadix(data, from17, to) {
  if (from17 < 2)
    throw new Error(`convertRadix: invalid from=${from17}, base cannot be less than 2`);
  if (to < 2)
    throw new Error(`convertRadix: invalid to=${to}, base cannot be less than 2`);
  aArr(data);
  if (!data.length)
    return [];
  let pos = 0;
  const res = [];
  const digits = Array.from(data, (d) => {
    anumber2(d);
    if (d < 0 || d >= from17)
      throw new Error(`invalid integer: ${d}`);
    return d;
  });
  const dlen = digits.length;
  while (true) {
    let carry = 0;
    let done = true;
    for (let i = pos; i < dlen; i++) {
      const digit = digits[i];
      const fromCarry = from17 * carry;
      const digitBase = fromCarry + digit;
      if (!Number.isSafeInteger(digitBase) || fromCarry / from17 !== carry || digitBase - digit !== fromCarry) {
        throw new Error("convertRadix: carry overflow");
      }
      const div = digitBase / to;
      carry = digitBase % to;
      const rounded = Math.floor(div);
      digits[i] = rounded;
      if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)
        throw new Error("convertRadix: carry overflow");
      if (!done)
        continue;
      else if (!rounded)
        pos = i;
      else
        done = false;
    }
    res.push(carry);
    if (done)
      break;
  }
  for (let i = 0; i < data.length - 1 && data[i] === 0; i++)
    res.push(0);
  return res.reverse();
}
// @__NO_SIDE_EFFECTS__
function radix(num) {
  anumber2(num);
  const _256 = 2 ** 8;
  return {
    encode: (bytes) => {
      if (!isBytes2(bytes))
        throw new Error("radix.encode input should be Uint8Array");
      return convertRadix(Array.from(bytes), _256, num);
    },
    decode: (digits) => {
      anumArr("radix.decode", digits);
      return Uint8Array.from(convertRadix(digits, num, _256));
    }
  };
}
function checksum(len, fn) {
  anumber2(len);
  afn(fn);
  return {
    encode(data) {
      if (!isBytes2(data))
        throw new Error("checksum.encode: input should be Uint8Array");
      const sum = fn(data).slice(0, len);
      const res = new Uint8Array(data.length + len);
      res.set(data);
      res.set(sum, data.length);
      return res;
    },
    decode(data) {
      if (!isBytes2(data))
        throw new Error("checksum.decode: input should be Uint8Array");
      const payload = data.slice(0, -len);
      const oldChecksum = data.slice(-len);
      const newChecksum = fn(payload).slice(0, len);
      for (let i = 0; i < len; i++)
        if (newChecksum[i] !== oldChecksum[i])
          throw new Error("Invalid checksum");
      return payload;
    }
  };
}
var genBase58 = /* @__NO_SIDE_EFFECTS__ */ (abc) => /* @__PURE__ */ chain(/* @__PURE__ */ radix(58), /* @__PURE__ */ alphabet(abc), /* @__PURE__ */ join(""));
var base58 = /* @__PURE__ */ genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
var createBase58check = (sha2568) => /* @__PURE__ */ chain(checksum(4, (data) => sha2568(sha2568(data))), base58);
var base58check = createBase58check;

// node_modules/@noble/curves/esm/abstract/utils.js
var _0n = /* @__PURE__ */ BigInt(0);
var _1n = /* @__PURE__ */ BigInt(1);
function isBytes3(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function abytes2(item) {
  if (!isBytes3(item))
    throw new Error("Uint8Array expected");
}
function abool(title, value) {
  if (typeof value !== "boolean")
    throw new Error(title + " boolean expected, got " + value);
}
function numberToHexUnpadded(num) {
  const hex = num.toString(16);
  return hex.length & 1 ? "0" + hex : hex;
}
function hexToNumber(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  return hex === "" ? _0n : BigInt("0x" + hex);
}
var hasHexBuiltin2 = (
  // @ts-ignore
  typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
);
var hexes2 = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
function bytesToHex2(bytes) {
  abytes2(bytes);
  if (hasHexBuiltin2)
    return bytes.toHex();
  let hex = "";
  for (let i = 0; i < bytes.length; i++) {
    hex += hexes2[bytes[i]];
  }
  return hex;
}
var asciis2 = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function asciiToBase162(ch) {
  if (ch >= asciis2._0 && ch <= asciis2._9)
    return ch - asciis2._0;
  if (ch >= asciis2.A && ch <= asciis2.F)
    return ch - (asciis2.A - 10);
  if (ch >= asciis2.a && ch <= asciis2.f)
    return ch - (asciis2.a - 10);
  return;
}
function hexToBytes2(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  if (hasHexBuiltin2)
    return Uint8Array.fromHex(hex);
  const hl = hex.length;
  const al = hl / 2;
  if (hl % 2)
    throw new Error("hex string expected, got unpadded hex of length " + hl);
  const array = new Uint8Array(al);
  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
    const n1 = asciiToBase162(hex.charCodeAt(hi));
    const n2 = asciiToBase162(hex.charCodeAt(hi + 1));
    if (n1 === void 0 || n2 === void 0) {
      const char = hex[hi] + hex[hi + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
    }
    array[ai] = n1 * 16 + n2;
  }
  return array;
}
function bytesToNumberBE(bytes) {
  return hexToNumber(bytesToHex2(bytes));
}
function bytesToNumberLE(bytes) {
  abytes2(bytes);
  return hexToNumber(bytesToHex2(Uint8Array.from(bytes).reverse()));
}
function numberToBytesBE(n, len) {
  return hexToBytes2(n.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE(n, len) {
  return numberToBytesBE(n, len).reverse();
}
function ensureBytes(title, hex, expectedLength) {
  let res;
  if (typeof hex === "string") {
    try {
      res = hexToBytes2(hex);
    } catch (e) {
      throw new Error(title + " must be hex string or Uint8Array, cause: " + e);
    }
  } else if (isBytes3(hex)) {
    res = Uint8Array.from(hex);
  } else {
    throw new Error(title + " must be hex string or Uint8Array");
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(title + " of length " + expectedLength + " expected, got " + len);
  return res;
}
function concatBytes2(...arrays) {
  let sum = 0;
  for (let i = 0; i < arrays.length; i++) {
    const a = arrays[i];
    abytes2(a);
    sum += a.length;
  }
  const res = new Uint8Array(sum);
  for (let i = 0, pad = 0; i < arrays.length; i++) {
    const a = arrays[i];
    res.set(a, pad);
    pad += a.length;
  }
  return res;
}
var isPosBig = (n) => typeof n === "bigint" && _0n <= n;
function inRange(n, min, max) {
  return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;
}
function aInRange(title, n, min, max) {
  if (!inRange(n, min, max))
    throw new Error("expected valid " + title + ": " + min + " <= n < " + max + ", got " + n);
}
function bitLen(n) {
  let len;
  for (len = 0; n > _0n; n >>= _1n, len += 1)
    ;
  return len;
}
var bitMask = (n) => (_1n << BigInt(n)) - _1n;
var u8n = (len) => new Uint8Array(len);
var u8fr = (arr) => Uint8Array.from(arr);
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  let v = u8n(hashLen);
  let k = u8n(hashLen);
  let i = 0;
  const reset = () => {
    v.fill(1);
    k.fill(0);
    i = 0;
  };
  const h = (...b) => hmacFn(k, v, ...b);
  const reseed = (seed = u8n(0)) => {
    k = h(u8fr([0]), seed);
    v = h();
    if (seed.length === 0)
      return;
    k = h(u8fr([1]), seed);
    v = h();
  };
  const gen2 = () => {
    if (i++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v = h();
      const sl = v.slice();
      out.push(sl);
      len += v.length;
    }
    return concatBytes2(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed(seed);
    let res = void 0;
    while (!(res = pred(gen2())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
var validatorFns = {
  bigint: (val) => typeof val === "bigint",
  function: (val) => typeof val === "function",
  boolean: (val) => typeof val === "boolean",
  string: (val) => typeof val === "string",
  stringOrUint8Array: (val) => typeof val === "string" || isBytes3(val),
  isSafeInteger: (val) => Number.isSafeInteger(val),
  array: (val) => Array.isArray(val),
  field: (val, object) => object.Fp.isValid(val),
  hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
};
function validateObject(object, validators, optValidators = {}) {
  const checkField = (fieldName, type, isOptional) => {
    const checkVal = validatorFns[type];
    if (typeof checkVal !== "function")
      throw new Error("invalid validator function");
    const val = object[fieldName];
    if (isOptional && val === void 0)
      return;
    if (!checkVal(val, object)) {
      throw new Error("param " + String(fieldName) + " is invalid. Expected " + type + ", got " + val);
    }
  };
  for (const [fieldName, type] of Object.entries(validators))
    checkField(fieldName, type, false);
  for (const [fieldName, type] of Object.entries(optValidators))
    checkField(fieldName, type, true);
  return object;
}
function memoized(fn) {
  const map2 = /* @__PURE__ */ new WeakMap();
  return (arg, ...args) => {
    const val = map2.get(arg);
    if (val !== void 0)
      return val;
    const computed = fn(arg, ...args);
    map2.set(arg, computed);
    return computed;
  };
}

// node_modules/@noble/curves/esm/abstract/modular.js
var _0n2 = BigInt(0);
var _1n2 = BigInt(1);
var _2n = /* @__PURE__ */ BigInt(2);
var _3n = /* @__PURE__ */ BigInt(3);
var _4n = /* @__PURE__ */ BigInt(4);
var _5n = /* @__PURE__ */ BigInt(5);
var _8n = /* @__PURE__ */ BigInt(8);
var _9n = /* @__PURE__ */ BigInt(9);
var _16n = /* @__PURE__ */ BigInt(16);
function mod2(a, b) {
  const result = a % b;
  return result >= _0n2 ? result : b + result;
}
function pow2(x, power, modulo) {
  let res = x;
  while (power-- > _0n2) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert(number, modulo) {
  if (number === _0n2)
    throw new Error("invert: expected non-zero number");
  if (modulo <= _0n2)
    throw new Error("invert: expected positive modulus, got " + modulo);
  let a = mod2(number, modulo);
  let b = modulo;
  let x = _0n2, y = _1n2, u = _1n2, v = _0n2;
  while (a !== _0n2) {
    const q = b / a;
    const r = b % a;
    const m = x - u * q;
    const n = y - v * q;
    b = a, a = r, x = u, y = v, u = m, v = n;
  }
  const gcd = b;
  if (gcd !== _1n2)
    throw new Error("invert: does not exist");
  return mod2(x, modulo);
}
function tonelliShanks(P) {
  let Q = P - _1n2;
  let S = 0;
  while (Q % _2n === _0n2) {
    Q /= _2n;
    S++;
  }
  let Z = _2n;
  const _Fp = Field(P);
  while (Z < P && FpIsSquare(_Fp, Z)) {
    if (Z++ > 1e3)
      throw new Error("Cannot find square root: probably non-prime P");
  }
  if (S === 1) {
    const p1div4 = (P + _1n2) / _4n;
    return function tonelliFast(Fp, n) {
      const root = Fp.pow(n, p1div4);
      if (!Fp.eql(Fp.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  const Q1div2 = (Q + _1n2) / _2n;
  return function tonelliSlow(Fp, n) {
    if (!FpIsSquare(Fp, n))
      throw new Error("Cannot find square root");
    let r = S;
    let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q);
    let x = Fp.pow(n, Q1div2);
    let b = Fp.pow(n, Q);
    while (!Fp.eql(b, Fp.ONE)) {
      if (Fp.eql(b, Fp.ZERO))
        return Fp.ZERO;
      let m = 1;
      for (let t2 = Fp.sqr(b); m < r; m++) {
        if (Fp.eql(t2, Fp.ONE))
          break;
        t2 = Fp.sqr(t2);
      }
      const ge = Fp.pow(g, _1n2 << BigInt(r - m - 1));
      g = Fp.sqr(ge);
      x = Fp.mul(x, ge);
      b = Fp.mul(b, g);
      r = m;
    }
    return x;
  };
}
function FpSqrt(P) {
  if (P % _4n === _3n) {
    return function sqrt3mod4(Fp, n) {
      const p1div4 = (P + _1n2) / _4n;
      const root = Fp.pow(n, p1div4);
      if (!Fp.eql(Fp.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P % _8n === _5n) {
    return function sqrt5mod8(Fp, n) {
      const n2 = Fp.mul(n, _2n);
      const c1 = (P - _5n) / _8n;
      const v = Fp.pow(n2, c1);
      const nv = Fp.mul(n, v);
      const i = Fp.mul(Fp.mul(nv, _2n), v);
      const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
      if (!Fp.eql(Fp.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P % _16n === _9n) {
  }
  return tonelliShanks(P);
}
var FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  };
  const opts = FIELD_FIELDS.reduce((map2, val) => {
    map2[val] = "function";
    return map2;
  }, initial);
  return validateObject(field, opts);
}
function FpPow(Fp, num, power) {
  if (power < _0n2)
    throw new Error("invalid exponent, negatives unsupported");
  if (power === _0n2)
    return Fp.ONE;
  if (power === _1n2)
    return num;
  let p = Fp.ONE;
  let d = num;
  while (power > _0n2) {
    if (power & _1n2)
      p = Fp.mul(p, d);
    d = Fp.sqr(d);
    power >>= _1n2;
  }
  return p;
}
function FpInvertBatch(Fp, nums, passZero = false) {
  const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : void 0);
  const multipliedAcc = nums.reduce((acc, num, i) => {
    if (Fp.is0(num))
      return acc;
    inverted[i] = acc;
    return Fp.mul(acc, num);
  }, Fp.ONE);
  const invertedAcc = Fp.inv(multipliedAcc);
  nums.reduceRight((acc, num, i) => {
    if (Fp.is0(num))
      return acc;
    inverted[i] = Fp.mul(acc, inverted[i]);
    return Fp.mul(acc, num);
  }, invertedAcc);
  return inverted;
}
function FpLegendre(Fp, n) {
  const legc = (Fp.ORDER - _1n2) / _2n;
  const powered = Fp.pow(n, legc);
  const yes = Fp.eql(powered, Fp.ONE);
  const zero = Fp.eql(powered, Fp.ZERO);
  const no = Fp.eql(powered, Fp.neg(Fp.ONE));
  if (!yes && !zero && !no)
    throw new Error("Cannot find square root: probably non-prime P");
  return yes ? 1 : zero ? 0 : -1;
}
function FpIsSquare(Fp, n) {
  const l = FpLegendre(Fp, n);
  return l === 0 || l === 1;
}
function nLength(n, nBitLength) {
  if (nBitLength !== void 0)
    anumber(nBitLength);
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field(ORDER, bitLen2, isLE3 = false, redef = {}) {
  if (ORDER <= _0n2)
    throw new Error("invalid field: expected ORDER > 0, got " + ORDER);
  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen2);
  if (BYTES > 2048)
    throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let sqrtP;
  const f = Object.freeze({
    ORDER,
    isLE: isLE3,
    BITS,
    BYTES,
    MASK: bitMask(BITS),
    ZERO: _0n2,
    ONE: _1n2,
    create: (num) => mod2(num, ORDER),
    isValid: (num) => {
      if (typeof num !== "bigint")
        throw new Error("invalid field element: expected bigint, got " + typeof num);
      return _0n2 <= num && num < ORDER;
    },
    is0: (num) => num === _0n2,
    isOdd: (num) => (num & _1n2) === _1n2,
    neg: (num) => mod2(-num, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num) => mod2(num * num, ORDER),
    add: (lhs, rhs) => mod2(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod2(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod2(lhs * rhs, ORDER),
    pow: (num, power) => FpPow(f, num, power),
    div: (lhs, rhs) => mod2(lhs * invert(rhs, ORDER), ORDER),
    // Same as above, but doesn't normalize
    sqrN: (num) => num * num,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num) => invert(num, ORDER),
    sqrt: redef.sqrt || ((n) => {
      if (!sqrtP)
        sqrtP = FpSqrt(ORDER);
      return sqrtP(f, n);
    }),
    toBytes: (num) => isLE3 ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
    fromBytes: (bytes) => {
      if (bytes.length !== BYTES)
        throw new Error("Field.fromBytes: expected " + BYTES + " bytes, got " + bytes.length);
      return isLE3 ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);
    },
    // TODO: we don't need it here, move out to separate fn
    invertBatch: (lst) => FpInvertBatch(f, lst),
    // We can't move this out because Fp6, Fp12 implement it
    // and it's unclear what to return in there.
    cmov: (a, b, c) => c ? b : a
  });
  return Object.freeze(f);
}
function getFieldBytesLength(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength(fieldOrder) {
  const length11 = getFieldBytesLength(fieldOrder);
  return length11 + Math.ceil(length11 / 2);
}
function mapHashToField(key, fieldOrder, isLE3 = false) {
  const len = key.length;
  const fieldLen = getFieldBytesLength(fieldOrder);
  const minLen = getMinHashLength(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error("expected " + minLen + "-1024 bytes of input, got " + len);
  const num = isLE3 ? bytesToNumberLE(key) : bytesToNumberBE(key);
  const reduced = mod2(num, fieldOrder - _1n2) + _1n2;
  return isLE3 ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
}

// node_modules/@noble/curves/esm/abstract/curve.js
var _0n3 = BigInt(0);
var _1n3 = BigInt(1);
function constTimeNegate(condition, item) {
  const neg = item.negate();
  return condition ? neg : item;
}
function validateW(W, bits) {
  if (!Number.isSafeInteger(W) || W <= 0 || W > bits)
    throw new Error("invalid window size, expected [1.." + bits + "], got W=" + W);
}
function calcWOpts(W, scalarBits) {
  validateW(W, scalarBits);
  const windows = Math.ceil(scalarBits / W) + 1;
  const windowSize = 2 ** (W - 1);
  const maxNumber = 2 ** W;
  const mask = bitMask(W);
  const shiftBy = BigInt(W);
  return { windows, windowSize, mask, maxNumber, shiftBy };
}
function calcOffsets(n, window2, wOpts) {
  const { windowSize, mask, maxNumber, shiftBy } = wOpts;
  let wbits = Number(n & mask);
  let nextN = n >> shiftBy;
  if (wbits > windowSize) {
    wbits -= maxNumber;
    nextN += _1n3;
  }
  const offsetStart = window2 * windowSize;
  const offset = offsetStart + Math.abs(wbits) - 1;
  const isZero = wbits === 0;
  const isNeg = wbits < 0;
  const isNegF = window2 % 2 !== 0;
  const offsetF = offsetStart;
  return { nextN, offset, isZero, isNeg, isNegF, offsetF };
}
function validateMSMPoints(points, c) {
  if (!Array.isArray(points))
    throw new Error("array expected");
  points.forEach((p, i) => {
    if (!(p instanceof c))
      throw new Error("invalid point at index " + i);
  });
}
function validateMSMScalars(scalars, field) {
  if (!Array.isArray(scalars))
    throw new Error("array of scalars expected");
  scalars.forEach((s, i) => {
    if (!field.isValid(s))
      throw new Error("invalid scalar at index " + i);
  });
}
var pointPrecomputes = /* @__PURE__ */ new WeakMap();
var pointWindowSizes = /* @__PURE__ */ new WeakMap();
function getW(P) {
  return pointWindowSizes.get(P) || 1;
}
function wNAF(c, bits) {
  return {
    constTimeNegate,
    hasPrecomputes(elm) {
      return getW(elm) !== 1;
    },
    // non-const time multiplication ladder
    unsafeLadder(elm, n, p = c.ZERO) {
      let d = elm;
      while (n > _0n3) {
        if (n & _1n3)
          p = p.add(d);
        d = d.double();
        n >>= _1n3;
      }
      return p;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @param elm Point instance
     * @param W window size
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(elm, W) {
      const { windows, windowSize } = calcWOpts(W, bits);
      const points = [];
      let p = elm;
      let base14 = p;
      for (let window2 = 0; window2 < windows; window2++) {
        base14 = p;
        points.push(base14);
        for (let i = 1; i < windowSize; i++) {
          base14 = base14.add(p);
          points.push(base14);
        }
        p = base14.double();
      }
      return points;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(W, precomputes, n) {
      let p = c.ZERO;
      let f = c.BASE;
      const wo = calcWOpts(W, bits);
      for (let window2 = 0; window2 < wo.windows; window2++) {
        const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window2, wo);
        n = nextN;
        if (isZero) {
          f = f.add(constTimeNegate(isNegF, precomputes[offsetF]));
        } else {
          p = p.add(constTimeNegate(isNeg, precomputes[offset]));
        }
      }
      return { p, f };
    },
    /**
     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @param acc accumulator point to add result of multiplication
     * @returns point
     */
    wNAFUnsafe(W, precomputes, n, acc = c.ZERO) {
      const wo = calcWOpts(W, bits);
      for (let window2 = 0; window2 < wo.windows; window2++) {
        if (n === _0n3)
          break;
        const { nextN, offset, isZero, isNeg } = calcOffsets(n, window2, wo);
        n = nextN;
        if (isZero) {
          continue;
        } else {
          const item = precomputes[offset];
          acc = acc.add(isNeg ? item.negate() : item);
        }
      }
      return acc;
    },
    getPrecomputes(W, P, transform) {
      let comp = pointPrecomputes.get(P);
      if (!comp) {
        comp = this.precomputeWindow(P, W);
        if (W !== 1)
          pointPrecomputes.set(P, transform(comp));
      }
      return comp;
    },
    wNAFCached(P, n, transform) {
      const W = getW(P);
      return this.wNAF(W, this.getPrecomputes(W, P, transform), n);
    },
    wNAFCachedUnsafe(P, n, transform, prev) {
      const W = getW(P);
      if (W === 1)
        return this.unsafeLadder(P, n, prev);
      return this.wNAFUnsafe(W, this.getPrecomputes(W, P, transform), n, prev);
    },
    // We calculate precomputes for elliptic curve point multiplication
    // using windowed method. This specifies window size and
    // stores precomputed values. Usually only base point would be precomputed.
    setWindowSize(P, W) {
      validateW(W, bits);
      pointWindowSizes.set(P, W);
      pointPrecomputes.delete(P);
    }
  };
}
function pippenger(c, fieldN, points, scalars) {
  validateMSMPoints(points, c);
  validateMSMScalars(scalars, fieldN);
  if (points.length !== scalars.length)
    throw new Error("arrays of points and scalars must have equal length");
  const zero = c.ZERO;
  const wbits = bitLen(BigInt(points.length));
  const windowSize = wbits > 12 ? wbits - 3 : wbits > 4 ? wbits - 2 : wbits ? 2 : 1;
  const MASK = bitMask(windowSize);
  const buckets = new Array(Number(MASK) + 1).fill(zero);
  const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
  let sum = zero;
  for (let i = lastBits; i >= 0; i -= windowSize) {
    buckets.fill(zero);
    for (let j = 0; j < scalars.length; j++) {
      const scalar = scalars[j];
      const wbits2 = Number(scalar >> BigInt(i) & MASK);
      buckets[wbits2] = buckets[wbits2].add(points[j]);
    }
    let resI = zero;
    for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {
      sumI = sumI.add(buckets[j]);
      resI = resI.add(sumI);
    }
    sum = sum.add(resI);
    if (i !== 0)
      for (let j = 0; j < windowSize; j++)
        sum = sum.double();
  }
  return sum;
}
function validateBasic(curve) {
  validateField(curve.Fp);
  validateObject(curve, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  });
  return Object.freeze({
    ...nLength(curve.n, curve.nBitLength),
    ...curve,
    ...{ p: curve.Fp.ORDER }
  });
}

// node_modules/@noble/curves/esm/abstract/weierstrass.js
function validateSigVerOpts(opts) {
  if (opts.lowS !== void 0)
    abool("lowS", opts.lowS);
  if (opts.prehash !== void 0)
    abool("prehash", opts.prehash);
}
function validatePointOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo, Fp, a } = opts;
  if (endo) {
    if (!Fp.eql(a, Fp.ZERO)) {
      throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");
    }
    if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
      throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function");
    }
  }
  return Object.freeze({ ...opts });
}
var DERErr = class extends Error {
  constructor(m = "") {
    super(m);
  }
};
var DER = {
  // asn.1 DER encoding utils
  Err: DERErr,
  // Basic building block is TLV (Tag-Length-Value)
  _tlv: {
    encode: (tag, data) => {
      const { Err: E } = DER;
      if (tag < 0 || tag > 256)
        throw new E("tlv.encode: wrong tag");
      if (data.length & 1)
        throw new E("tlv.encode: unpadded data");
      const dataLen = data.length / 2;
      const len = numberToHexUnpadded(dataLen);
      if (len.length / 2 & 128)
        throw new E("tlv.encode: long form length too big");
      const lenLen = dataLen > 127 ? numberToHexUnpadded(len.length / 2 | 128) : "";
      const t = numberToHexUnpadded(tag);
      return t + lenLen + len + data;
    },
    // v - value, l - left bytes (unparsed)
    decode(tag, data) {
      const { Err: E } = DER;
      let pos = 0;
      if (tag < 0 || tag > 256)
        throw new E("tlv.encode: wrong tag");
      if (data.length < 2 || data[pos++] !== tag)
        throw new E("tlv.decode: wrong tlv");
      const first2 = data[pos++];
      const isLong = !!(first2 & 128);
      let length11 = 0;
      if (!isLong)
        length11 = first2;
      else {
        const lenLen = first2 & 127;
        if (!lenLen)
          throw new E("tlv.decode(long): indefinite length not supported");
        if (lenLen > 4)
          throw new E("tlv.decode(long): byte length is too big");
        const lengthBytes = data.subarray(pos, pos + lenLen);
        if (lengthBytes.length !== lenLen)
          throw new E("tlv.decode: length bytes not complete");
        if (lengthBytes[0] === 0)
          throw new E("tlv.decode(long): zero leftmost byte");
        for (const b of lengthBytes)
          length11 = length11 << 8 | b;
        pos += lenLen;
        if (length11 < 128)
          throw new E("tlv.decode(long): not minimal encoding");
      }
      const v = data.subarray(pos, pos + length11);
      if (v.length !== length11)
        throw new E("tlv.decode: wrong value length");
      return { v, l: data.subarray(pos + length11) };
    }
  },
  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
  // since we always use positive integers here. It must always be empty:
  // - add zero byte if exists
  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
  _int: {
    encode(num) {
      const { Err: E } = DER;
      if (num < _0n4)
        throw new E("integer: negative integers are not allowed");
      let hex = numberToHexUnpadded(num);
      if (Number.parseInt(hex[0], 16) & 8)
        hex = "00" + hex;
      if (hex.length & 1)
        throw new E("unexpected DER parsing assertion: unpadded hex");
      return hex;
    },
    decode(data) {
      const { Err: E } = DER;
      if (data[0] & 128)
        throw new E("invalid signature integer: negative");
      if (data[0] === 0 && !(data[1] & 128))
        throw new E("invalid signature integer: unnecessary leading zero");
      return bytesToNumberBE(data);
    }
  },
  toSig(hex) {
    const { Err: E, _int: int, _tlv: tlv } = DER;
    const data = ensureBytes("signature", hex);
    const { v: seqBytes, l: seqLeftBytes } = tlv.decode(48, data);
    if (seqLeftBytes.length)
      throw new E("invalid signature: left bytes after parsing");
    const { v: rBytes, l: rLeftBytes } = tlv.decode(2, seqBytes);
    const { v: sBytes, l: sLeftBytes } = tlv.decode(2, rLeftBytes);
    if (sLeftBytes.length)
      throw new E("invalid signature: left bytes after parsing");
    return { r: int.decode(rBytes), s: int.decode(sBytes) };
  },
  hexFromSig(sig) {
    const { _tlv: tlv, _int: int } = DER;
    const rs = tlv.encode(2, int.encode(sig.r));
    const ss = tlv.encode(2, int.encode(sig.s));
    const seq = rs + ss;
    return tlv.encode(48, seq);
  }
};
var _0n4 = BigInt(0);
var _1n4 = BigInt(1);
var _2n2 = BigInt(2);
var _3n2 = BigInt(3);
var _4n2 = BigInt(4);
function weierstrassPoints(opts) {
  const CURVE = validatePointOpts(opts);
  const { Fp } = CURVE;
  const Fn = Field(CURVE.n, CURVE.nBitLength);
  const toBytes5 = CURVE.toBytes || ((_c, point, _isCompressed) => {
    const a = point.toAffine();
    return concatBytes2(Uint8Array.from([4]), Fp.toBytes(a.x), Fp.toBytes(a.y));
  });
  const fromBytes2 = CURVE.fromBytes || ((bytes) => {
    const tail = bytes.subarray(1);
    const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
    const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
    return { x, y };
  });
  function weierstrassEquation(x) {
    const { a, b } = CURVE;
    const x2 = Fp.sqr(x);
    const x3 = Fp.mul(x2, x);
    return Fp.add(Fp.add(x3, Fp.mul(x, a)), b);
  }
  if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
    throw new Error("bad generator point: equation left != right");
  function isWithinCurveOrder(num) {
    return inRange(num, _1n4, CURVE.n);
  }
  function normPrivateKeyToScalar(key) {
    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: N } = CURVE;
    if (lengths && typeof key !== "bigint") {
      if (isBytes3(key))
        key = bytesToHex2(key);
      if (typeof key !== "string" || !lengths.includes(key.length))
        throw new Error("invalid private key");
      key = key.padStart(nByteLength * 2, "0");
    }
    let num;
    try {
      num = typeof key === "bigint" ? key : bytesToNumberBE(ensureBytes("private key", key, nByteLength));
    } catch (error) {
      throw new Error("invalid private key, expected hex or " + nByteLength + " bytes, got " + typeof key);
    }
    if (wrapPrivateKey)
      num = mod2(num, N);
    aInRange("private key", num, _1n4, N);
    return num;
  }
  function aprjpoint(other) {
    if (!(other instanceof Point2))
      throw new Error("ProjectivePoint expected");
  }
  const toAffineMemo = memoized((p, iz) => {
    const { px: x, py: y, pz: z } = p;
    if (Fp.eql(z, Fp.ONE))
      return { x, y };
    const is0 = p.is0();
    if (iz == null)
      iz = is0 ? Fp.ONE : Fp.inv(z);
    const ax = Fp.mul(x, iz);
    const ay = Fp.mul(y, iz);
    const zz = Fp.mul(z, iz);
    if (is0)
      return { x: Fp.ZERO, y: Fp.ZERO };
    if (!Fp.eql(zz, Fp.ONE))
      throw new Error("invZ was invalid");
    return { x: ax, y: ay };
  });
  const assertValidMemo = memoized((p) => {
    if (p.is0()) {
      if (CURVE.allowInfinityPoint && !Fp.is0(p.py))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x, y } = p.toAffine();
    if (!Fp.isValid(x) || !Fp.isValid(y))
      throw new Error("bad point: x or y not FE");
    const left = Fp.sqr(y);
    const right = weierstrassEquation(x);
    if (!Fp.eql(left, right))
      throw new Error("bad point: equation left != right");
    if (!p.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return true;
  });
  class Point2 {
    constructor(px, py, pz) {
      if (px == null || !Fp.isValid(px))
        throw new Error("x required");
      if (py == null || !Fp.isValid(py) || Fp.is0(py))
        throw new Error("y required");
      if (pz == null || !Fp.isValid(pz))
        throw new Error("z required");
      this.px = px;
      this.py = py;
      this.pz = pz;
      Object.freeze(this);
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(p) {
      const { x, y } = p || {};
      if (!p || !Fp.isValid(x) || !Fp.isValid(y))
        throw new Error("invalid affine point");
      if (p instanceof Point2)
        throw new Error("projective point not allowed");
      const is0 = (i) => Fp.eql(i, Fp.ZERO);
      if (is0(x) && is0(y))
        return Point2.ZERO;
      return new Point2(x, y, Fp.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(points) {
      const toInv = FpInvertBatch(Fp, points.map((p) => p.pz));
      return points.map((p, i) => p.toAffine(toInv[i])).map(Point2.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(hex) {
      const P = Point2.fromAffine(fromBytes2(ensureBytes("pointHex", hex)));
      P.assertValidity();
      return P;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(privateKey) {
      return Point2.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    // Multiscalar Multiplication
    static msm(points, scalars) {
      return pippenger(Point2, Fn, points, scalars);
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      wnaf.setWindowSize(this, windowSize);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      assertValidMemo(this);
    }
    hasEvenY() {
      const { y } = this.toAffine();
      if (Fp.isOdd)
        return !Fp.isOdd(y);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(other) {
      aprjpoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
      const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
      return U1 && U2;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new Point2(this.px, Fp.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a, b } = CURVE;
      const b3 = Fp.mul(b, _3n2);
      const { px: X1, py: Y1, pz: Z1 } = this;
      let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
      let t0 = Fp.mul(X1, X1);
      let t1 = Fp.mul(Y1, Y1);
      let t2 = Fp.mul(Z1, Z1);
      let t3 = Fp.mul(X1, Y1);
      t3 = Fp.add(t3, t3);
      Z3 = Fp.mul(X1, Z1);
      Z3 = Fp.add(Z3, Z3);
      X3 = Fp.mul(a, Z3);
      Y3 = Fp.mul(b3, t2);
      Y3 = Fp.add(X3, Y3);
      X3 = Fp.sub(t1, Y3);
      Y3 = Fp.add(t1, Y3);
      Y3 = Fp.mul(X3, Y3);
      X3 = Fp.mul(t3, X3);
      Z3 = Fp.mul(b3, Z3);
      t2 = Fp.mul(a, t2);
      t3 = Fp.sub(t0, t2);
      t3 = Fp.mul(a, t3);
      t3 = Fp.add(t3, Z3);
      Z3 = Fp.add(t0, t0);
      t0 = Fp.add(Z3, t0);
      t0 = Fp.add(t0, t2);
      t0 = Fp.mul(t0, t3);
      Y3 = Fp.add(Y3, t0);
      t2 = Fp.mul(Y1, Z1);
      t2 = Fp.add(t2, t2);
      t0 = Fp.mul(t2, t3);
      X3 = Fp.sub(X3, t0);
      Z3 = Fp.mul(t2, t1);
      Z3 = Fp.add(Z3, Z3);
      Z3 = Fp.add(Z3, Z3);
      return new Point2(X3, Y3, Z3);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(other) {
      aprjpoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
      const a = CURVE.a;
      const b3 = Fp.mul(CURVE.b, _3n2);
      let t0 = Fp.mul(X1, X2);
      let t1 = Fp.mul(Y1, Y2);
      let t2 = Fp.mul(Z1, Z2);
      let t3 = Fp.add(X1, Y1);
      let t4 = Fp.add(X2, Y2);
      t3 = Fp.mul(t3, t4);
      t4 = Fp.add(t0, t1);
      t3 = Fp.sub(t3, t4);
      t4 = Fp.add(X1, Z1);
      let t5 = Fp.add(X2, Z2);
      t4 = Fp.mul(t4, t5);
      t5 = Fp.add(t0, t2);
      t4 = Fp.sub(t4, t5);
      t5 = Fp.add(Y1, Z1);
      X3 = Fp.add(Y2, Z2);
      t5 = Fp.mul(t5, X3);
      X3 = Fp.add(t1, t2);
      t5 = Fp.sub(t5, X3);
      Z3 = Fp.mul(a, t4);
      X3 = Fp.mul(b3, t2);
      Z3 = Fp.add(X3, Z3);
      X3 = Fp.sub(t1, Z3);
      Z3 = Fp.add(t1, Z3);
      Y3 = Fp.mul(X3, Z3);
      t1 = Fp.add(t0, t0);
      t1 = Fp.add(t1, t0);
      t2 = Fp.mul(a, t2);
      t4 = Fp.mul(b3, t4);
      t1 = Fp.add(t1, t2);
      t2 = Fp.sub(t0, t2);
      t2 = Fp.mul(a, t2);
      t4 = Fp.add(t4, t2);
      t0 = Fp.mul(t1, t4);
      Y3 = Fp.add(Y3, t0);
      t0 = Fp.mul(t5, t4);
      X3 = Fp.mul(t3, X3);
      X3 = Fp.sub(X3, t0);
      t0 = Fp.mul(t3, t1);
      Z3 = Fp.mul(t5, Z3);
      Z3 = Fp.add(Z3, t0);
      return new Point2(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point2.ZERO);
    }
    wNAF(n) {
      return wnaf.wNAFCached(this, n, Point2.normalizeZ);
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(sc) {
      const { endo, n: N } = CURVE;
      aInRange("scalar", sc, _0n4, N);
      const I = Point2.ZERO;
      if (sc === _0n4)
        return I;
      if (this.is0() || sc === _1n4)
        return this;
      if (!endo || wnaf.hasPrecomputes(this))
        return wnaf.wNAFCachedUnsafe(this, sc, Point2.normalizeZ);
      let { k1neg, k1, k2neg, k2 } = endo.splitScalar(sc);
      let k1p = I;
      let k2p = I;
      let d = this;
      while (k1 > _0n4 || k2 > _0n4) {
        if (k1 & _1n4)
          k1p = k1p.add(d);
        if (k2 & _1n4)
          k2p = k2p.add(d);
        d = d.double();
        k1 >>= _1n4;
        k2 >>= _1n4;
      }
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new Point2(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
      return k1p.add(k2p);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(scalar) {
      const { endo, n: N } = CURVE;
      aInRange("scalar", scalar, _1n4, N);
      let point, fake;
      if (endo) {
        const { k1neg, k1, k2neg, k2 } = endo.splitScalar(scalar);
        let { p: k1p, f: f1p } = this.wNAF(k1);
        let { p: k2p, f: f2p } = this.wNAF(k2);
        k1p = wnaf.constTimeNegate(k1neg, k1p);
        k2p = wnaf.constTimeNegate(k2neg, k2p);
        k2p = new Point2(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        point = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        const { p, f } = this.wNAF(scalar);
        point = p;
        fake = f;
      }
      return Point2.normalizeZ([point, fake])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(Q, a, b) {
      const G = Point2.BASE;
      const mul3 = (P, a2) => a2 === _0n4 || a2 === _1n4 || !P.equals(G) ? P.multiplyUnsafe(a2) : P.multiply(a2);
      const sum = mul3(this, a).add(mul3(Q, b));
      return sum.is0() ? void 0 : sum;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z)  (x=x/z, y=y/z)
    toAffine(iz) {
      return toAffineMemo(this, iz);
    }
    isTorsionFree() {
      const { h: cofactor, isTorsionFree } = CURVE;
      if (cofactor === _1n4)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point2, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: cofactor, clearCofactor } = CURVE;
      if (cofactor === _1n4)
        return this;
      if (clearCofactor)
        return clearCofactor(Point2, this);
      return this.multiplyUnsafe(CURVE.h);
    }
    toRawBytes(isCompressed = true) {
      abool("isCompressed", isCompressed);
      this.assertValidity();
      return toBytes5(Point2, this, isCompressed);
    }
    toHex(isCompressed = true) {
      abool("isCompressed", isCompressed);
      return bytesToHex2(this.toRawBytes(isCompressed));
    }
  }
  Point2.BASE = new Point2(CURVE.Gx, CURVE.Gy, Fp.ONE);
  Point2.ZERO = new Point2(Fp.ZERO, Fp.ONE, Fp.ZERO);
  const _bits = CURVE.nBitLength;
  const wnaf = wNAF(Point2, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
  return {
    CURVE,
    ProjectivePoint: Point2,
    normPrivateKeyToScalar,
    weierstrassEquation,
    isWithinCurveOrder
  };
}
function validateOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  });
  return Object.freeze({ lowS: true, ...opts });
}
function weierstrass(curveDef) {
  const CURVE = validateOpts(curveDef);
  const { Fp, n: CURVE_ORDER } = CURVE;
  const compressedLen = Fp.BYTES + 1;
  const uncompressedLen = 2 * Fp.BYTES + 1;
  function modN(a) {
    return mod2(a, CURVE_ORDER);
  }
  function invN(a) {
    return invert(a, CURVE_ORDER);
  }
  const { ProjectivePoint: Point2, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
    ...CURVE,
    toBytes(_c, point, isCompressed) {
      const a = point.toAffine();
      const x = Fp.toBytes(a.x);
      const cat = concatBytes2;
      abool("isCompressed", isCompressed);
      if (isCompressed) {
        return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);
      } else {
        return cat(Uint8Array.from([4]), x, Fp.toBytes(a.y));
      }
    },
    fromBytes(bytes) {
      const len = bytes.length;
      const head = bytes[0];
      const tail = bytes.subarray(1);
      if (len === compressedLen && (head === 2 || head === 3)) {
        const x = bytesToNumberBE(tail);
        if (!inRange(x, _1n4, Fp.ORDER))
          throw new Error("Point is not on curve");
        const y2 = weierstrassEquation(x);
        let y;
        try {
          y = Fp.sqrt(y2);
        } catch (sqrtError) {
          const suffix = sqrtError instanceof Error ? ": " + sqrtError.message : "";
          throw new Error("Point is not on curve" + suffix);
        }
        const isYOdd = (y & _1n4) === _1n4;
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y = Fp.neg(y);
        return { x, y };
      } else if (len === uncompressedLen && head === 4) {
        const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
        const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
        return { x, y };
      } else {
        const cl = compressedLen;
        const ul = uncompressedLen;
        throw new Error("invalid Point, expected length of " + cl + ", or uncompressed " + ul + ", got " + len);
      }
    }
  });
  const numToNByteHex = (num) => bytesToHex2(numberToBytesBE(num, CURVE.nByteLength));
  function isBiggerThanHalfOrder(number) {
    const HALF = CURVE_ORDER >> _1n4;
    return number > HALF;
  }
  function normalizeS(s) {
    return isBiggerThanHalfOrder(s) ? modN(-s) : s;
  }
  const slcNum = (b, from17, to) => bytesToNumberBE(b.slice(from17, to));
  class Signature {
    constructor(r, s, recovery) {
      aInRange("r", r, _1n4, CURVE_ORDER);
      aInRange("s", s, _1n4, CURVE_ORDER);
      this.r = r;
      this.s = s;
      if (recovery != null)
        this.recovery = recovery;
      Object.freeze(this);
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(hex) {
      const l = CURVE.nByteLength;
      hex = ensureBytes("compactSignature", hex, l * 2);
      return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(hex) {
      const { r, s } = DER.toSig(ensureBytes("DER", hex));
      return new Signature(r, s);
    }
    /**
     * @todo remove
     * @deprecated
     */
    assertValidity() {
    }
    addRecoveryBit(recovery) {
      return new Signature(this.r, this.s, recovery);
    }
    recoverPublicKey(msgHash) {
      const { r, s, recovery: rec } = this;
      const h = bits2int_modN(ensureBytes("msgHash", msgHash));
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
      if (radj >= Fp.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const prefix = (rec & 1) === 0 ? "02" : "03";
      const R = Point2.fromHex(prefix + numToNByteHex(radj));
      const ir = invN(radj);
      const u1 = modN(-h * ir);
      const u2 = modN(s * ir);
      const Q = Point2.BASE.multiplyAndAddUnsafe(R, u1, u2);
      if (!Q)
        throw new Error("point at infinify");
      Q.assertValidity();
      return Q;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return hexToBytes2(this.toDERHex());
    }
    toDERHex() {
      return DER.hexFromSig(this);
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return hexToBytes2(this.toCompactHex());
    }
    toCompactHex() {
      return numToNByteHex(this.r) + numToNByteHex(this.s);
    }
  }
  const utils = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error) {
        return false;
      }
    },
    normPrivateKeyToScalar,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const length11 = getMinHashLength(CURVE.n);
      return mapHashToField(CURVE.randomBytes(length11), CURVE.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(windowSize = 8, point = Point2.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  function getPublicKey(privateKey, isCompressed = true) {
    return Point2.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  }
  function isProbPub(item) {
    const arr = isBytes3(item);
    const str = typeof item === "string";
    const len = (arr || str) && item.length;
    if (arr)
      return len === compressedLen || len === uncompressedLen;
    if (str)
      return len === 2 * compressedLen || len === 2 * uncompressedLen;
    if (item instanceof Point2)
      return true;
    return false;
  }
  function getSharedSecret(privateA, publicB, isCompressed = true) {
    if (isProbPub(privateA))
      throw new Error("first arg must be private key");
    if (!isProbPub(publicB))
      throw new Error("second arg must be public key");
    const b = Point2.fromHex(publicB);
    return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
  }
  const bits2int = CURVE.bits2int || function(bytes) {
    if (bytes.length > 8192)
      throw new Error("input is too large");
    const num = bytesToNumberBE(bytes);
    const delta = bytes.length * 8 - CURVE.nBitLength;
    return delta > 0 ? num >> BigInt(delta) : num;
  };
  const bits2int_modN = CURVE.bits2int_modN || function(bytes) {
    return modN(bits2int(bytes));
  };
  const ORDER_MASK = bitMask(CURVE.nBitLength);
  function int2octets(num) {
    aInRange("num < 2^" + CURVE.nBitLength, num, _0n4, ORDER_MASK);
    return numberToBytesBE(num, CURVE.nByteLength);
  }
  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
    if (["recovered", "canonical"].some((k) => k in opts))
      throw new Error("sign() legacy options not supported");
    const { hash, randomBytes: randomBytes3 } = CURVE;
    let { lowS, prehash, extraEntropy: ent } = opts;
    if (lowS == null)
      lowS = true;
    msgHash = ensureBytes("msgHash", msgHash);
    validateSigVerOpts(opts);
    if (prehash)
      msgHash = ensureBytes("prehashed msgHash", hash(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d = normPrivateKeyToScalar(privateKey);
    const seedArgs = [int2octets(d), int2octets(h1int)];
    if (ent != null && ent !== false) {
      const e = ent === true ? randomBytes3(Fp.BYTES) : ent;
      seedArgs.push(ensureBytes("extraEntropy", e));
    }
    const seed = concatBytes2(...seedArgs);
    const m = h1int;
    function k2sig(kBytes) {
      const k = bits2int(kBytes);
      if (!isWithinCurveOrder(k))
        return;
      const ik = invN(k);
      const q = Point2.BASE.multiply(k).toAffine();
      const r = modN(q.x);
      if (r === _0n4)
        return;
      const s = modN(ik * modN(m + r * d));
      if (s === _0n4)
        return;
      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n4);
      let normS = s;
      if (lowS && isBiggerThanHalfOrder(s)) {
        normS = normalizeS(s);
        recovery ^= 1;
      }
      return new Signature(r, normS, recovery);
    }
    return { seed, k2sig };
  }
  const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
  const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
  function sign(msgHash, privKey, opts = defaultSigOpts) {
    const { seed, k2sig } = prepSig(msgHash, privKey, opts);
    const C = CURVE;
    const drbg = createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
    return drbg(seed, k2sig);
  }
  Point2.BASE._setWindowSize(8);
  function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
    const sg = signature;
    msgHash = ensureBytes("msgHash", msgHash);
    publicKey = ensureBytes("publicKey", publicKey);
    const { lowS, prehash, format: format12 } = opts;
    validateSigVerOpts(opts);
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    if (format12 !== void 0 && format12 !== "compact" && format12 !== "der")
      throw new Error("format must be compact or der");
    const isHex = typeof sg === "string" || isBytes3(sg);
    const isObj = !isHex && !format12 && typeof sg === "object" && sg !== null && typeof sg.r === "bigint" && typeof sg.s === "bigint";
    if (!isHex && !isObj)
      throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
    let _sig = void 0;
    let P;
    try {
      if (isObj)
        _sig = new Signature(sg.r, sg.s);
      if (isHex) {
        try {
          if (format12 !== "compact")
            _sig = Signature.fromDER(sg);
        } catch (derError) {
          if (!(derError instanceof DER.Err))
            throw derError;
        }
        if (!_sig && format12 !== "der")
          _sig = Signature.fromCompact(sg);
      }
      P = Point2.fromHex(publicKey);
    } catch (error) {
      return false;
    }
    if (!_sig)
      return false;
    if (lowS && _sig.hasHighS())
      return false;
    if (prehash)
      msgHash = CURVE.hash(msgHash);
    const { r, s } = _sig;
    const h = bits2int_modN(msgHash);
    const is2 = invN(s);
    const u1 = modN(h * is2);
    const u2 = modN(r * is2);
    const R = Point2.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine();
    if (!R)
      return false;
    const v = modN(R.x);
    return v === r;
  }
  return {
    CURVE,
    getPublicKey,
    getSharedSecret,
    sign,
    verify,
    ProjectivePoint: Point2,
    Signature,
    utils
  };
}

// node_modules/@noble/curves/esm/_shortw_utils.js
function getHash(hash) {
  return {
    hash,
    hmac: (key, ...msgs) => hmac(hash, key, concatBytes(...msgs)),
    randomBytes
  };
}
function createCurve(curveDef, defHash) {
  const create12 = (hash) => weierstrass({ ...curveDef, ...getHash(hash) });
  return { ...create12(defHash), create: create12 };
}

// node_modules/@noble/curves/esm/secp256k1.js
var secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
var secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var _1n5 = BigInt(1);
var _2n3 = BigInt(2);
var divNearest = (a, b) => (a + b / _2n3) / b;
function sqrtMod(y) {
  const P = secp256k1P;
  const _3n3 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b2 = y * y * y % P;
  const b3 = b2 * b2 * y % P;
  const b6 = pow2(b3, _3n3, P) * b3 % P;
  const b9 = pow2(b6, _3n3, P) * b3 % P;
  const b11 = pow2(b9, _2n3, P) * b2 % P;
  const b22 = pow2(b11, _11n, P) * b11 % P;
  const b44 = pow2(b22, _22n, P) * b22 % P;
  const b88 = pow2(b44, _44n, P) * b44 % P;
  const b176 = pow2(b88, _88n, P) * b88 % P;
  const b220 = pow2(b176, _44n, P) * b44 % P;
  const b223 = pow2(b220, _3n3, P) * b3 % P;
  const t1 = pow2(b223, _23n, P) * b22 % P;
  const t2 = pow2(t1, _6n, P) * b2 % P;
  const root = pow2(t2, _2n3, P);
  if (!Fpk1.eql(Fpk1.sqr(root), y))
    throw new Error("Cannot find square root");
  return root;
}
var Fpk1 = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
var secp256k1 = createCurve({
  a: BigInt(0),
  b: BigInt(7),
  Fp: Fpk1,
  n: secp256k1N,
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  lowS: true,
  // Allow only low-S signatures by default in sign() and verify()
  endo: {
    // Endomorphism, see above
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (k) => {
      const n = secp256k1N;
      const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
      const b1 = -_1n5 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
      const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
      const b2 = a1;
      const POW_2_128 = BigInt("0x100000000000000000000000000000000");
      const c1 = divNearest(b2 * k, n);
      const c2 = divNearest(-b1 * k, n);
      let k1 = mod2(k - c1 * a1 - c2 * a2, n);
      let k2 = mod2(-c1 * b1 - c2 * b2, n);
      const k1neg = k1 > POW_2_128;
      const k2neg = k2 > POW_2_128;
      if (k1neg)
        k1 = n - k1;
      if (k2neg)
        k2 = n - k2;
      if (k1 > POW_2_128 || k2 > POW_2_128) {
        throw new Error("splitScalar: Endomorphism failed, k=" + k);
      }
      return { k1neg, k1, k2neg, k2 };
    }
  }
}, sha256);
var _0n5 = BigInt(0);
var Point = secp256k1.ProjectivePoint;

// node_modules/@noble/hashes/esm/_assert.js
var abytes3 = abytes;

// node_modules/ethereum-cryptography/esm/utils.js
function hexToBytes3(data) {
  const sliced = data.startsWith("0x") ? data.substring(2) : data;
  return hexToBytes(sliced);
}
function equalsBytes(a, b) {
  if (a.length !== b.length) {
    return false;
  }
  for (let i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}
function wrapHash(hash) {
  return (msg) => {
    abytes3(msg);
    return hash(msg);
  };
}

// node_modules/ethereum-cryptography/esm/sha256.js
var sha2562 = wrapHash(sha256);

// node_modules/ethereum-cryptography/esm/random.js
function getRandomBytesSync(bytes) {
  return randomBytes(bytes);
}

// node_modules/@ethereumjs/rlp/dist/esm/errors.js
var DEFAULT_ERROR_CODE = "ETHEREUMJS_DEFAULT_ERROR_CODE";
var EthereumJSError = class extends Error {
  constructor(type, message, stack) {
    super(message ?? type.code);
    this.type = type;
    if (stack !== void 0)
      this.stack = stack;
  }
  getMetadata() {
    return this.type;
  }
  /**
   * Get the metadata and the stacktrace for the error.
   */
  toObject() {
    return {
      type: this.getMetadata(),
      message: this.message ?? "",
      stack: this.stack ?? "",
      className: this.constructor.name
    };
  }
};
function EthereumJSErrorWithoutCode(message, stack) {
  return new EthereumJSError({ code: DEFAULT_ERROR_CODE }, message, stack);
}

// node_modules/@ethereumjs/rlp/dist/esm/index.js
var cachedHexes = Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, "0"));

// node_modules/@ethereumjs/util/dist/esm/internal.js
function isHexString(value, length11) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/))
    return false;
  if (typeof length11 !== "undefined" && length11 > 0 && value.length !== 2 + 2 * length11)
    return false;
  return true;
}
var stripHexPrefix = (str) => {
  if (typeof str !== "string")
    throw EthereumJSErrorWithoutCode(`[stripHexPrefix] input must be type 'string', received ${typeof str}`);
  return isHexString(str) ? str.slice(2) : str;
};
function padToEven(value) {
  let a = value;
  if (typeof a !== "string") {
    throw EthereumJSErrorWithoutCode(`[padToEven] value must be type 'string', received ${typeof a}`);
  }
  if (a.length % 2)
    a = `0${a}`;
  return a;
}

// node_modules/@ethereumjs/util/dist/esm/helpers.js
var assertIsHexString = function(input) {
  if (!isHexString(input)) {
    const msg = `This method only supports 0x-prefixed hex strings but input was: ${input}`;
    throw EthereumJSErrorWithoutCode(msg);
  }
};
var assertIsBytes = function(input) {
  if (!(input instanceof Uint8Array)) {
    const msg = `This method only supports Uint8Array but input was: ${input}`;
    throw EthereumJSErrorWithoutCode(msg);
  }
};

// node_modules/@ethereumjs/util/dist/esm/bytes.js
var BIGINT_0 = BigInt(0);
var bytesToUnprefixedHex = bytesToHex;
var hexToBytes4 = (hex) => {
  if (!hex.startsWith("0x"))
    throw EthereumJSErrorWithoutCode("input string must be 0x prefixed");
  return hexToBytes3(padToEven(stripHexPrefix(hex)));
};
var unprefixedHexToBytes = (hex) => {
  if (hex.startsWith("0x"))
    throw EthereumJSErrorWithoutCode("input string cannot be 0x prefixed");
  return hexToBytes3(padToEven(hex));
};
var bytesToHex3 = (bytes) => {
  const unprefixedHex = bytesToUnprefixedHex(bytes);
  return `0x${unprefixedHex}`;
};
var BIGINT_CACHE = [];
for (let i = 0; i <= 256 * 256 - 1; i++) {
  BIGINT_CACHE[i] = BigInt(i);
}
var bytesToBigInt = (bytes, littleEndian = false) => {
  if (littleEndian) {
    bytes.reverse();
  }
  const hex = bytesToHex3(bytes);
  if (hex === "0x") {
    return BIGINT_0;
  }
  if (hex.length === 4) {
    return BIGINT_CACHE[bytes[0]];
  }
  if (hex.length === 6) {
    return BIGINT_CACHE[bytes[0] * 256 + bytes[1]];
  }
  return BigInt(hex);
};
var intToHex = (i) => {
  if (!Number.isSafeInteger(i) || i < 0) {
    throw EthereumJSErrorWithoutCode(`Received an invalid integer type: ${i}`);
  }
  return `0x${i.toString(16)}`;
};
var intToBytes = (i) => {
  const hex = intToHex(i);
  return hexToBytes4(hex);
};
var toBytes2 = (v) => {
  if (v === null || v === void 0) {
    return new Uint8Array();
  }
  if (Array.isArray(v) || v instanceof Uint8Array) {
    return Uint8Array.from(v);
  }
  if (typeof v === "string") {
    if (!isHexString(v)) {
      throw EthereumJSErrorWithoutCode(`Cannot convert string to Uint8Array. toBytes only supports 0x-prefixed hex strings and this string was given: ${v}`);
    }
    return hexToBytes4(v);
  }
  if (typeof v === "number") {
    return intToBytes(v);
  }
  if (typeof v === "bigint") {
    if (v < BIGINT_0) {
      throw EthereumJSErrorWithoutCode(`Cannot convert negative bigint to Uint8Array. Given: ${v}`);
    }
    let n = v.toString(16);
    if (n.length % 2)
      n = "0" + n;
    return unprefixedHexToBytes(n);
  }
  if (v.toBytes !== void 0) {
    return v.toBytes();
  }
  throw EthereumJSErrorWithoutCode("invalid type");
};
var randomBytes2 = (length11) => {
  return getRandomBytesSync(length11);
};
var concatBytes3 = (...arrays) => {
  if (arrays.length === 1)
    return arrays[0];
  const length11 = arrays.reduce((a, arr) => a + arr.length, 0);
  const result = new Uint8Array(length11);
  for (let i = 0, pad = 0; i < arrays.length; i++) {
    const arr = arrays[i];
    result.set(arr, pad);
    pad += arr.length;
  }
  return result;
};

// node_modules/@ethereumjs/util/dist/esm/constants.js
var MAX_UINT64 = BigInt("0xffffffffffffffff");
var MAX_INTEGER = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var MAX_INTEGER_BIGINT = BigInt("115792089237316195423570985008687907853269984665640564039457584007913129639935");
var SECP256K1_ORDER = secp256k1.CURVE.n;
var SECP256K1_ORDER_DIV_2 = secp256k1.CURVE.n / BigInt(2);
var TWO_POW256 = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
var KECCAK256_NULL_S = "0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470";
var KECCAK256_NULL = hexToBytes4(KECCAK256_NULL_S);
var KECCAK256_RLP_ARRAY_S = "0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347";
var KECCAK256_RLP_ARRAY = hexToBytes4(KECCAK256_RLP_ARRAY_S);
var KECCAK256_RLP_S = "0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421";
var KECCAK256_RLP = hexToBytes4(KECCAK256_RLP_S);
var SHA256_NULL = sha2562(new Uint8Array());
var RLP_EMPTY_STRING = Uint8Array.from([128]);
var MAX_BLOCK_SIZE = 10485760;
var SAFETY_MARGIN = 2097152;
var MAX_RLP_BLOCK_SIZE = MAX_BLOCK_SIZE - SAFETY_MARGIN;
var BIGINT_NEG1 = BigInt(-1);
var BIGINT_02 = BigInt(0);
var BIGINT_1 = BigInt(1);
var BIGINT_2 = BigInt(2);
var BIGINT_3 = BigInt(3);
var BIGINT_7 = BigInt(7);
var BIGINT_8 = BigInt(8);
var BIGINT_27 = BigInt(27);
var BIGINT_28 = BigInt(28);
var BIGINT_31 = BigInt(31);
var BIGINT_32 = BigInt(32);
var BIGINT_64 = BigInt(64);
var BIGINT_128 = BigInt(128);
var BIGINT_255 = BigInt(255);
var BIGINT_256 = BigInt(256);
var BIGINT_96 = BigInt(96);
var BIGINT_100 = BigInt(100);
var BIGINT_160 = BigInt(160);
var BIGINT_224 = BigInt(224);
var BIGINT_2EXP96 = BigInt(7922816251426434e13);
var BIGINT_2EXP160 = BigInt(1461501637330903e33);
var BIGINT_2EXP224 = BigInt(2695994666715064e52);
var BIGINT_2EXP256 = BIGINT_2 ** BIGINT_256;

// node_modules/@ethereumjs/util/dist/esm/units.js
var GWEI_TO_WEI = BigInt(10 ** 9);
var ETHER_TO_WEI = BigInt(10 ** 18);

// node_modules/@noble/hashes/esm/sha3.js
var _0n6 = BigInt(0);
var _1n6 = BigInt(1);
var _2n4 = BigInt(2);
var _7n = BigInt(7);
var _256n = BigInt(256);
var _0x71n = BigInt(113);
var SHA3_PI = [];
var SHA3_ROTL = [];
var _SHA3_IOTA = [];
for (let round = 0, R = _1n6, x = 1, y = 0; round < 24; round++) {
  [x, y] = [y, (2 * x + 3 * y) % 5];
  SHA3_PI.push(2 * (5 * y + x));
  SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
  let t = _0n6;
  for (let j = 0; j < 7; j++) {
    R = (R << _1n6 ^ (R >> _7n) * _0x71n) % _256n;
    if (R & _2n4)
      t ^= _1n6 << (_1n6 << /* @__PURE__ */ BigInt(j)) - _1n6;
  }
  _SHA3_IOTA.push(t);
}
var IOTAS = split(_SHA3_IOTA, true);
var SHA3_IOTA_H = IOTAS[0];
var SHA3_IOTA_L = IOTAS[1];
var rotlH = (h, l, s) => s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s);
var rotlL = (h, l, s) => s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s);
function keccakP(s, rounds = 24) {
  const B = new Uint32Array(5 * 2);
  for (let round = 24 - rounds; round < 24; round++) {
    for (let x = 0; x < 10; x++)
      B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
    for (let x = 0; x < 10; x += 2) {
      const idx1 = (x + 8) % 10;
      const idx0 = (x + 2) % 10;
      const B0 = B[idx0];
      const B1 = B[idx0 + 1];
      const Th = rotlH(B0, B1, 1) ^ B[idx1];
      const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
      for (let y = 0; y < 50; y += 10) {
        s[x + y] ^= Th;
        s[x + y + 1] ^= Tl;
      }
    }
    let curH = s[2];
    let curL = s[3];
    for (let t = 0; t < 24; t++) {
      const shift = SHA3_ROTL[t];
      const Th = rotlH(curH, curL, shift);
      const Tl = rotlL(curH, curL, shift);
      const PI = SHA3_PI[t];
      curH = s[PI];
      curL = s[PI + 1];
      s[PI] = Th;
      s[PI + 1] = Tl;
    }
    for (let y = 0; y < 50; y += 10) {
      for (let x = 0; x < 10; x++)
        B[x] = s[y + x];
      for (let x = 0; x < 10; x++)
        s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
    }
    s[0] ^= SHA3_IOTA_H[round];
    s[1] ^= SHA3_IOTA_L[round];
  }
  clean(B);
}
var Keccak = class _Keccak extends Hash {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
    super();
    this.pos = 0;
    this.posOut = 0;
    this.finished = false;
    this.destroyed = false;
    this.enableXOF = false;
    this.blockLen = blockLen;
    this.suffix = suffix;
    this.outputLen = outputLen;
    this.enableXOF = enableXOF;
    this.rounds = rounds;
    anumber(outputLen);
    if (!(0 < blockLen && blockLen < 200))
      throw new Error("only keccak-f1600 function is supported");
    this.state = new Uint8Array(200);
    this.state32 = u32(this.state);
  }
  clone() {
    return this._cloneInto();
  }
  keccak() {
    swap32IfBE(this.state32);
    keccakP(this.state32, this.rounds);
    swap32IfBE(this.state32);
    this.posOut = 0;
    this.pos = 0;
  }
  update(data) {
    aexists(this);
    data = toBytes(data);
    abytes(data);
    const { blockLen, state } = this;
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      for (let i = 0; i < take; i++)
        state[this.pos++] ^= data[pos++];
      if (this.pos === blockLen)
        this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state, suffix, pos, blockLen } = this;
    state[pos] ^= suffix;
    if ((suffix & 128) !== 0 && pos === blockLen - 1)
      this.keccak();
    state[blockLen - 1] ^= 128;
    this.keccak();
  }
  writeInto(out) {
    aexists(this, false);
    abytes(out);
    this.finish();
    const bufferOut = this.state;
    const { blockLen } = this;
    for (let pos = 0, len = out.length; pos < len; ) {
      if (this.posOut >= blockLen)
        this.keccak();
      const take = Math.min(blockLen - this.posOut, len - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
      this.posOut += take;
      pos += take;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(out);
  }
  xof(bytes) {
    anumber(bytes);
    return this.xofInto(new Uint8Array(bytes));
  }
  digestInto(out) {
    aoutput(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true;
    clean(this.state);
  }
  _cloneInto(to) {
    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
    to || (to = new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
    to.state32.set(this.state32);
    to.pos = this.pos;
    to.posOut = this.posOut;
    to.finished = this.finished;
    to.rounds = rounds;
    to.suffix = suffix;
    to.outputLen = outputLen;
    to.enableXOF = enableXOF;
    to.destroyed = this.destroyed;
    return to;
  }
};
var gen = (suffix, blockLen, outputLen) => createHasher(() => new Keccak(blockLen, suffix, outputLen));
var keccak_224 = /* @__PURE__ */ (() => gen(1, 144, 224 / 8))();
var keccak_256 = /* @__PURE__ */ (() => gen(1, 136, 256 / 8))();
var keccak_384 = /* @__PURE__ */ (() => gen(1, 104, 384 / 8))();
var keccak_512 = /* @__PURE__ */ (() => gen(1, 72, 512 / 8))();

// node_modules/ethereum-cryptography/esm/keccak.js
var keccak224 = wrapHash(keccak_224);
var keccak256 = (() => {
  const k = wrapHash(keccak_256);
  k.create = keccak_256.create;
  return k;
})();
var keccak384 = wrapHash(keccak_384);
var keccak512 = wrapHash(keccak_512);

// node_modules/@ethereumjs/util/dist/esm/account.js
var toChecksumAddress = function(hexAddress, eip1191ChainId) {
  assertIsHexString(hexAddress);
  const address = stripHexPrefix(hexAddress).toLowerCase();
  let prefix = "";
  if (eip1191ChainId !== void 0) {
    const chainId = bytesToBigInt(toBytes2(eip1191ChainId));
    prefix = chainId.toString() + "0x";
  }
  const bytes = utf8ToBytes(prefix + address);
  const hash = bytesToHex3(keccak256(bytes)).slice(2);
  let ret = "";
  for (let i = 0; i < address.length; i++) {
    if (parseInt(hash[i], 16) >= 8) {
      ret += address[i].toUpperCase();
    } else {
      ret += address[i];
    }
  }
  return `0x${ret}`;
};
var isValidPrivate = function(privateKey) {
  return secp256k1.utils.isValidPrivateKey(privateKey);
};
var isValidPublic = function(publicKey, sanitize = false) {
  assertIsBytes(publicKey);
  if (publicKey.length === 64) {
    try {
      secp256k1.ProjectivePoint.fromHex(concatBytes3(Uint8Array.from([4]), publicKey));
      return true;
    } catch {
      return false;
    }
  }
  if (!sanitize) {
    return false;
  }
  try {
    secp256k1.ProjectivePoint.fromHex(publicKey);
    return true;
  } catch {
    return false;
  }
};
var pubToAddress = function(pubKey, sanitize = false) {
  assertIsBytes(pubKey);
  if (sanitize && pubKey.length !== 64) {
    pubKey = secp256k1.ProjectivePoint.fromHex(pubKey).toRawBytes(false).slice(1);
  }
  if (pubKey.length !== 64) {
    throw EthereumJSErrorWithoutCode("Expected pubKey to be of length 64");
  }
  return keccak256(pubKey).subarray(-20);
};
var publicToAddress = pubToAddress;
var privateToPublic = function(privateKey) {
  assertIsBytes(privateKey);
  return secp256k1.ProjectivePoint.fromPrivateKey(privateKey).toRawBytes(false).slice(1);
};
var privateToAddress = function(privateKey) {
  return publicToAddress(privateToPublic(privateKey));
};
var importPublic = function(publicKey) {
  assertIsBytes(publicKey);
  if (publicKey.length !== 64) {
    publicKey = secp256k1.ProjectivePoint.fromHex(publicKey).toRawBytes(false).slice(1);
  }
  return publicKey;
};
var emptyUint8Arr = new Uint8Array(0);

// node_modules/@ethereumjs/util/dist/esm/authorization.js
var EOA_CODE_7702_AUTHORITY_SIGNING_MAGIC = hexToBytes4("0x05");

// node_modules/@ethereumjs/util/dist/esm/binaryTree.js
var BinaryTreeLeafType = {
  BasicData: 0,
  CodeHash: 1
};
var BINARY_TREE_BASIC_DATA_LEAF_KEY = intToBytes(BinaryTreeLeafType.BasicData);
var BINARY_TREE_CODE_HASH_LEAF_KEY = intToBytes(BinaryTreeLeafType.CodeHash);
var BINARY_TREE_CODE_CHUNK_SIZE = 31;
var BINARY_TREE_MAIN_STORAGE_OFFSET = BigInt(256) ** BigInt(BINARY_TREE_CODE_CHUNK_SIZE);

// node_modules/@ethereumjs/util/dist/esm/blobs.js
var BYTES_PER_FIELD_ELEMENT = 32;
var FIELD_ELEMENTS_PER_BLOB = 4096;
var BLOB_SIZE = BYTES_PER_FIELD_ELEMENT * FIELD_ELEMENTS_PER_BLOB;
var MAX_BLOBS_PER_TX = 6;
var MAX_BLOB_BYTES_PER_TX = BLOB_SIZE * MAX_BLOBS_PER_TX - 1;

// node_modules/@noble/ciphers/esm/utils.js
function isBytes4(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function abytes4(b, ...lengths) {
  if (!isBytes4(b))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
}
function u8(arr) {
  return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
}
function u322(arr) {
  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
}
function clean2(...arrays) {
  for (let i = 0; i < arrays.length; i++) {
    arrays[i].fill(0);
  }
}
var isLE2 = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
function overlapBytes(a, b) {
  return a.buffer === b.buffer && // best we can do, may fail with an obscure Proxy
  a.byteOffset < b.byteOffset + b.byteLength && // a starts before b end
  b.byteOffset < a.byteOffset + a.byteLength;
}
function complexOverlapBytes(input, output) {
  if (overlapBytes(input, output) && input.byteOffset < output.byteOffset)
    throw new Error("complex overlap of input and output is not supported");
}
var wrapCipher = /* @__NO_SIDE_EFFECTS__ */ (params, constructor) => {
  function wrappedCipher(key, ...args) {
    abytes4(key);
    if (!isLE2)
      throw new Error("Non little-endian hardware is not yet supported");
    if (params.nonceLength !== void 0) {
      const nonce = args[0];
      if (!nonce)
        throw new Error("nonce / iv required");
      if (params.varSizeNonce)
        abytes4(nonce);
      else
        abytes4(nonce, params.nonceLength);
    }
    const tagl = params.tagLength;
    if (tagl && args[1] !== void 0) {
      abytes4(args[1]);
    }
    const cipher = constructor(key, ...args);
    const checkOutput = (fnLength, output) => {
      if (output !== void 0) {
        if (fnLength !== 2)
          throw new Error("cipher output not supported");
        abytes4(output);
      }
    };
    let called = false;
    const wrCipher = {
      encrypt(data, output) {
        if (called)
          throw new Error("cannot encrypt() twice with same key + nonce");
        called = true;
        abytes4(data);
        checkOutput(cipher.encrypt.length, output);
        return cipher.encrypt(data, output);
      },
      decrypt(data, output) {
        abytes4(data);
        if (tagl && data.length < tagl)
          throw new Error("invalid ciphertext length: smaller than tagLength=" + tagl);
        checkOutput(cipher.decrypt.length, output);
        return cipher.decrypt(data, output);
      }
    };
    return wrCipher;
  }
  Object.assign(wrappedCipher, params);
  return wrappedCipher;
};
function getOutput(expectedLength, out, onlyAligned = true) {
  if (out === void 0)
    return new Uint8Array(expectedLength);
  if (out.length !== expectedLength)
    throw new Error("invalid output length, expected " + expectedLength + ", got: " + out.length);
  if (onlyAligned && !isAligned32(out))
    throw new Error("invalid output, must be aligned");
  return out;
}
function isAligned32(bytes) {
  return bytes.byteOffset % 4 === 0;
}
function copyBytes(bytes) {
  return Uint8Array.from(bytes);
}

// node_modules/@noble/ciphers/esm/aes.js
var BLOCK_SIZE = 16;
var BLOCK_SIZE32 = 4;
var POLY = 283;
function mul2(n) {
  return n << 1 ^ POLY & -(n >> 7);
}
function mul(a, b) {
  let res = 0;
  for (; b > 0; b >>= 1) {
    res ^= a & -(b & 1);
    a = mul2(a);
  }
  return res;
}
var sbox = /* @__PURE__ */ (() => {
  const t = new Uint8Array(256);
  for (let i = 0, x = 1; i < 256; i++, x ^= mul2(x))
    t[i] = x;
  const box = new Uint8Array(256);
  box[0] = 99;
  for (let i = 0; i < 255; i++) {
    let x = t[255 - i];
    x |= x << 8;
    box[t[i]] = (x ^ x >> 4 ^ x >> 5 ^ x >> 6 ^ x >> 7 ^ 99) & 255;
  }
  clean2(t);
  return box;
})();
var invSbox = /* @__PURE__ */ sbox.map((_, j) => sbox.indexOf(j));
var rotr32_8 = (n) => n << 24 | n >>> 8;
var rotl32_8 = (n) => n << 8 | n >>> 24;
function genTtable(sbox2, fn) {
  if (sbox2.length !== 256)
    throw new Error("Wrong sbox length");
  const T0 = new Uint32Array(256).map((_, j) => fn(sbox2[j]));
  const T1 = T0.map(rotl32_8);
  const T2 = T1.map(rotl32_8);
  const T3 = T2.map(rotl32_8);
  const T01 = new Uint32Array(256 * 256);
  const T23 = new Uint32Array(256 * 256);
  const sbox22 = new Uint16Array(256 * 256);
  for (let i = 0; i < 256; i++) {
    for (let j = 0; j < 256; j++) {
      const idx = i * 256 + j;
      T01[idx] = T0[i] ^ T1[j];
      T23[idx] = T2[i] ^ T3[j];
      sbox22[idx] = sbox2[i] << 8 | sbox2[j];
    }
  }
  return { sbox: sbox2, sbox2: sbox22, T0, T1, T2, T3, T01, T23 };
}
var tableEncoding = /* @__PURE__ */ genTtable(sbox, (s) => mul(s, 3) << 24 | s << 16 | s << 8 | mul(s, 2));
var tableDecoding = /* @__PURE__ */ genTtable(invSbox, (s) => mul(s, 11) << 24 | mul(s, 13) << 16 | mul(s, 9) << 8 | mul(s, 14));
var xPowers = /* @__PURE__ */ (() => {
  const p = new Uint8Array(16);
  for (let i = 0, x = 1; i < 16; i++, x = mul2(x))
    p[i] = x;
  return p;
})();
function expandKeyLE(key) {
  abytes4(key);
  const len = key.length;
  if (![16, 24, 32].includes(len))
    throw new Error("aes: invalid key size, should be 16, 24 or 32, got " + len);
  const { sbox2 } = tableEncoding;
  const toClean = [];
  if (!isAligned32(key))
    toClean.push(key = copyBytes(key));
  const k32 = u322(key);
  const Nk = k32.length;
  const subByte = (n) => applySbox(sbox2, n, n, n, n);
  const xk = new Uint32Array(len + 28);
  xk.set(k32);
  for (let i = Nk; i < xk.length; i++) {
    let t = xk[i - 1];
    if (i % Nk === 0)
      t = subByte(rotr32_8(t)) ^ xPowers[i / Nk - 1];
    else if (Nk > 6 && i % Nk === 4)
      t = subByte(t);
    xk[i] = xk[i - Nk] ^ t;
  }
  clean2(...toClean);
  return xk;
}
function expandKeyDecLE(key) {
  const encKey = expandKeyLE(key);
  const xk = encKey.slice();
  const Nk = encKey.length;
  const { sbox2 } = tableEncoding;
  const { T0, T1, T2, T3 } = tableDecoding;
  for (let i = 0; i < Nk; i += 4) {
    for (let j = 0; j < 4; j++)
      xk[i + j] = encKey[Nk - i - 4 + j];
  }
  clean2(encKey);
  for (let i = 4; i < Nk - 4; i++) {
    const x = xk[i];
    const w = applySbox(sbox2, x, x, x, x);
    xk[i] = T0[w & 255] ^ T1[w >>> 8 & 255] ^ T2[w >>> 16 & 255] ^ T3[w >>> 24];
  }
  return xk;
}
function apply0123(T01, T23, s0, s1, s2, s3) {
  return T01[s0 << 8 & 65280 | s1 >>> 8 & 255] ^ T23[s2 >>> 8 & 65280 | s3 >>> 24 & 255];
}
function applySbox(sbox2, s0, s1, s2, s3) {
  return sbox2[s0 & 255 | s1 & 65280] | sbox2[s2 >>> 16 & 255 | s3 >>> 16 & 65280] << 16;
}
function encrypt(xk, s0, s1, s2, s3) {
  const { sbox2, T01, T23 } = tableEncoding;
  let k = 0;
  s0 ^= xk[k++], s1 ^= xk[k++], s2 ^= xk[k++], s3 ^= xk[k++];
  const rounds = xk.length / 4 - 2;
  for (let i = 0; i < rounds; i++) {
    const t02 = xk[k++] ^ apply0123(T01, T23, s0, s1, s2, s3);
    const t12 = xk[k++] ^ apply0123(T01, T23, s1, s2, s3, s0);
    const t22 = xk[k++] ^ apply0123(T01, T23, s2, s3, s0, s1);
    const t32 = xk[k++] ^ apply0123(T01, T23, s3, s0, s1, s2);
    s0 = t02, s1 = t12, s2 = t22, s3 = t32;
  }
  const t0 = xk[k++] ^ applySbox(sbox2, s0, s1, s2, s3);
  const t1 = xk[k++] ^ applySbox(sbox2, s1, s2, s3, s0);
  const t2 = xk[k++] ^ applySbox(sbox2, s2, s3, s0, s1);
  const t3 = xk[k++] ^ applySbox(sbox2, s3, s0, s1, s2);
  return { s0: t0, s1: t1, s2: t2, s3: t3 };
}
function decrypt(xk, s0, s1, s2, s3) {
  const { sbox2, T01, T23 } = tableDecoding;
  let k = 0;
  s0 ^= xk[k++], s1 ^= xk[k++], s2 ^= xk[k++], s3 ^= xk[k++];
  const rounds = xk.length / 4 - 2;
  for (let i = 0; i < rounds; i++) {
    const t02 = xk[k++] ^ apply0123(T01, T23, s0, s3, s2, s1);
    const t12 = xk[k++] ^ apply0123(T01, T23, s1, s0, s3, s2);
    const t22 = xk[k++] ^ apply0123(T01, T23, s2, s1, s0, s3);
    const t32 = xk[k++] ^ apply0123(T01, T23, s3, s2, s1, s0);
    s0 = t02, s1 = t12, s2 = t22, s3 = t32;
  }
  const t0 = xk[k++] ^ applySbox(sbox2, s0, s3, s2, s1);
  const t1 = xk[k++] ^ applySbox(sbox2, s1, s0, s3, s2);
  const t2 = xk[k++] ^ applySbox(sbox2, s2, s1, s0, s3);
  const t3 = xk[k++] ^ applySbox(sbox2, s3, s2, s1, s0);
  return { s0: t0, s1: t1, s2: t2, s3: t3 };
}
function ctrCounter(xk, nonce, src12, dst) {
  abytes4(nonce, BLOCK_SIZE);
  abytes4(src12);
  const srcLen = src12.length;
  dst = getOutput(srcLen, dst);
  complexOverlapBytes(src12, dst);
  const ctr2 = nonce;
  const c32 = u322(ctr2);
  let { s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]);
  const src32 = u322(src12);
  const dst32 = u322(dst);
  for (let i = 0; i + 4 <= src32.length; i += 4) {
    dst32[i + 0] = src32[i + 0] ^ s0;
    dst32[i + 1] = src32[i + 1] ^ s1;
    dst32[i + 2] = src32[i + 2] ^ s2;
    dst32[i + 3] = src32[i + 3] ^ s3;
    let carry = 1;
    for (let i2 = ctr2.length - 1; i2 >= 0; i2--) {
      carry = carry + (ctr2[i2] & 255) | 0;
      ctr2[i2] = carry & 255;
      carry >>>= 8;
    }
    ({ s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]));
  }
  const start = BLOCK_SIZE * Math.floor(src32.length / BLOCK_SIZE32);
  if (start < srcLen) {
    const b32 = new Uint32Array([s0, s1, s2, s3]);
    const buf2 = u8(b32);
    for (let i = start, pos = 0; i < srcLen; i++, pos++)
      dst[i] = src12[i] ^ buf2[pos];
    clean2(b32);
  }
  return dst;
}
var ctr = /* @__PURE__ */ wrapCipher({ blockSize: 16, nonceLength: 16 }, function aesctr(key, nonce) {
  function processCtr(buf2, dst) {
    abytes4(buf2);
    if (dst !== void 0) {
      abytes4(dst);
      if (!isAligned32(dst))
        throw new Error("unaligned destination");
    }
    const xk = expandKeyLE(key);
    const n = copyBytes(nonce);
    const toClean = [xk, n];
    if (!isAligned32(buf2))
      toClean.push(buf2 = copyBytes(buf2));
    const out = ctrCounter(xk, n, buf2, dst);
    clean2(...toClean);
    return out;
  }
  return {
    encrypt: (plaintext, dst) => processCtr(plaintext, dst),
    decrypt: (ciphertext, dst) => processCtr(ciphertext, dst)
  };
});
function validateBlockDecrypt(data) {
  abytes4(data);
  if (data.length % BLOCK_SIZE !== 0) {
    throw new Error("aes-(cbc/ecb).decrypt ciphertext should consist of blocks with size " + BLOCK_SIZE);
  }
}
function validateBlockEncrypt(plaintext, pcks5, dst) {
  abytes4(plaintext);
  let outLen = plaintext.length;
  const remaining = outLen % BLOCK_SIZE;
  if (!pcks5 && remaining !== 0)
    throw new Error("aec/(cbc-ecb): unpadded plaintext with disabled padding");
  if (!isAligned32(plaintext))
    plaintext = copyBytes(plaintext);
  const b = u322(plaintext);
  if (pcks5) {
    let left = BLOCK_SIZE - remaining;
    if (!left)
      left = BLOCK_SIZE;
    outLen = outLen + left;
  }
  dst = getOutput(outLen, dst);
  complexOverlapBytes(plaintext, dst);
  const o = u322(dst);
  return { b, o, out: dst };
}
function validatePCKS(data, pcks5) {
  if (!pcks5)
    return data;
  const len = data.length;
  if (!len)
    throw new Error("aes/pcks5: empty ciphertext not allowed");
  const lastByte = data[len - 1];
  if (lastByte <= 0 || lastByte > 16)
    throw new Error("aes/pcks5: wrong padding");
  const out = data.subarray(0, -lastByte);
  for (let i = 0; i < lastByte; i++)
    if (data[len - i - 1] !== lastByte)
      throw new Error("aes/pcks5: wrong padding");
  return out;
}
function padPCKS(left) {
  const tmp = new Uint8Array(16);
  const tmp32 = u322(tmp);
  tmp.set(left);
  const paddingByte = BLOCK_SIZE - left.length;
  for (let i = BLOCK_SIZE - paddingByte; i < BLOCK_SIZE; i++)
    tmp[i] = paddingByte;
  return tmp32;
}
var cbc = /* @__PURE__ */ wrapCipher({ blockSize: 16, nonceLength: 16 }, function aescbc(key, iv, opts = {}) {
  const pcks5 = !opts.disablePadding;
  return {
    encrypt(plaintext, dst) {
      const xk = expandKeyLE(key);
      const { b, o, out: _out } = validateBlockEncrypt(plaintext, pcks5, dst);
      let _iv = iv;
      const toClean = [xk];
      if (!isAligned32(_iv))
        toClean.push(_iv = copyBytes(_iv));
      const n32 = u322(_iv);
      let s0 = n32[0], s1 = n32[1], s2 = n32[2], s3 = n32[3];
      let i = 0;
      for (; i + 4 <= b.length; ) {
        s0 ^= b[i + 0], s1 ^= b[i + 1], s2 ^= b[i + 2], s3 ^= b[i + 3];
        ({ s0, s1, s2, s3 } = encrypt(xk, s0, s1, s2, s3));
        o[i++] = s0, o[i++] = s1, o[i++] = s2, o[i++] = s3;
      }
      if (pcks5) {
        const tmp32 = padPCKS(plaintext.subarray(i * 4));
        s0 ^= tmp32[0], s1 ^= tmp32[1], s2 ^= tmp32[2], s3 ^= tmp32[3];
        ({ s0, s1, s2, s3 } = encrypt(xk, s0, s1, s2, s3));
        o[i++] = s0, o[i++] = s1, o[i++] = s2, o[i++] = s3;
      }
      clean2(...toClean);
      return _out;
    },
    decrypt(ciphertext, dst) {
      validateBlockDecrypt(ciphertext);
      const xk = expandKeyDecLE(key);
      let _iv = iv;
      const toClean = [xk];
      if (!isAligned32(_iv))
        toClean.push(_iv = copyBytes(_iv));
      const n32 = u322(_iv);
      dst = getOutput(ciphertext.length, dst);
      if (!isAligned32(ciphertext))
        toClean.push(ciphertext = copyBytes(ciphertext));
      complexOverlapBytes(ciphertext, dst);
      const b = u322(ciphertext);
      const o = u322(dst);
      let s0 = n32[0], s1 = n32[1], s2 = n32[2], s3 = n32[3];
      for (let i = 0; i + 4 <= b.length; ) {
        const ps0 = s0, ps1 = s1, ps2 = s2, ps3 = s3;
        s0 = b[i + 0], s1 = b[i + 1], s2 = b[i + 2], s3 = b[i + 3];
        const { s0: o0, s1: o1, s2: o2, s3: o3 } = decrypt(xk, s0, s1, s2, s3);
        o[i++] = o0 ^ ps0, o[i++] = o1 ^ ps1, o[i++] = o2 ^ ps2, o[i++] = o3 ^ ps3;
      }
      clean2(...toClean);
      return validatePCKS(dst, pcks5);
    }
  };
});

// node_modules/ethereum-cryptography/esm/aes.js
function getCipher(key, iv, mode, pkcs7PaddingEnabled = true) {
  if (!mode.startsWith("aes-")) {
    throw new Error("AES: unsupported mode");
  }
  const len = key.length;
  if (mode.startsWith("aes-128") && len !== 16 || mode.startsWith("aes-256") && len !== 32) {
    throw new Error("AES: wrong key length");
  }
  if (iv.length !== 16) {
    throw new Error("AES: wrong IV length");
  }
  if (["aes-128-cbc", "aes-256-cbc"].includes(mode)) {
    return cbc(key, iv, { disablePadding: !pkcs7PaddingEnabled });
  }
  if (["aes-128-ctr", "aes-256-ctr"].includes(mode)) {
    return ctr(key, iv);
  }
  throw new Error("AES: unsupported mode");
}
function encrypt2(msg, key, iv, mode = "aes-128-ctr", pkcs7PaddingEnabled = true) {
  return getCipher(key, iv, mode, pkcs7PaddingEnabled).encrypt(msg);
}
function decrypt2(ciphertext, key, iv, mode = "aes-128-ctr", pkcs7PaddingEnabled = true) {
  return getCipher(key, iv, mode, pkcs7PaddingEnabled).decrypt(ciphertext);
}

// node_modules/ethereum-cryptography/esm/pbkdf2.js
async function pbkdf22(password, salt, iterations, keylen, digest6) {
  if (!["sha256", "sha512"].includes(digest6)) {
    throw new Error("Only sha256 and sha512 are supported");
  }
  abytes3(password);
  abytes3(salt);
  return pbkdf2Async(digest6 === "sha256" ? sha256 : sha512, password, salt, {
    c: iterations,
    dkLen: keylen
  });
}

// node_modules/@noble/hashes/esm/scrypt.js
function XorAndSalsa(prev, pi, input, ii, out, oi) {
  let y00 = prev[pi++] ^ input[ii++], y01 = prev[pi++] ^ input[ii++];
  let y02 = prev[pi++] ^ input[ii++], y03 = prev[pi++] ^ input[ii++];
  let y04 = prev[pi++] ^ input[ii++], y05 = prev[pi++] ^ input[ii++];
  let y06 = prev[pi++] ^ input[ii++], y07 = prev[pi++] ^ input[ii++];
  let y08 = prev[pi++] ^ input[ii++], y09 = prev[pi++] ^ input[ii++];
  let y10 = prev[pi++] ^ input[ii++], y11 = prev[pi++] ^ input[ii++];
  let y12 = prev[pi++] ^ input[ii++], y13 = prev[pi++] ^ input[ii++];
  let y14 = prev[pi++] ^ input[ii++], y15 = prev[pi++] ^ input[ii++];
  let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
  for (let i = 0; i < 8; i += 2) {
    x04 ^= rotl(x00 + x12 | 0, 7);
    x08 ^= rotl(x04 + x00 | 0, 9);
    x12 ^= rotl(x08 + x04 | 0, 13);
    x00 ^= rotl(x12 + x08 | 0, 18);
    x09 ^= rotl(x05 + x01 | 0, 7);
    x13 ^= rotl(x09 + x05 | 0, 9);
    x01 ^= rotl(x13 + x09 | 0, 13);
    x05 ^= rotl(x01 + x13 | 0, 18);
    x14 ^= rotl(x10 + x06 | 0, 7);
    x02 ^= rotl(x14 + x10 | 0, 9);
    x06 ^= rotl(x02 + x14 | 0, 13);
    x10 ^= rotl(x06 + x02 | 0, 18);
    x03 ^= rotl(x15 + x11 | 0, 7);
    x07 ^= rotl(x03 + x15 | 0, 9);
    x11 ^= rotl(x07 + x03 | 0, 13);
    x15 ^= rotl(x11 + x07 | 0, 18);
    x01 ^= rotl(x00 + x03 | 0, 7);
    x02 ^= rotl(x01 + x00 | 0, 9);
    x03 ^= rotl(x02 + x01 | 0, 13);
    x00 ^= rotl(x03 + x02 | 0, 18);
    x06 ^= rotl(x05 + x04 | 0, 7);
    x07 ^= rotl(x06 + x05 | 0, 9);
    x04 ^= rotl(x07 + x06 | 0, 13);
    x05 ^= rotl(x04 + x07 | 0, 18);
    x11 ^= rotl(x10 + x09 | 0, 7);
    x08 ^= rotl(x11 + x10 | 0, 9);
    x09 ^= rotl(x08 + x11 | 0, 13);
    x10 ^= rotl(x09 + x08 | 0, 18);
    x12 ^= rotl(x15 + x14 | 0, 7);
    x13 ^= rotl(x12 + x15 | 0, 9);
    x14 ^= rotl(x13 + x12 | 0, 13);
    x15 ^= rotl(x14 + x13 | 0, 18);
  }
  out[oi++] = y00 + x00 | 0;
  out[oi++] = y01 + x01 | 0;
  out[oi++] = y02 + x02 | 0;
  out[oi++] = y03 + x03 | 0;
  out[oi++] = y04 + x04 | 0;
  out[oi++] = y05 + x05 | 0;
  out[oi++] = y06 + x06 | 0;
  out[oi++] = y07 + x07 | 0;
  out[oi++] = y08 + x08 | 0;
  out[oi++] = y09 + x09 | 0;
  out[oi++] = y10 + x10 | 0;
  out[oi++] = y11 + x11 | 0;
  out[oi++] = y12 + x12 | 0;
  out[oi++] = y13 + x13 | 0;
  out[oi++] = y14 + x14 | 0;
  out[oi++] = y15 + x15 | 0;
}
function BlockMix(input, ii, out, oi, r) {
  let head = oi + 0;
  let tail = oi + 16 * r;
  for (let i = 0; i < 16; i++)
    out[tail + i] = input[ii + (2 * r - 1) * 16 + i];
  for (let i = 0; i < r; i++, head += 16, ii += 16) {
    XorAndSalsa(out, tail, input, ii, out, head);
    if (i > 0)
      tail += 16;
    XorAndSalsa(out, head, input, ii += 16, out, tail);
  }
}
function scryptInit(password, salt, _opts) {
  const opts = checkOpts({
    dkLen: 32,
    asyncTick: 10,
    maxmem: 1024 ** 3 + 1024
  }, _opts);
  const { N, r, p, dkLen, asyncTick, maxmem, onProgress } = opts;
  anumber(N);
  anumber(r);
  anumber(p);
  anumber(dkLen);
  anumber(asyncTick);
  anumber(maxmem);
  if (onProgress !== void 0 && typeof onProgress !== "function")
    throw new Error("progressCb should be function");
  const blockSize = 128 * r;
  const blockSize32 = blockSize / 4;
  const pow32 = Math.pow(2, 32);
  if (N <= 1 || (N & N - 1) !== 0 || N > pow32) {
    throw new Error("Scrypt: N must be larger than 1, a power of 2, and less than 2^32");
  }
  if (p < 0 || p > (pow32 - 1) * 32 / blockSize) {
    throw new Error("Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)");
  }
  if (dkLen < 0 || dkLen > (pow32 - 1) * 32) {
    throw new Error("Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32");
  }
  const memUsed = blockSize * (N + p);
  if (memUsed > maxmem) {
    throw new Error("Scrypt: memused is bigger than maxMem. Expected 128 * r * (N + p) > maxmem of " + maxmem);
  }
  const B = pbkdf2(sha256, password, salt, { c: 1, dkLen: blockSize * p });
  const B32 = u32(B);
  const V3 = u32(new Uint8Array(blockSize * N));
  const tmp = u32(new Uint8Array(blockSize));
  let blockMixCb = () => {
  };
  if (onProgress) {
    const totalBlockMix = 2 * N * p;
    const callbackPer = Math.max(Math.floor(totalBlockMix / 1e4), 1);
    let blockMixCnt = 0;
    blockMixCb = () => {
      blockMixCnt++;
      if (onProgress && (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix))
        onProgress(blockMixCnt / totalBlockMix);
    };
  }
  return { N, r, p, dkLen, blockSize32, V: V3, B32, B, tmp, blockMixCb, asyncTick };
}
function scryptOutput(password, dkLen, B, V3, tmp) {
  const res = pbkdf2(sha256, password, B, { c: 1, dkLen });
  clean(B, V3, tmp);
  return res;
}
async function scryptAsync(password, salt, opts) {
  const { N, r, p, dkLen, blockSize32, V: V3, B32, B, tmp, blockMixCb, asyncTick } = scryptInit(password, salt, opts);
  swap32IfBE(B32);
  for (let pi = 0; pi < p; pi++) {
    const Pi = blockSize32 * pi;
    for (let i = 0; i < blockSize32; i++)
      V3[i] = B32[Pi + i];
    let pos = 0;
    await asyncLoop(N - 1, asyncTick, () => {
      BlockMix(V3, pos, V3, pos += blockSize32, r);
      blockMixCb();
    });
    BlockMix(V3, (N - 1) * blockSize32, B32, Pi, r);
    blockMixCb();
    await asyncLoop(N, asyncTick, () => {
      const j = B32[Pi + blockSize32 - 16] % N;
      for (let k = 0; k < blockSize32; k++)
        tmp[k] = B32[Pi + k] ^ V3[j * blockSize32 + k];
      BlockMix(tmp, 0, B32, Pi, r);
      blockMixCb();
    });
  }
  swap32IfBE(B32);
  return scryptOutput(password, dkLen, B, V3, tmp);
}

// node_modules/ethereum-cryptography/esm/scrypt.js
async function scrypt2(password, salt, n, p, r, dkLen, onProgress) {
  abytes3(password);
  abytes3(salt);
  return scryptAsync(password, salt, { N: n, r, p, dkLen, onProgress });
}

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}

// node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    if (typeof crypto === "undefined" || !crypto.getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
    getRandomValues = crypto.getRandomValues.bind(crypto);
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = { randomUUID };

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf2, offset) {
  if (native_default.randomUUID && !buf2 && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random ?? options.rng?.() ?? rng();
  if (rnds.length < 16) {
    throw new Error("Random bytes length must be >= 16");
  }
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf2) {
    offset = offset || 0;
    if (offset < 0 || offset + 16 > buf2.length) {
      throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);
    }
    for (let i = 0; i < 16; ++i) {
      buf2[offset + i] = rnds[i];
    }
    return buf2;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// node_modules/@ethereumjs/wallet/dist/esm/wallet.js
var bs58check = base58check(sha2562);
function scryptV1(password, salt, kdfparams) {
  const { N, P, R, DkLen } = kdfparams;
  return scrypt2(password, salt, N, P, R, DkLen);
}
function scryptV3(password, kdfparams) {
  const { salt, n, p, r, dklen } = kdfparams;
  return scrypt2(utf8ToBytes(password), salt, n, p, r, dklen);
}
function scryptV3Out(password, kdfparams) {
  const { salt, n, p, r, dklen } = kdfparams;
  return scrypt2(utf8ToBytes(password), unprefixedHexToBytes(salt), n, p, r, dklen);
}
function validateHexString(paramName, str, length11) {
  if (str.toLowerCase().startsWith("0x")) {
    str = str.slice(2);
  }
  if (!str && length11 === void 0) {
    return str;
  }
  if (length11 % 2) {
    throw EthereumJSErrorWithoutCode(`Invalid length argument, must be an even number`);
  }
  if (typeof length11 === "number" && str.length !== length11) {
    throw EthereumJSErrorWithoutCode(`Invalid ${paramName}, string must be ${length11} hex characters`);
  }
  if (!/^([0-9a-f]{2})+$/i.test(str)) {
    const howMany = typeof length11 === "number" ? length11 : "empty or a non-zero even number of";
    throw EthereumJSErrorWithoutCode(`Invalid ${paramName}, string must be ${howMany} hex characters`);
  }
  return str;
}
function validateBytes(paramName, bytes, length11) {
  if (!(bytes instanceof Uint8Array)) {
    const howManyHex = typeof length11 === "number" ? `${length11 * 2}` : "empty or a non-zero even number of";
    const howManyBytes = typeof length11 === "number" ? ` (${length11} bytes)` : "";
    throw EthereumJSErrorWithoutCode(`Invalid ${paramName}, must be a string (${howManyHex} hex characters) or Uint8Array${howManyBytes}`);
  }
  if (typeof length11 === "number" && bytes.length !== length11) {
    throw EthereumJSErrorWithoutCode(`Invalid ${paramName}, Uint8Array must be ${length11} bytes`);
  }
  return bytes;
}
function mergeToV3ParamsWithDefaults(params) {
  const v3Defaults = {
    cipher: "aes-128-ctr",
    kdf: "scrypt",
    salt: randomBytes2(32),
    iv: randomBytes2(16),
    uuid: randomBytes2(16),
    dklen: 32,
    c: 262144,
    n: 262144,
    r: 8,
    p: 1
  };
  if (!params) {
    return v3Defaults;
  }
  if (typeof params.salt === "string") {
    params.salt = unprefixedHexToBytes(validateHexString("salt", params.salt));
  }
  if (typeof params.iv === "string") {
    params.iv = unprefixedHexToBytes(validateHexString("iv", params.iv, 32));
  }
  if (typeof params.uuid === "string") {
    params.uuid = unprefixedHexToBytes(validateHexString("uuid", params.uuid, 32));
  }
  if (params.salt) {
    validateBytes("salt", params.salt);
  }
  if (params.iv) {
    validateBytes("iv", params.iv, 16);
  }
  if (params.uuid) {
    validateBytes("uuid", params.uuid, 16);
  }
  return {
    ...v3Defaults,
    ...params
  };
}
var KDFFunctions = {
  PBKDF: "pbkdf2",
  Scrypt: "scrypt"
};
function kdfParamsForPBKDF(opts) {
  return {
    dklen: opts.dklen,
    salt: opts.salt,
    c: opts.c,
    prf: "hmac-sha256"
  };
}
function kdfParamsForScrypt(opts) {
  return {
    dklen: opts.dklen,
    salt: opts.salt,
    n: opts.n,
    p: opts.p,
    r: opts.r
  };
}
var Wallet = class _Wallet {
  constructor(privateKey, publicKey) {
    this.privateKey = privateKey;
    this.publicKey = publicKey;
    if (privateKey && publicKey) {
      throw EthereumJSErrorWithoutCode("Cannot supply both a private and a public key to the constructor");
    }
    if (privateKey && !isValidPrivate(privateKey)) {
      throw EthereumJSErrorWithoutCode("Private key does not satisfy the curve requirements (ie. it is invalid)");
    }
    if (publicKey && !isValidPublic(publicKey)) {
      throw EthereumJSErrorWithoutCode("Invalid public key");
    }
  }
  // static methods
  /**
   * Create an instance based on a new random key.
   *
   * @param icapDirect setting this to `true` will generate an address suitable for the `ICAP Direct mode`
   */
  static generate(icapDirect = false) {
    if (icapDirect) {
      const max = BigInt("0x088f924eeceeda7fe92e1f5b0fffffffffffffff");
      for (; ; ) {
        const privateKey = randomBytes2(32);
        const hex = bytesToUnprefixedHex(privateToAddress(privateKey));
        if (BigInt("0x" + hex) <= max) {
          return new _Wallet(privateKey);
        }
      }
    } else {
      return new _Wallet(randomBytes2(32));
    }
  }
  /**
   * Create an instance where the address is valid against the supplied pattern (**this will be very slow**)
   */
  static generateVanityAddress(pattern) {
    if (!(pattern instanceof RegExp)) {
      pattern = new RegExp(pattern);
    }
    for (; ; ) {
      const privateKey = randomBytes2(32);
      const address = privateToAddress(privateKey);
      if (pattern.test(bytesToUnprefixedHex(address))) {
        return new _Wallet(privateKey);
      }
    }
  }
  /**
   * Create an instance based on a public key (certain methods will not be available)
   *
   * This method only accepts uncompressed Ethereum-style public keys, unless
   * the `nonStrict` flag is set to true.
   */
  static fromPublicKey(publicKey, nonStrict = false) {
    if (nonStrict) {
      publicKey = importPublic(publicKey);
    }
    return new _Wallet(void 0, publicKey);
  }
  /**
   * Create an instance based on a BIP32 extended public key (xpub)
   */
  static fromExtendedPublicKey(extendedPublicKey) {
    if (extendedPublicKey.slice(0, 4) !== "xpub") {
      throw EthereumJSErrorWithoutCode("Not an extended public key");
    }
    const publicKey = bs58check.decode(extendedPublicKey).subarray(45);
    return _Wallet.fromPublicKey(publicKey, true);
  }
  /**
   * Create an instance based on a raw private key
   */
  static fromPrivateKey(privateKey) {
    return new _Wallet(privateKey);
  }
  /**
   * Create an instance based on a BIP32 extended private key (xprv)
   */
  static fromExtendedPrivateKey(extendedPrivateKey) {
    if (extendedPrivateKey.slice(0, 4) !== "xprv") {
      throw EthereumJSErrorWithoutCode("Not an extended private key");
    }
    const tmp = bs58check.decode(extendedPrivateKey);
    if (tmp[45] !== 0) {
      throw EthereumJSErrorWithoutCode("Invalid extended private key");
    }
    return _Wallet.fromPrivateKey(tmp.subarray(46));
  }
  /**
   * Import a wallet (Version 1 of the Ethereum wallet format).
   *
   * @param input A JSON serialized string, or an object representing V1 Keystore.
   * @param password The keystore password.
   */
  static async fromV1(input, password) {
    const json = typeof input === "object" ? input : JSON.parse(input);
    if (json.Version !== "1") {
      throw EthereumJSErrorWithoutCode("Not a V1 Wallet");
    }
    if (json.Crypto.KeyHeader.Kdf !== "scrypt") {
      throw EthereumJSErrorWithoutCode("Unsupported key derivation scheme");
    }
    const kdfparams = json.Crypto.KeyHeader.KdfParams;
    const salt = unprefixedHexToBytes(json.Crypto.Salt);
    const derivedKey = await scryptV1(utf8ToBytes(password), salt, kdfparams);
    const ciphertext = unprefixedHexToBytes(json.Crypto.CipherText);
    const mac = keccak256(concatBytes3(derivedKey.subarray(16, 32), ciphertext));
    if (bytesToUnprefixedHex(mac) !== json.Crypto.MAC) {
      throw EthereumJSErrorWithoutCode("Key derivation failed - possibly wrong passphrase");
    }
    const seed = decrypt2(ciphertext, keccak256(derivedKey.subarray(0, 16)).subarray(0, 16), unprefixedHexToBytes(json.Crypto.IV), "aes-128-cbc");
    return new _Wallet(seed);
  }
  /**
   * Import a wallet (Version 3 of the Ethereum wallet format). Set `nonStrict` true to accept files with mixed-caps.
   *
   * @param input A JSON serialized string, or an object representing V3 Keystore.
   * @param password The keystore password.
   */
  static async fromV3(input, password, nonStrict = false) {
    const json = typeof input === "object" ? input : JSON.parse(nonStrict ? input.toLowerCase() : input);
    if (json.version !== 3) {
      throw EthereumJSErrorWithoutCode("Not a V3 wallet");
    }
    let derivedKey, kdfparams;
    if (json.crypto.kdf === "scrypt") {
      kdfparams = json.crypto.kdfparams;
      derivedKey = await scryptV3Out(password, kdfparams);
    } else if (json.crypto.kdf === "pbkdf2") {
      kdfparams = json.crypto.kdfparams;
      if (kdfparams.prf !== "hmac-sha256") {
        throw EthereumJSErrorWithoutCode("Unsupported parameters to PBKDF2");
      }
      derivedKey = await pbkdf22(utf8ToBytes(password), unprefixedHexToBytes(kdfparams.salt), kdfparams.c, kdfparams.dklen, "sha256");
    } else {
      throw EthereumJSErrorWithoutCode("Unsupported key derivation scheme");
    }
    const ciphertext = unprefixedHexToBytes(json.crypto.ciphertext);
    const mac = keccak256(concatBytes3(derivedKey.subarray(16, 32), ciphertext));
    if (bytesToUnprefixedHex(mac) !== json.crypto.mac) {
      throw EthereumJSErrorWithoutCode("Key derivation failed - possibly wrong passphrase");
    }
    const seed = decrypt2(ciphertext, derivedKey.subarray(0, 16), unprefixedHexToBytes(json.crypto.cipherparams.iv), json.crypto.cipher);
    return new _Wallet(seed);
  }
  /*
   * Import an Ethereum Pre Sale wallet.
   * Based on https://github.com/ethereum/pyethsaletool/blob/master/pyethsaletool.py
   * JSON fields: encseed, ethaddr, btcaddr, email
   *
   * @param input A JSON serialized string, or an object representing EthSale Keystore.
   * @param password The keystore password.
   */
  static async fromEthSale(input, password) {
    const json = typeof input === "object" ? input : JSON.parse(input);
    const encseed = unprefixedHexToBytes(json.encseed);
    const pass = utf8ToBytes(password);
    const derivedKey = (await pbkdf22(pass, pass, 2e3, 32, "sha256")).subarray(0, 16);
    const seed = decrypt2(encseed.subarray(16), derivedKey, encseed.subarray(0, 16), "aes-128-cbc", true);
    const wallet = new _Wallet(keccak256(seed));
    if (bytesToUnprefixedHex(wallet.getAddress()) !== json.ethaddr) {
      throw EthereumJSErrorWithoutCode("Decoded key mismatch - possibly wrong passphrase");
    }
    return wallet;
  }
  // private getters
  /**
   * Returns the wallet's public key.
   */
  get pubKey() {
    if (this.publicKey === void 0 || this.publicKey === null) {
      this.publicKey = privateToPublic(this.privateKey);
    }
    return this.publicKey;
  }
  /**
   * Returns the wallet's private key.
   */
  get privKey() {
    if (this.privateKey === void 0 || this.privateKey === null) {
      throw EthereumJSErrorWithoutCode("This is a public key only wallet");
    }
    return this.privateKey;
  }
  // public instance methods
  /**
   * Returns the wallet's private key.
   *
   */
  getPrivateKey() {
    return this.privKey;
  }
  getPrivateKeyString() {
    return bytesToHex3(this.privKey);
  }
  /**
   * Returns the wallet's public key.
   */
  getPublicKey() {
    return this.pubKey;
  }
  /**
   * Returns the wallet's public key as a "0x" prefixed hex string
   */
  getPublicKeyString() {
    return bytesToHex3(this.getPublicKey());
  }
  /**
   * Returns the wallet's address.
   */
  getAddress() {
    return publicToAddress(this.pubKey);
  }
  /**
   * Returns the wallet's address as a "0x" prefixed hex string
   */
  getAddressString() {
    return bytesToHex3(this.getAddress());
  }
  /**
   * Returns the wallet's private key as a "0x" prefixed hex string checksummed
   * according to [EIP 55](https://github.com/ethereum/EIPs/issues/55).
   */
  getChecksumAddressString() {
    return toChecksumAddress(this.getAddressString());
  }
  /**
   * Returns an Ethereum Version 3 Keystore Format object representing the wallet
   *
   * @param password The password used to encrypt the Keystore.
   * @param opts The options for the keystore. See [its spec](https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition) for more info.
   */
  async toV3(password, opts) {
    if (this.privateKey === void 0 || this.privateKey === null) {
      throw EthereumJSErrorWithoutCode("This is a public key only wallet");
    }
    const v3Params = mergeToV3ParamsWithDefaults(opts);
    let kdfParams;
    let derivedKey;
    switch (v3Params.kdf) {
      case KDFFunctions.PBKDF:
        kdfParams = kdfParamsForPBKDF(v3Params);
        derivedKey = await pbkdf22(utf8ToBytes(password), kdfParams.salt, kdfParams.c, kdfParams.dklen, "sha256");
        break;
      case KDFFunctions.Scrypt:
        kdfParams = kdfParamsForScrypt(v3Params);
        derivedKey = await scryptV3(password, kdfParams);
        break;
      default:
        throw EthereumJSErrorWithoutCode("Unsupported kdf");
    }
    const ciphertext = encrypt2(this.privKey, derivedKey.subarray(0, 16), v3Params.iv, v3Params.cipher, false);
    const mac = keccak256(concatBytes3(derivedKey.subarray(16, 32), ciphertext));
    return {
      version: 3,
      id: v4_default({ random: v3Params.uuid }),
      //@ts-expect-error - the official V3 keystore spec omits the address key
      address: bytesToUnprefixedHex(this.getAddress()),
      crypto: {
        ciphertext: bytesToUnprefixedHex(ciphertext),
        cipherparams: { iv: bytesToUnprefixedHex(v3Params.iv) },
        cipher: v3Params.cipher,
        kdf: v3Params.kdf,
        kdfparams: {
          ...kdfParams,
          salt: bytesToUnprefixedHex(kdfParams.salt)
        },
        mac: bytesToUnprefixedHex(mac)
      }
    };
  }
  /**
   * Return the suggested filename for V3 keystores.
   */
  getV3Filename(timestamp) {
    const ts = timestamp !== void 0 ? new Date(timestamp) : /* @__PURE__ */ new Date();
    return [
      "UTC--",
      ts.toJSON().replace(/:/g, "-"),
      "--",
      bytesToUnprefixedHex(this.getAddress())
    ].join("");
  }
  async toV3String(password, opts) {
    return JSON.stringify(await this.toV3(password, opts));
  }
  /**
   * Verify the publicKey, privateKey pair
   *
   * @param publicKey the public key to verify against the private key of the wallet
   */
  verifyPublicKey(publicKey) {
    if (this.privateKey === void 0)
      return false;
    return equalsBytes(privateToPublic(this.privateKey), publicKey);
  }
};

// node_modules/@ethereumjs/wallet/dist/esm/thirdparty.js
var import_js_md5 = __toESM(require_md5(), 1);

// src/core/wallet.ts
function createWallet() {
  const mnemonic = bip39.generateMnemonic();
  const seed = bip39.mnemonicToSeedSync(mnemonic);
  const wallet = Wallet.fromPrivateKey(seed.slice(0, 32));
  return {
    mnemonic,
    privateKey: wallet.getPrivateKeyString(),
    address: wallet.getAddressString()
  };
}

// node_modules/ipfs-core-utils/src/multibases.js
var LOAD_BASE = (name12) => Promise.reject(new Error(`No base found for "${name12}"`));
var Multibases = class {
  /**
   * @param {object} options
   * @param {LoadBaseFn} [options.loadBase]
   * @param {MultibaseCodec[]} options.bases
   */
  constructor(options) {
    this._basesByName = {};
    this._basesByPrefix = {};
    this._loadBase = options.loadBase || LOAD_BASE;
    for (const base14 of options.bases) {
      this.addBase(base14);
    }
  }
  /**
   * Add support for a multibase codec
   *
   * @param {MultibaseCodec} base
   */
  addBase(base14) {
    if (this._basesByName[base14.name] || this._basesByPrefix[base14.prefix]) {
      throw new Error(`Codec already exists for codec "${base14.name}"`);
    }
    this._basesByName[base14.name] = base14;
    this._basesByPrefix[base14.prefix] = base14;
  }
  /**
   * Remove support for a multibase codec
   *
   * @param {MultibaseCodec} base
   */
  removeBase(base14) {
    delete this._basesByName[base14.name];
    delete this._basesByPrefix[base14.prefix];
  }
  /**
   * @param {string} nameOrPrefix
   */
  async getBase(nameOrPrefix) {
    if (this._basesByName[nameOrPrefix]) {
      return this._basesByName[nameOrPrefix];
    }
    if (this._basesByPrefix[nameOrPrefix]) {
      return this._basesByPrefix[nameOrPrefix];
    }
    const base14 = await this._loadBase(nameOrPrefix);
    if (this._basesByName[base14.name] == null && this._basesByPrefix[base14.prefix] == null) {
      this.addBase(base14);
    }
    return base14;
  }
  listBases() {
    return Object.values(this._basesByName);
  }
};

// node_modules/ipfs-core-utils/src/multicodecs.js
var LOAD_CODEC = (codeOrName) => Promise.reject(new Error(`No codec found for "${codeOrName}"`));
var Multicodecs = class {
  /**
   * @param {object} options
   * @param {LoadCodecFn} [options.loadCodec]
   * @param {BlockCodec[]} options.codecs
   */
  constructor(options) {
    this._codecsByName = {};
    this._codecsByCode = {};
    this._loadCodec = options.loadCodec || LOAD_CODEC;
    for (const codec of options.codecs) {
      this.addCodec(codec);
    }
  }
  /**
   * Add support for a block codec
   *
   * @param {BlockCodec} codec
   */
  addCodec(codec) {
    if (this._codecsByName[codec.name] || this._codecsByCode[codec.code]) {
      throw new Error(`Resolver already exists for codec "${codec.name}"`);
    }
    this._codecsByName[codec.name] = codec;
    this._codecsByCode[codec.code] = codec;
  }
  /**
   * Remove support for a block codec
   *
   * @param {BlockCodec} codec
   */
  removeCodec(codec) {
    delete this._codecsByName[codec.name];
    delete this._codecsByCode[codec.code];
  }
  /**
   * @param {number | string} code
   */
  async getCodec(code12) {
    const table2 = typeof code12 === "string" ? this._codecsByName : this._codecsByCode;
    if (table2[code12]) {
      return table2[code12];
    }
    const codec = await this._loadCodec(code12);
    if (table2[code12] == null) {
      this.addCodec(codec);
    }
    return codec;
  }
  listCodecs() {
    return Object.values(this._codecsByName);
  }
};

// node_modules/ipfs-core-utils/src/multihashes.js
var LOAD_HASHER = (codeOrName) => Promise.reject(new Error(`No hasher found for "${codeOrName}"`));
var Multihashes = class {
  /**
   * @param {object} options
   * @param {LoadHasherFn} [options.loadHasher]
   * @param {MultihashHasher[]} options.hashers
   */
  constructor(options) {
    this._hashersByName = {};
    this._hashersByCode = {};
    this._loadHasher = options.loadHasher || LOAD_HASHER;
    for (const hasher of options.hashers) {
      this.addHasher(hasher);
    }
  }
  /**
   * Add support for a multibase hasher
   *
   * @param {MultihashHasher} hasher
   */
  addHasher(hasher) {
    if (this._hashersByName[hasher.name] || this._hashersByCode[hasher.code]) {
      throw new Error(`Resolver already exists for codec "${hasher.name}"`);
    }
    this._hashersByName[hasher.name] = hasher;
    this._hashersByCode[hasher.code] = hasher;
  }
  /**
   * Remove support for a multibase hasher
   *
   * @param {MultihashHasher} hasher
   */
  removeHasher(hasher) {
    delete this._hashersByName[hasher.name];
    delete this._hashersByCode[hasher.code];
  }
  /**
   * @param {number | string} code
   */
  async getHasher(code12) {
    const table2 = typeof code12 === "string" ? this._hashersByName : this._hashersByCode;
    if (table2[code12]) {
      return table2[code12];
    }
    const hasher = await this._loadHasher(code12);
    if (table2[code12] == null) {
      this.addHasher(hasher);
    }
    return hasher;
  }
  listHashers() {
    return Object.values(this._hashersByName);
  }
};

// node_modules/@ipld/dag-pb/src/index.js
var src_exports = {};
__export(src_exports, {
  code: () => code,
  createLink: () => createLink,
  createNode: () => createNode,
  decode: () => decode5,
  encode: () => encode3,
  name: () => name,
  prepare: () => prepare,
  validate: () => validate
});

// node_modules/@ipld/dag-pb/node_modules/multiformats/dist/src/bytes.js
var empty = new Uint8Array(0);
function equals(aa, bb) {
  if (aa === bb) {
    return true;
  }
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}
function coerce(o) {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array") {
    return o;
  }
  if (o instanceof ArrayBuffer) {
    return new Uint8Array(o);
  }
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}

// node_modules/@ipld/dag-pb/node_modules/multiformats/dist/src/vendor/base-x.js
function base(ALPHABET, name12) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode42(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length11 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length11) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length11 = i2;
      pbegin++;
    }
    var it2 = size - length11;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length11 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length11) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length11 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length11;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode58(string3) {
    var buffer2 = decodeUnsafe(string3);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name12} character`);
  }
  return {
    encode: encode42,
    decodeUnsafe,
    decode: decode58
  };
}
var src = base;
var _brrp__multiformats_scope_baseX = src;
var base_x_default = _brrp__multiformats_scope_baseX;

// node_modules/@ipld/dag-pb/node_modules/multiformats/dist/src/bases/base.js
var Encoder = class {
  name;
  prefix;
  baseEncode;
  constructor(name12, prefix, baseEncode) {
    this.name = name12;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes) {
    if (bytes instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder = class {
  name;
  prefix;
  baseDecode;
  prefixCodePoint;
  constructor(name12, prefix, baseDecode) {
    this.name = name12;
    this.prefix = prefix;
    const prefixCodePoint = prefix.codePointAt(0);
    if (prefixCodePoint === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefixCodePoint;
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or(this, decoder);
  }
};
var ComposedDecoder = class {
  decoders;
  constructor(decoders3) {
    this.decoders = decoders3;
  }
  or(decoder) {
    return or(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder != null) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
function or(left, right) {
  return new ComposedDecoder({
    ...left.decoders ?? { [left.prefix]: left },
    ...right.decoders ?? { [right.prefix]: right }
  });
}
var Codec = class {
  name;
  prefix;
  baseEncode;
  baseDecode;
  encoder;
  decoder;
  constructor(name12, prefix, baseEncode, baseDecode) {
    this.name = name12;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder(name12, prefix, baseEncode);
    this.decoder = new Decoder(name12, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
function from({ name: name12, prefix, encode: encode42, decode: decode58 }) {
  return new Codec(name12, prefix, encode42, decode58);
}
function baseX({ name: name12, prefix, alphabet: alphabet7 }) {
  const { encode: encode42, decode: decode58 } = base_x_default(alphabet7, name12);
  return from({
    prefix,
    name: name12,
    encode: encode42,
    decode: (text) => coerce(decode58(text))
  });
}
function decode(string3, alphabetIdx, bitsPerChar, name12) {
  let end = string3.length;
  while (string3[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = alphabetIdx[string3[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name12} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer2 >> bits;
    }
  }
  if (bits >= bitsPerChar || (255 & buffer2 << 8 - bits) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
function encode(data, alphabet7, bitsPerChar) {
  const pad = alphabet7[alphabet7.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer2 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer2 = buffer2 << 8 | data[i];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet7[mask & buffer2 >> bits];
    }
  }
  if (bits !== 0) {
    out += alphabet7[mask & buffer2 << bitsPerChar - bits];
  }
  if (pad) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
function createAlphabetIdx(alphabet7) {
  const alphabetIdx = {};
  for (let i = 0; i < alphabet7.length; ++i) {
    alphabetIdx[alphabet7[i]] = i;
  }
  return alphabetIdx;
}
function rfc4648({ name: name12, prefix, bitsPerChar, alphabet: alphabet7 }) {
  const alphabetIdx = createAlphabetIdx(alphabet7);
  return from({
    prefix,
    name: name12,
    encode(input) {
      return encode(input, alphabet7, bitsPerChar);
    },
    decode(input) {
      return decode(input, alphabetIdx, bitsPerChar, name12);
    }
  });
}

// node_modules/@ipld/dag-pb/node_modules/multiformats/dist/src/bases/base32.js
var base32 = rfc4648({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper = rfc4648({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad = rfc4648({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper = rfc4648({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex = rfc4648({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper = rfc4648({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad = rfc4648({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper = rfc4648({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z = rfc4648({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@ipld/dag-pb/node_modules/multiformats/dist/src/bases/base36.js
var base36 = baseX({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper = baseX({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/@ipld/dag-pb/node_modules/multiformats/dist/src/bases/base58.js
var base58btc = baseX({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr = baseX({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@ipld/dag-pb/node_modules/multiformats/dist/src/vendor/varint.js
var encode_1 = encode2;
var MSB = 128;
var REST = 127;
var MSBALL = ~REST;
var INT = Math.pow(2, 31);
function encode2(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT) {
    out[offset++] = num & 255 | MSB;
    num /= 128;
  }
  while (num & MSBALL) {
    out[offset++] = num & 255 | MSB;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode2.bytes = offset - oldOffset + 1;
  return out;
}
var decode2 = read;
var MSB$1 = 128;
var REST$1 = 127;
function read(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
  do {
    if (counter >= l) {
      read.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf2[counter++];
    res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$1);
  read.bytes = counter - offset;
  return res;
}
var N1 = Math.pow(2, 7);
var N2 = Math.pow(2, 14);
var N3 = Math.pow(2, 21);
var N4 = Math.pow(2, 28);
var N5 = Math.pow(2, 35);
var N6 = Math.pow(2, 42);
var N7 = Math.pow(2, 49);
var N8 = Math.pow(2, 56);
var N9 = Math.pow(2, 63);
var length = function(value) {
  return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
};
var varint = {
  encode: encode_1,
  decode: decode2,
  encodingLength: length
};
var _brrp_varint = varint;
var varint_default = _brrp_varint;

// node_modules/@ipld/dag-pb/node_modules/multiformats/dist/src/varint.js
function decode3(data, offset = 0) {
  const code12 = varint_default.decode(data, offset);
  return [code12, varint_default.decode.bytes];
}
function encodeTo(int, target, offset = 0) {
  varint_default.encode(int, target, offset);
  return target;
}
function encodingLength(int) {
  return varint_default.encodingLength(int);
}

// node_modules/@ipld/dag-pb/node_modules/multiformats/dist/src/hashes/digest.js
function create(code12, digest6) {
  const size = digest6.byteLength;
  const sizeOffset = encodingLength(code12);
  const digestOffset = sizeOffset + encodingLength(size);
  const bytes = new Uint8Array(digestOffset + size);
  encodeTo(code12, bytes, 0);
  encodeTo(size, bytes, sizeOffset);
  bytes.set(digest6, digestOffset);
  return new Digest(code12, size, digest6, bytes);
}
function decode4(multihash) {
  const bytes = coerce(multihash);
  const [code12, sizeOffset] = decode3(bytes);
  const [size, digestOffset] = decode3(bytes.subarray(sizeOffset));
  const digest6 = bytes.subarray(sizeOffset + digestOffset);
  if (digest6.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest(code12, size, digest6, bytes);
}
function equals2(a, b) {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals(a.bytes, data.bytes);
  }
}
var Digest = class {
  code;
  size;
  digest;
  bytes;
  /**
   * Creates a multihash digest.
   */
  constructor(code12, size, digest6, bytes) {
    this.code = code12;
    this.size = size;
    this.digest = digest6;
    this.bytes = bytes;
  }
};

// node_modules/@ipld/dag-pb/node_modules/multiformats/dist/src/cid.js
function format(link, base14) {
  const { bytes, version } = link;
  switch (version) {
    case 0:
      return toStringV0(bytes, baseCache(link), base14 ?? base58btc.encoder);
    default:
      return toStringV1(bytes, baseCache(link), base14 ?? base32.encoder);
  }
}
var cache = /* @__PURE__ */ new WeakMap();
function baseCache(cid) {
  const baseCache11 = cache.get(cid);
  if (baseCache11 == null) {
    const baseCache12 = /* @__PURE__ */ new Map();
    cache.set(cid, baseCache12);
    return baseCache12;
  }
  return baseCache11;
}
var CID = class _CID {
  code;
  version;
  multihash;
  bytes;
  "/";
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param multihash - (Multi)hash of the of the content.
   */
  constructor(version, code12, multihash, bytes) {
    this.code = code12;
    this.version = version;
    this.multihash = multihash;
    this.bytes = bytes;
    this["/"] = bytes;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code12, multihash } = this;
        if (code12 !== DAG_PB_CODE) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return _CID.createV0(multihash);
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code12, digest: digest6 } = this.multihash;
        const multihash = create(code12, digest6);
        return _CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return _CID.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals2(self2.multihash, unknown.multihash);
  }
  toString(base14) {
    return format(this, base14);
  }
  toJSON() {
    return { "/": format(this) };
  }
  link() {
    return this;
  }
  [Symbol.toStringTag] = "CID";
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value = input;
    if (value instanceof _CID) {
      return value;
    } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
      const { version, code: code12, multihash, bytes } = value;
      return new _CID(version, code12, multihash, bytes ?? encodeCID(version, code12, multihash.bytes));
    } else if (value[cidSymbol] === true) {
      const { version, multihash, code: code12 } = value;
      const digest6 = decode4(multihash);
      return _CID.create(version, code12, digest6);
    } else {
      return null;
    }
  }
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param digest - (Multi)hash of the of the content.
   */
  static create(version, code12, digest6) {
    if (typeof code12 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest6.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version) {
      case 0: {
        if (code12 !== DAG_PB_CODE) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
        } else {
          return new _CID(version, code12, digest6, digest6.bytes);
        }
      }
      case 1: {
        const bytes = encodeCID(version, code12, digest6.bytes);
        return new _CID(version, code12, digest6, bytes);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   */
  static createV0(digest6) {
    return _CID.create(0, DAG_PB_CODE, digest6);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @param code - Content encoding format code.
   * @param digest - Multihash of the content.
   */
  static createV1(code12, digest6) {
    return _CID.create(1, code12, digest6);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   */
  static decode(bytes) {
    const [cid, remainder] = _CID.decodeFirst(bytes);
    if (remainder.length !== 0) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   */
  static decodeFirst(bytes) {
    const specs = _CID.inspectBytes(bytes);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest6 = new Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? _CID.createV0(digest6) : _CID.createV1(specs.codec, digest6);
    return [cid, bytes.subarray(specs.size)];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i, length11] = decode3(initialBytes.subarray(offset));
      offset += length11;
      return i;
    };
    let version = next();
    let codec = DAG_PB_CODE;
    if (version === 18) {
      version = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version !== 0 && version !== 1) {
      throw new RangeError(`Invalid CID version ${version}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   */
  static parse(source, base14) {
    const [prefix, bytes] = parseCIDtoBytes(source, base14);
    const cid = _CID.decode(bytes);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache(cid).set(prefix, source);
    return cid;
  }
};
function parseCIDtoBytes(source, base14) {
  switch (source[0]) {
    // CIDv0 is parsed differently
    case "Q": {
      const decoder = base14 ?? base58btc;
      return [
        base58btc.prefix,
        decoder.decode(`${base58btc.prefix}${source}`)
      ];
    }
    case base58btc.prefix: {
      const decoder = base14 ?? base58btc;
      return [base58btc.prefix, decoder.decode(source)];
    }
    case base32.prefix: {
      const decoder = base14 ?? base32;
      return [base32.prefix, decoder.decode(source)];
    }
    case base36.prefix: {
      const decoder = base14 ?? base36;
      return [base36.prefix, decoder.decode(source)];
    }
    default: {
      if (base14 == null) {
        throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");
      }
      return [source[0], base14.decode(source)];
    }
  }
}
function toStringV0(bytes, cache11, base14) {
  const { prefix } = base14;
  if (prefix !== base58btc.prefix) {
    throw Error(`Cannot string encode V0 in ${base14.name} encoding`);
  }
  const cid = cache11.get(prefix);
  if (cid == null) {
    const cid2 = base14.encode(bytes).slice(1);
    cache11.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
function toStringV1(bytes, cache11, base14) {
  const { prefix } = base14;
  const cid = cache11.get(prefix);
  if (cid == null) {
    const cid2 = base14.encode(bytes);
    cache11.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
var DAG_PB_CODE = 112;
var SHA_256_CODE = 18;
function encodeCID(version, code12, multihash) {
  const codeOffset = encodingLength(version);
  const hashOffset = codeOffset + encodingLength(code12);
  const bytes = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo(version, bytes, 0);
  encodeTo(code12, bytes, codeOffset);
  bytes.set(multihash, hashOffset);
  return bytes;
}
var cidSymbol = Symbol.for("@ipld/js-cid/CID");

// node_modules/@ipld/dag-pb/src/pb-decode.js
var textDecoder = new TextDecoder();
function decodeVarint(bytes, offset) {
  let v = 0;
  for (let shift = 0; ; shift += 7) {
    if (shift >= 64) {
      throw new Error("protobuf: varint overflow");
    }
    if (offset >= bytes.length) {
      throw new Error("protobuf: unexpected end of data");
    }
    const b = bytes[offset++];
    v += shift < 28 ? (b & 127) << shift : (b & 127) * 2 ** shift;
    if (b < 128) {
      break;
    }
  }
  return [v, offset];
}
function decodeBytes(bytes, offset) {
  let byteLen;
  [byteLen, offset] = decodeVarint(bytes, offset);
  const postOffset = offset + byteLen;
  if (byteLen < 0 || postOffset < 0) {
    throw new Error("protobuf: invalid length");
  }
  if (postOffset > bytes.length) {
    throw new Error("protobuf: unexpected end of data");
  }
  return [bytes.subarray(offset, postOffset), postOffset];
}
function decodeKey(bytes, index) {
  let wire;
  [wire, index] = decodeVarint(bytes, index);
  return [wire & 7, wire >> 3, index];
}
function decodeLink(bytes) {
  const link = {};
  const l = bytes.length;
  let index = 0;
  while (index < l) {
    let wireType, fieldNum;
    [wireType, fieldNum, index] = decodeKey(bytes, index);
    if (fieldNum === 1) {
      if (link.Hash) {
        throw new Error("protobuf: (PBLink) duplicate Hash section");
      }
      if (wireType !== 2) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Hash`);
      }
      if (link.Name !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Name before Hash");
      }
      if (link.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Tsize before Hash");
      }
      [link.Hash, index] = decodeBytes(bytes, index);
    } else if (fieldNum === 2) {
      if (link.Name !== void 0) {
        throw new Error("protobuf: (PBLink) duplicate Name section");
      }
      if (wireType !== 2) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Name`);
      }
      if (link.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Tsize before Name");
      }
      let byts;
      [byts, index] = decodeBytes(bytes, index);
      link.Name = textDecoder.decode(byts);
    } else if (fieldNum === 3) {
      if (link.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) duplicate Tsize section");
      }
      if (wireType !== 0) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Tsize`);
      }
      [link.Tsize, index] = decodeVarint(bytes, index);
    } else {
      throw new Error(`protobuf: (PBLink) invalid fieldNumber, expected 1, 2 or 3, got ${fieldNum}`);
    }
  }
  if (index > l) {
    throw new Error("protobuf: (PBLink) unexpected end of data");
  }
  return link;
}
function decodeNode(bytes) {
  const l = bytes.length;
  let index = 0;
  let links = void 0;
  let linksBeforeData = false;
  let data = void 0;
  while (index < l) {
    let wireType, fieldNum;
    [wireType, fieldNum, index] = decodeKey(bytes, index);
    if (wireType !== 2) {
      throw new Error(`protobuf: (PBNode) invalid wireType, expected 2, got ${wireType}`);
    }
    if (fieldNum === 1) {
      if (data) {
        throw new Error("protobuf: (PBNode) duplicate Data section");
      }
      [data, index] = decodeBytes(bytes, index);
      if (links) {
        linksBeforeData = true;
      }
    } else if (fieldNum === 2) {
      if (linksBeforeData) {
        throw new Error("protobuf: (PBNode) duplicate Links section");
      } else if (!links) {
        links = [];
      }
      let byts;
      [byts, index] = decodeBytes(bytes, index);
      links.push(decodeLink(byts));
    } else {
      throw new Error(`protobuf: (PBNode) invalid fieldNumber, expected 1 or 2, got ${fieldNum}`);
    }
  }
  if (index > l) {
    throw new Error("protobuf: (PBNode) unexpected end of data");
  }
  const node = {};
  if (data) {
    node.Data = data;
  }
  node.Links = links || [];
  return node;
}

// node_modules/@ipld/dag-pb/src/pb-encode.js
var textEncoder = new TextEncoder();
var maxInt32 = 2 ** 32;
var maxUInt32 = 2 ** 31;
function encodeLink(link, bytes) {
  let i = bytes.length;
  if (typeof link.Tsize === "number") {
    if (link.Tsize < 0) {
      throw new Error("Tsize cannot be negative");
    }
    if (!Number.isSafeInteger(link.Tsize)) {
      throw new Error("Tsize too large for encoding");
    }
    i = encodeVarint(bytes, i, link.Tsize) - 1;
    bytes[i] = 24;
  }
  if (typeof link.Name === "string") {
    const nameBytes = textEncoder.encode(link.Name);
    i -= nameBytes.length;
    bytes.set(nameBytes, i);
    i = encodeVarint(bytes, i, nameBytes.length) - 1;
    bytes[i] = 18;
  }
  if (link.Hash) {
    i -= link.Hash.length;
    bytes.set(link.Hash, i);
    i = encodeVarint(bytes, i, link.Hash.length) - 1;
    bytes[i] = 10;
  }
  return bytes.length - i;
}
function encodeNode(node) {
  const size = sizeNode(node);
  const bytes = new Uint8Array(size);
  let i = size;
  if (node.Data) {
    i -= node.Data.length;
    bytes.set(node.Data, i);
    i = encodeVarint(bytes, i, node.Data.length) - 1;
    bytes[i] = 10;
  }
  if (node.Links) {
    for (let index = node.Links.length - 1; index >= 0; index--) {
      const size2 = encodeLink(node.Links[index], bytes.subarray(0, i));
      i -= size2;
      i = encodeVarint(bytes, i, size2) - 1;
      bytes[i] = 18;
    }
  }
  return bytes;
}
function sizeLink(link) {
  let n = 0;
  if (link.Hash) {
    const l = link.Hash.length;
    n += 1 + l + sov(l);
  }
  if (typeof link.Name === "string") {
    const l = textEncoder.encode(link.Name).length;
    n += 1 + l + sov(l);
  }
  if (typeof link.Tsize === "number") {
    n += 1 + sov(link.Tsize);
  }
  return n;
}
function sizeNode(node) {
  let n = 0;
  if (node.Data) {
    const l = node.Data.length;
    n += 1 + l + sov(l);
  }
  if (node.Links) {
    for (const link of node.Links) {
      const l = sizeLink(link);
      n += 1 + l + sov(l);
    }
  }
  return n;
}
function encodeVarint(bytes, offset, v) {
  offset -= sov(v);
  const base14 = offset;
  while (v >= maxUInt32) {
    bytes[offset++] = v & 127 | 128;
    v /= 128;
  }
  while (v >= 128) {
    bytes[offset++] = v & 127 | 128;
    v >>>= 7;
  }
  bytes[offset] = v;
  return base14;
}
function sov(x) {
  if (x % 2 === 0) {
    x++;
  }
  return Math.floor((len64(x) + 6) / 7);
}
function len64(x) {
  let n = 0;
  if (x >= maxInt32) {
    x = Math.floor(x / maxInt32);
    n = 32;
  }
  if (x >= 1 << 16) {
    x >>>= 16;
    n += 16;
  }
  if (x >= 1 << 8) {
    x >>>= 8;
    n += 8;
  }
  return n + len8tab[x];
}
var len8tab = [
  0,
  1,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8
];

// node_modules/@ipld/dag-pb/src/util.js
var pbNodeProperties = ["Data", "Links"];
var pbLinkProperties = ["Hash", "Name", "Tsize"];
var textEncoder2 = new TextEncoder();
function linkComparator(a, b) {
  if (a === b) {
    return 0;
  }
  const abuf = a.Name ? textEncoder2.encode(a.Name) : [];
  const bbuf = b.Name ? textEncoder2.encode(b.Name) : [];
  let x = abuf.length;
  let y = bbuf.length;
  for (let i = 0, len = Math.min(x, y); i < len; ++i) {
    if (abuf[i] !== bbuf[i]) {
      x = abuf[i];
      y = bbuf[i];
      break;
    }
  }
  return x < y ? -1 : y < x ? 1 : 0;
}
function hasOnlyProperties(node, properties) {
  return !Object.keys(node).some((p) => !properties.includes(p));
}
function asLink(link) {
  if (typeof link.asCID === "object") {
    const Hash2 = CID.asCID(link);
    if (!Hash2) {
      throw new TypeError("Invalid DAG-PB form");
    }
    return { Hash: Hash2 };
  }
  if (typeof link !== "object" || Array.isArray(link)) {
    throw new TypeError("Invalid DAG-PB form");
  }
  const pbl = {};
  if (link.Hash) {
    let cid = CID.asCID(link.Hash);
    try {
      if (!cid) {
        if (typeof link.Hash === "string") {
          cid = CID.parse(link.Hash);
        } else if (link.Hash instanceof Uint8Array) {
          cid = CID.decode(link.Hash);
        }
      }
    } catch (e) {
      throw new TypeError(`Invalid DAG-PB form: ${e.message}`);
    }
    if (cid) {
      pbl.Hash = cid;
    }
  }
  if (!pbl.Hash) {
    throw new TypeError("Invalid DAG-PB form");
  }
  if (typeof link.Name === "string") {
    pbl.Name = link.Name;
  }
  if (typeof link.Tsize === "number") {
    pbl.Tsize = link.Tsize;
  }
  return pbl;
}
function prepare(node) {
  if (node instanceof Uint8Array || typeof node === "string") {
    node = { Data: node };
  }
  if (typeof node !== "object" || Array.isArray(node)) {
    throw new TypeError("Invalid DAG-PB form");
  }
  const pbn = {};
  if (node.Data !== void 0) {
    if (typeof node.Data === "string") {
      pbn.Data = textEncoder2.encode(node.Data);
    } else if (node.Data instanceof Uint8Array) {
      pbn.Data = node.Data;
    } else {
      throw new TypeError("Invalid DAG-PB form");
    }
  }
  if (node.Links !== void 0) {
    if (Array.isArray(node.Links)) {
      pbn.Links = node.Links.map(asLink);
      pbn.Links.sort(linkComparator);
    } else {
      throw new TypeError("Invalid DAG-PB form");
    }
  } else {
    pbn.Links = [];
  }
  return pbn;
}
function validate(node) {
  if (!node || typeof node !== "object" || Array.isArray(node) || node instanceof Uint8Array || node["/"] && node["/"] === node.bytes) {
    throw new TypeError("Invalid DAG-PB form");
  }
  if (!hasOnlyProperties(node, pbNodeProperties)) {
    throw new TypeError("Invalid DAG-PB form (extraneous properties)");
  }
  if (node.Data !== void 0 && !(node.Data instanceof Uint8Array)) {
    throw new TypeError("Invalid DAG-PB form (Data must be bytes)");
  }
  if (!Array.isArray(node.Links)) {
    throw new TypeError("Invalid DAG-PB form (Links must be a list)");
  }
  for (let i = 0; i < node.Links.length; i++) {
    const link = node.Links[i];
    if (!link || typeof link !== "object" || Array.isArray(link) || link instanceof Uint8Array || link["/"] && link["/"] === link.bytes) {
      throw new TypeError("Invalid DAG-PB form (bad link)");
    }
    if (!hasOnlyProperties(link, pbLinkProperties)) {
      throw new TypeError("Invalid DAG-PB form (extraneous properties on link)");
    }
    if (link.Hash === void 0) {
      throw new TypeError("Invalid DAG-PB form (link must have a Hash)");
    }
    if (link.Hash == null || !link.Hash["/"] || link.Hash["/"] !== link.Hash.bytes) {
      throw new TypeError("Invalid DAG-PB form (link Hash must be a CID)");
    }
    if (link.Name !== void 0 && typeof link.Name !== "string") {
      throw new TypeError("Invalid DAG-PB form (link Name must be a string)");
    }
    if (link.Tsize !== void 0) {
      if (typeof link.Tsize !== "number" || link.Tsize % 1 !== 0) {
        throw new TypeError("Invalid DAG-PB form (link Tsize must be an integer)");
      }
      if (link.Tsize < 0) {
        throw new TypeError("Invalid DAG-PB form (link Tsize cannot be negative)");
      }
    }
    if (i > 0 && linkComparator(link, node.Links[i - 1]) === -1) {
      throw new TypeError("Invalid DAG-PB form (links must be sorted by Name bytes)");
    }
  }
}
function createNode(data, links = []) {
  return prepare({ Data: data, Links: links });
}
function createLink(name12, size, cid) {
  return asLink({ Hash: cid, Name: name12, Tsize: size });
}
function toByteView(buf2) {
  if (buf2 instanceof ArrayBuffer) {
    return new Uint8Array(buf2, 0, buf2.byteLength);
  }
  return buf2;
}

// node_modules/@ipld/dag-pb/src/index.js
var name = "dag-pb";
var code = 112;
function encode3(node) {
  validate(node);
  const pbn = {};
  if (node.Links) {
    pbn.Links = node.Links.map((l) => {
      const link = {};
      if (l.Hash) {
        link.Hash = l.Hash.bytes;
      }
      if (l.Name !== void 0) {
        link.Name = l.Name;
      }
      if (l.Tsize !== void 0) {
        link.Tsize = l.Tsize;
      }
      return link;
    });
  }
  if (node.Data) {
    pbn.Data = node.Data;
  }
  return encodeNode(pbn);
}
function decode5(bytes) {
  const buf2 = toByteView(bytes);
  const pbn = decodeNode(buf2);
  const node = {};
  if (pbn.Data) {
    node.Data = pbn.Data;
  }
  if (pbn.Links) {
    node.Links = pbn.Links.map((l) => {
      const link = {};
      try {
        link.Hash = CID.decode(l.Hash);
      } catch {
      }
      if (!link.Hash) {
        throw new Error("Invalid Hash field found in link, expected CID");
      }
      if (l.Name !== void 0) {
        link.Name = l.Name;
      }
      if (l.Tsize !== void 0) {
        link.Tsize = l.Tsize;
      }
      return link;
    });
  }
  return node;
}

// node_modules/@ipld/dag-cbor/src/index.js
var src_exports2 = {};
__export(src_exports2, {
  code: () => code2,
  decode: () => decode11,
  decodeOptions: () => decodeOptions,
  encode: () => encode7,
  encodeOptions: () => encodeOptions,
  name: () => name2,
  toByteView: () => toByteView2
});

// node_modules/cborg/lib/is.js
var typeofs = [
  "string",
  "number",
  "bigint",
  "symbol"
];
var objectTypeNames = [
  "Function",
  "Generator",
  "AsyncGenerator",
  "GeneratorFunction",
  "AsyncGeneratorFunction",
  "AsyncFunction",
  "Observable",
  "Array",
  "Buffer",
  "Object",
  "RegExp",
  "Date",
  "Error",
  "Map",
  "Set",
  "WeakMap",
  "WeakSet",
  "ArrayBuffer",
  "SharedArrayBuffer",
  "DataView",
  "Promise",
  "URL",
  "HTMLElement",
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Uint16Array",
  "Int32Array",
  "Uint32Array",
  "Float32Array",
  "Float64Array",
  "BigInt64Array",
  "BigUint64Array"
];
function is(value) {
  if (value === null) {
    return "null";
  }
  if (value === void 0) {
    return "undefined";
  }
  if (value === true || value === false) {
    return "boolean";
  }
  const typeOf2 = typeof value;
  if (typeofs.includes(typeOf2)) {
    return typeOf2;
  }
  if (typeOf2 === "function") {
    return "Function";
  }
  if (Array.isArray(value)) {
    return "Array";
  }
  if (isBuffer(value)) {
    return "Buffer";
  }
  const objectType = getObjectType(value);
  if (objectType) {
    return objectType;
  }
  return "Object";
}
function isBuffer(value) {
  return value && value.constructor && value.constructor.isBuffer && value.constructor.isBuffer.call(null, value);
}
function getObjectType(value) {
  const objectTypeName = Object.prototype.toString.call(value).slice(8, -1);
  if (objectTypeNames.includes(objectTypeName)) {
    return objectTypeName;
  }
  return void 0;
}

// node_modules/cborg/lib/token.js
var Type = class {
  /**
   * @param {number} major
   * @param {string} name
   * @param {boolean} terminal
   */
  constructor(major, name12, terminal) {
    this.major = major;
    this.majorEncoded = major << 5;
    this.name = name12;
    this.terminal = terminal;
  }
  /* c8 ignore next 3 */
  toString() {
    return `Type[${this.major}].${this.name}`;
  }
  /**
   * @param {Type} typ
   * @returns {number}
   */
  compare(typ) {
    return this.major < typ.major ? -1 : this.major > typ.major ? 1 : 0;
  }
};
Type.uint = new Type(0, "uint", true);
Type.negint = new Type(1, "negint", true);
Type.bytes = new Type(2, "bytes", true);
Type.string = new Type(3, "string", true);
Type.array = new Type(4, "array", false);
Type.map = new Type(5, "map", false);
Type.tag = new Type(6, "tag", false);
Type.float = new Type(7, "float", true);
Type.false = new Type(7, "false", true);
Type.true = new Type(7, "true", true);
Type.null = new Type(7, "null", true);
Type.undefined = new Type(7, "undefined", true);
Type.break = new Type(7, "break", true);
var Token = class {
  /**
   * @param {Type} type
   * @param {any} [value]
   * @param {number} [encodedLength]
   */
  constructor(type, value, encodedLength) {
    this.type = type;
    this.value = value;
    this.encodedLength = encodedLength;
    this.encodedBytes = void 0;
    this.byteValue = void 0;
  }
  /* c8 ignore next 3 */
  toString() {
    return `Token[${this.type}].${this.value}`;
  }
};

// node_modules/cborg/lib/byte-utils.js
var useBuffer = globalThis.process && // @ts-ignore
!globalThis.process.browser && // @ts-ignore
globalThis.Buffer && // @ts-ignore
typeof globalThis.Buffer.isBuffer === "function";
var textDecoder2 = new TextDecoder();
var textEncoder3 = new TextEncoder();
function isBuffer2(buf2) {
  return useBuffer && globalThis.Buffer.isBuffer(buf2);
}
function asU8A(buf2) {
  if (!(buf2 instanceof Uint8Array)) {
    return Uint8Array.from(buf2);
  }
  return isBuffer2(buf2) ? new Uint8Array(buf2.buffer, buf2.byteOffset, buf2.byteLength) : buf2;
}
var toString = useBuffer ? (
  // eslint-disable-line operator-linebreak
  /**
   * @param {Uint8Array} bytes
   * @param {number} start
   * @param {number} end
   */
  (bytes, start, end) => {
    return end - start > 64 ? (
      // eslint-disable-line operator-linebreak
      // @ts-ignore
      globalThis.Buffer.from(bytes.subarray(start, end)).toString("utf8")
    ) : utf8Slice(bytes, start, end);
  }
) : (
  // eslint-disable-line operator-linebreak
  /**
   * @param {Uint8Array} bytes
   * @param {number} start
   * @param {number} end
   */
  (bytes, start, end) => {
    return end - start > 64 ? textDecoder2.decode(bytes.subarray(start, end)) : utf8Slice(bytes, start, end);
  }
);
var fromString = useBuffer ? (
  // eslint-disable-line operator-linebreak
  /**
   * @param {string} string
   */
  (string3) => {
    return string3.length > 64 ? (
      // eslint-disable-line operator-linebreak
      // @ts-ignore
      globalThis.Buffer.from(string3)
    ) : utf8ToBytes2(string3);
  }
) : (
  // eslint-disable-line operator-linebreak
  /**
   * @param {string} string
   */
  (string3) => {
    return string3.length > 64 ? textEncoder3.encode(string3) : utf8ToBytes2(string3);
  }
);
var fromArray = (arr) => {
  return Uint8Array.from(arr);
};
var slice = useBuffer ? (
  // eslint-disable-line operator-linebreak
  /**
   * @param {Uint8Array} bytes
   * @param {number} start
   * @param {number} end
   */
  (bytes, start, end) => {
    if (isBuffer2(bytes)) {
      return new Uint8Array(bytes.subarray(start, end));
    }
    return bytes.slice(start, end);
  }
) : (
  // eslint-disable-line operator-linebreak
  /**
   * @param {Uint8Array} bytes
   * @param {number} start
   * @param {number} end
   */
  (bytes, start, end) => {
    return bytes.slice(start, end);
  }
);
var concat = useBuffer ? (
  // eslint-disable-line operator-linebreak
  /**
   * @param {Uint8Array[]} chunks
   * @param {number} length
   * @returns {Uint8Array}
   */
  (chunks, length11) => {
    chunks = chunks.map((c) => c instanceof Uint8Array ? c : (
      // eslint-disable-line operator-linebreak
      // @ts-ignore
      globalThis.Buffer.from(c)
    ));
    return asU8A(globalThis.Buffer.concat(chunks, length11));
  }
) : (
  // eslint-disable-line operator-linebreak
  /**
   * @param {Uint8Array[]} chunks
   * @param {number} length
   * @returns {Uint8Array}
   */
  (chunks, length11) => {
    const out = new Uint8Array(length11);
    let off = 0;
    for (let b of chunks) {
      if (off + b.length > out.length) {
        b = b.subarray(0, out.length - off);
      }
      out.set(b, off);
      off += b.length;
    }
    return out;
  }
);
var alloc = useBuffer ? (
  // eslint-disable-line operator-linebreak
  /**
   * @param {number} size
   * @returns {Uint8Array}
   */
  (size) => {
    return globalThis.Buffer.allocUnsafe(size);
  }
) : (
  // eslint-disable-line operator-linebreak
  /**
   * @param {number} size
   * @returns {Uint8Array}
   */
  (size) => {
    return new Uint8Array(size);
  }
);
function compare(b1, b2) {
  if (isBuffer2(b1) && isBuffer2(b2)) {
    return b1.compare(b2);
  }
  for (let i = 0; i < b1.length; i++) {
    if (b1[i] === b2[i]) {
      continue;
    }
    return b1[i] < b2[i] ? -1 : 1;
  }
  return 0;
}
function utf8ToBytes2(str) {
  const out = [];
  let p = 0;
  for (let i = 0; i < str.length; i++) {
    let c = str.charCodeAt(i);
    if (c < 128) {
      out[p++] = c;
    } else if (c < 2048) {
      out[p++] = c >> 6 | 192;
      out[p++] = c & 63 | 128;
    } else if ((c & 64512) === 55296 && i + 1 < str.length && (str.charCodeAt(i + 1) & 64512) === 56320) {
      c = 65536 + ((c & 1023) << 10) + (str.charCodeAt(++i) & 1023);
      out[p++] = c >> 18 | 240;
      out[p++] = c >> 12 & 63 | 128;
      out[p++] = c >> 6 & 63 | 128;
      out[p++] = c & 63 | 128;
    } else {
      out[p++] = c >> 12 | 224;
      out[p++] = c >> 6 & 63 | 128;
      out[p++] = c & 63 | 128;
    }
  }
  return out;
}
function utf8Slice(buf2, offset, end) {
  const res = [];
  while (offset < end) {
    const firstByte = buf2[offset];
    let codePoint = null;
    let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (offset + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf2[offset + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf2[offset + 1];
          thirdByte = buf2[offset + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf2[offset + 1];
          thirdByte = buf2[offset + 2];
          fourthByte = buf2[offset + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    offset += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
var MAX_ARGUMENTS_LENGTH = 4096;
function decodeCodePointsArray(codePoints) {
  const len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints);
  }
  let res = "";
  let i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    );
  }
  return res;
}

// node_modules/cborg/lib/bl.js
var defaultChunkSize = 256;
var Bl = class {
  /**
   * @param {number} [chunkSize]
   */
  constructor(chunkSize = defaultChunkSize) {
    this.chunkSize = chunkSize;
    this.cursor = 0;
    this.maxCursor = -1;
    this.chunks = [];
    this._initReuseChunk = null;
  }
  reset() {
    this.cursor = 0;
    this.maxCursor = -1;
    if (this.chunks.length) {
      this.chunks = [];
    }
    if (this._initReuseChunk !== null) {
      this.chunks.push(this._initReuseChunk);
      this.maxCursor = this._initReuseChunk.length - 1;
    }
  }
  /**
   * @param {Uint8Array|number[]} bytes
   */
  push(bytes) {
    let topChunk = this.chunks[this.chunks.length - 1];
    const newMax = this.cursor + bytes.length;
    if (newMax <= this.maxCursor + 1) {
      const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
      topChunk.set(bytes, chunkPos);
    } else {
      if (topChunk) {
        const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
        if (chunkPos < topChunk.length) {
          this.chunks[this.chunks.length - 1] = topChunk.subarray(0, chunkPos);
          this.maxCursor = this.cursor - 1;
        }
      }
      if (bytes.length < 64 && bytes.length < this.chunkSize) {
        topChunk = alloc(this.chunkSize);
        this.chunks.push(topChunk);
        this.maxCursor += topChunk.length;
        if (this._initReuseChunk === null) {
          this._initReuseChunk = topChunk;
        }
        topChunk.set(bytes, 0);
      } else {
        this.chunks.push(bytes);
        this.maxCursor += bytes.length;
      }
    }
    this.cursor += bytes.length;
  }
  /**
   * @param {boolean} [reset]
   * @returns {Uint8Array}
   */
  toBytes(reset = false) {
    let byts;
    if (this.chunks.length === 1) {
      const chunk = this.chunks[0];
      if (reset && this.cursor > chunk.length / 2) {
        byts = this.cursor === chunk.length ? chunk : chunk.subarray(0, this.cursor);
        this._initReuseChunk = null;
        this.chunks = [];
      } else {
        byts = slice(chunk, 0, this.cursor);
      }
    } else {
      byts = concat(this.chunks, this.cursor);
    }
    if (reset) {
      this.reset();
    }
    return byts;
  }
};

// node_modules/cborg/lib/common.js
var decodeErrPrefix = "CBOR decode error:";
var encodeErrPrefix = "CBOR encode error:";
var uintMinorPrefixBytes = [];
uintMinorPrefixBytes[23] = 1;
uintMinorPrefixBytes[24] = 2;
uintMinorPrefixBytes[25] = 3;
uintMinorPrefixBytes[26] = 5;
uintMinorPrefixBytes[27] = 9;
function assertEnoughData(data, pos, need) {
  if (data.length - pos < need) {
    throw new Error(`${decodeErrPrefix} not enough data for type`);
  }
}

// node_modules/cborg/lib/0uint.js
var uintBoundaries = [24, 256, 65536, 4294967296, BigInt("18446744073709551616")];
function readUint8(data, offset, options) {
  assertEnoughData(data, offset, 1);
  const value = data[offset];
  if (options.strict === true && value < uintBoundaries[0]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint16(data, offset, options) {
  assertEnoughData(data, offset, 2);
  const value = data[offset] << 8 | data[offset + 1];
  if (options.strict === true && value < uintBoundaries[1]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint32(data, offset, options) {
  assertEnoughData(data, offset, 4);
  const value = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
  if (options.strict === true && value < uintBoundaries[2]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint64(data, offset, options) {
  assertEnoughData(data, offset, 8);
  const hi = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
  const lo = data[offset + 4] * 16777216 + (data[offset + 5] << 16) + (data[offset + 6] << 8) + data[offset + 7];
  const value = (BigInt(hi) << BigInt(32)) + BigInt(lo);
  if (options.strict === true && value < uintBoundaries[3]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  if (value <= Number.MAX_SAFE_INTEGER) {
    return Number(value);
  }
  if (options.allowBigInt === true) {
    return value;
  }
  throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
}
function decodeUint8(data, pos, _minor, options) {
  return new Token(Type.uint, readUint8(data, pos + 1, options), 2);
}
function decodeUint16(data, pos, _minor, options) {
  return new Token(Type.uint, readUint16(data, pos + 1, options), 3);
}
function decodeUint32(data, pos, _minor, options) {
  return new Token(Type.uint, readUint32(data, pos + 1, options), 5);
}
function decodeUint64(data, pos, _minor, options) {
  return new Token(Type.uint, readUint64(data, pos + 1, options), 9);
}
function encodeUint(buf2, token) {
  return encodeUintValue(buf2, 0, token.value);
}
function encodeUintValue(buf2, major, uint) {
  if (uint < uintBoundaries[0]) {
    const nuint = Number(uint);
    buf2.push([major | nuint]);
  } else if (uint < uintBoundaries[1]) {
    const nuint = Number(uint);
    buf2.push([major | 24, nuint]);
  } else if (uint < uintBoundaries[2]) {
    const nuint = Number(uint);
    buf2.push([major | 25, nuint >>> 8, nuint & 255]);
  } else if (uint < uintBoundaries[3]) {
    const nuint = Number(uint);
    buf2.push([major | 26, nuint >>> 24 & 255, nuint >>> 16 & 255, nuint >>> 8 & 255, nuint & 255]);
  } else {
    const buint = BigInt(uint);
    if (buint < uintBoundaries[4]) {
      const set = [major | 27, 0, 0, 0, 0, 0, 0, 0];
      let lo = Number(buint & BigInt(4294967295));
      let hi = Number(buint >> BigInt(32) & BigInt(4294967295));
      set[8] = lo & 255;
      lo = lo >> 8;
      set[7] = lo & 255;
      lo = lo >> 8;
      set[6] = lo & 255;
      lo = lo >> 8;
      set[5] = lo & 255;
      set[4] = hi & 255;
      hi = hi >> 8;
      set[3] = hi & 255;
      hi = hi >> 8;
      set[2] = hi & 255;
      hi = hi >> 8;
      set[1] = hi & 255;
      buf2.push(set);
    } else {
      throw new Error(`${decodeErrPrefix} encountered BigInt larger than allowable range`);
    }
  }
}
encodeUint.encodedSize = function encodedSize(token) {
  return encodeUintValue.encodedSize(token.value);
};
encodeUintValue.encodedSize = function encodedSize2(uint) {
  if (uint < uintBoundaries[0]) {
    return 1;
  }
  if (uint < uintBoundaries[1]) {
    return 2;
  }
  if (uint < uintBoundaries[2]) {
    return 3;
  }
  if (uint < uintBoundaries[3]) {
    return 5;
  }
  return 9;
};
encodeUint.compareTokens = function compareTokens(tok1, tok2) {
  return tok1.value < tok2.value ? -1 : tok1.value > tok2.value ? 1 : (
    /* c8 ignore next */
    0
  );
};

// node_modules/cborg/lib/1negint.js
function decodeNegint8(data, pos, _minor, options) {
  return new Token(Type.negint, -1 - readUint8(data, pos + 1, options), 2);
}
function decodeNegint16(data, pos, _minor, options) {
  return new Token(Type.negint, -1 - readUint16(data, pos + 1, options), 3);
}
function decodeNegint32(data, pos, _minor, options) {
  return new Token(Type.negint, -1 - readUint32(data, pos + 1, options), 5);
}
var neg1b = BigInt(-1);
var pos1b = BigInt(1);
function decodeNegint64(data, pos, _minor, options) {
  const int = readUint64(data, pos + 1, options);
  if (typeof int !== "bigint") {
    const value = -1 - int;
    if (value >= Number.MIN_SAFE_INTEGER) {
      return new Token(Type.negint, value, 9);
    }
  }
  if (options.allowBigInt !== true) {
    throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
  }
  return new Token(Type.negint, neg1b - BigInt(int), 9);
}
function encodeNegint(buf2, token) {
  const negint = token.value;
  const unsigned = typeof negint === "bigint" ? negint * neg1b - pos1b : negint * -1 - 1;
  encodeUintValue(buf2, token.type.majorEncoded, unsigned);
}
encodeNegint.encodedSize = function encodedSize3(token) {
  const negint = token.value;
  const unsigned = typeof negint === "bigint" ? negint * neg1b - pos1b : negint * -1 - 1;
  if (unsigned < uintBoundaries[0]) {
    return 1;
  }
  if (unsigned < uintBoundaries[1]) {
    return 2;
  }
  if (unsigned < uintBoundaries[2]) {
    return 3;
  }
  if (unsigned < uintBoundaries[3]) {
    return 5;
  }
  return 9;
};
encodeNegint.compareTokens = function compareTokens2(tok1, tok2) {
  return tok1.value < tok2.value ? 1 : tok1.value > tok2.value ? -1 : (
    /* c8 ignore next */
    0
  );
};

// node_modules/cborg/lib/2bytes.js
function toToken(data, pos, prefix, length11) {
  assertEnoughData(data, pos, prefix + length11);
  const buf2 = slice(data, pos + prefix, pos + prefix + length11);
  return new Token(Type.bytes, buf2, prefix + length11);
}
function decodeBytesCompact(data, pos, minor, _options) {
  return toToken(data, pos, 1, minor);
}
function decodeBytes8(data, pos, _minor, options) {
  return toToken(data, pos, 2, readUint8(data, pos + 1, options));
}
function decodeBytes16(data, pos, _minor, options) {
  return toToken(data, pos, 3, readUint16(data, pos + 1, options));
}
function decodeBytes32(data, pos, _minor, options) {
  return toToken(data, pos, 5, readUint32(data, pos + 1, options));
}
function decodeBytes64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer bytes lengths not supported`);
  }
  return toToken(data, pos, 9, l);
}
function tokenBytes(token) {
  if (token.encodedBytes === void 0) {
    token.encodedBytes = token.type === Type.string ? fromString(token.value) : token.value;
  }
  return token.encodedBytes;
}
function encodeBytes(buf2, token) {
  const bytes = tokenBytes(token);
  encodeUintValue(buf2, token.type.majorEncoded, bytes.length);
  buf2.push(bytes);
}
encodeBytes.encodedSize = function encodedSize4(token) {
  const bytes = tokenBytes(token);
  return encodeUintValue.encodedSize(bytes.length) + bytes.length;
};
encodeBytes.compareTokens = function compareTokens3(tok1, tok2) {
  return compareBytes(tokenBytes(tok1), tokenBytes(tok2));
};
function compareBytes(b1, b2) {
  return b1.length < b2.length ? -1 : b1.length > b2.length ? 1 : compare(b1, b2);
}

// node_modules/cborg/lib/3string.js
function toToken2(data, pos, prefix, length11, options) {
  const totLength = prefix + length11;
  assertEnoughData(data, pos, totLength);
  const tok = new Token(Type.string, toString(data, pos + prefix, pos + totLength), totLength);
  if (options.retainStringBytes === true) {
    tok.byteValue = slice(data, pos + prefix, pos + totLength);
  }
  return tok;
}
function decodeStringCompact(data, pos, minor, options) {
  return toToken2(data, pos, 1, minor, options);
}
function decodeString8(data, pos, _minor, options) {
  return toToken2(data, pos, 2, readUint8(data, pos + 1, options), options);
}
function decodeString16(data, pos, _minor, options) {
  return toToken2(data, pos, 3, readUint16(data, pos + 1, options), options);
}
function decodeString32(data, pos, _minor, options) {
  return toToken2(data, pos, 5, readUint32(data, pos + 1, options), options);
}
function decodeString64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer string lengths not supported`);
  }
  return toToken2(data, pos, 9, l, options);
}
var encodeString = encodeBytes;

// node_modules/cborg/lib/4array.js
function toToken3(_data, _pos, prefix, length11) {
  return new Token(Type.array, length11, prefix);
}
function decodeArrayCompact(data, pos, minor, _options) {
  return toToken3(data, pos, 1, minor);
}
function decodeArray8(data, pos, _minor, options) {
  return toToken3(data, pos, 2, readUint8(data, pos + 1, options));
}
function decodeArray16(data, pos, _minor, options) {
  return toToken3(data, pos, 3, readUint16(data, pos + 1, options));
}
function decodeArray32(data, pos, _minor, options) {
  return toToken3(data, pos, 5, readUint32(data, pos + 1, options));
}
function decodeArray64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer array lengths not supported`);
  }
  return toToken3(data, pos, 9, l);
}
function decodeArrayIndefinite(data, pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return toToken3(data, pos, 1, Infinity);
}
function encodeArray(buf2, token) {
  encodeUintValue(buf2, Type.array.majorEncoded, token.value);
}
encodeArray.compareTokens = encodeUint.compareTokens;
encodeArray.encodedSize = function encodedSize5(token) {
  return encodeUintValue.encodedSize(token.value);
};

// node_modules/cborg/lib/5map.js
function toToken4(_data, _pos, prefix, length11) {
  return new Token(Type.map, length11, prefix);
}
function decodeMapCompact(data, pos, minor, _options) {
  return toToken4(data, pos, 1, minor);
}
function decodeMap8(data, pos, _minor, options) {
  return toToken4(data, pos, 2, readUint8(data, pos + 1, options));
}
function decodeMap16(data, pos, _minor, options) {
  return toToken4(data, pos, 3, readUint16(data, pos + 1, options));
}
function decodeMap32(data, pos, _minor, options) {
  return toToken4(data, pos, 5, readUint32(data, pos + 1, options));
}
function decodeMap64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer map lengths not supported`);
  }
  return toToken4(data, pos, 9, l);
}
function decodeMapIndefinite(data, pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return toToken4(data, pos, 1, Infinity);
}
function encodeMap(buf2, token) {
  encodeUintValue(buf2, Type.map.majorEncoded, token.value);
}
encodeMap.compareTokens = encodeUint.compareTokens;
encodeMap.encodedSize = function encodedSize6(token) {
  return encodeUintValue.encodedSize(token.value);
};

// node_modules/cborg/lib/6tag.js
function decodeTagCompact(_data, _pos, minor, _options) {
  return new Token(Type.tag, minor, 1);
}
function decodeTag8(data, pos, _minor, options) {
  return new Token(Type.tag, readUint8(data, pos + 1, options), 2);
}
function decodeTag16(data, pos, _minor, options) {
  return new Token(Type.tag, readUint16(data, pos + 1, options), 3);
}
function decodeTag32(data, pos, _minor, options) {
  return new Token(Type.tag, readUint32(data, pos + 1, options), 5);
}
function decodeTag64(data, pos, _minor, options) {
  return new Token(Type.tag, readUint64(data, pos + 1, options), 9);
}
function encodeTag(buf2, token) {
  encodeUintValue(buf2, Type.tag.majorEncoded, token.value);
}
encodeTag.compareTokens = encodeUint.compareTokens;
encodeTag.encodedSize = function encodedSize7(token) {
  return encodeUintValue.encodedSize(token.value);
};

// node_modules/cborg/lib/7float.js
var MINOR_FALSE = 20;
var MINOR_TRUE = 21;
var MINOR_NULL = 22;
var MINOR_UNDEFINED = 23;
function decodeUndefined(_data, _pos, _minor, options) {
  if (options.allowUndefined === false) {
    throw new Error(`${decodeErrPrefix} undefined values are not supported`);
  } else if (options.coerceUndefinedToNull === true) {
    return new Token(Type.null, null, 1);
  }
  return new Token(Type.undefined, void 0, 1);
}
function decodeBreak(_data, _pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return new Token(Type.break, void 0, 1);
}
function createToken(value, bytes, options) {
  if (options) {
    if (options.allowNaN === false && Number.isNaN(value)) {
      throw new Error(`${decodeErrPrefix} NaN values are not supported`);
    }
    if (options.allowInfinity === false && (value === Infinity || value === -Infinity)) {
      throw new Error(`${decodeErrPrefix} Infinity values are not supported`);
    }
  }
  return new Token(Type.float, value, bytes);
}
function decodeFloat16(data, pos, _minor, options) {
  return createToken(readFloat16(data, pos + 1), 3, options);
}
function decodeFloat32(data, pos, _minor, options) {
  return createToken(readFloat32(data, pos + 1), 5, options);
}
function decodeFloat64(data, pos, _minor, options) {
  return createToken(readFloat64(data, pos + 1), 9, options);
}
function encodeFloat(buf2, token, options) {
  const float = token.value;
  if (float === false) {
    buf2.push([Type.float.majorEncoded | MINOR_FALSE]);
  } else if (float === true) {
    buf2.push([Type.float.majorEncoded | MINOR_TRUE]);
  } else if (float === null) {
    buf2.push([Type.float.majorEncoded | MINOR_NULL]);
  } else if (float === void 0) {
    buf2.push([Type.float.majorEncoded | MINOR_UNDEFINED]);
  } else {
    let decoded;
    let success = false;
    if (!options || options.float64 !== true) {
      encodeFloat16(float);
      decoded = readFloat16(ui8a, 1);
      if (float === decoded || Number.isNaN(float)) {
        ui8a[0] = 249;
        buf2.push(ui8a.slice(0, 3));
        success = true;
      } else {
        encodeFloat32(float);
        decoded = readFloat32(ui8a, 1);
        if (float === decoded) {
          ui8a[0] = 250;
          buf2.push(ui8a.slice(0, 5));
          success = true;
        }
      }
    }
    if (!success) {
      encodeFloat64(float);
      decoded = readFloat64(ui8a, 1);
      ui8a[0] = 251;
      buf2.push(ui8a.slice(0, 9));
    }
  }
}
encodeFloat.encodedSize = function encodedSize8(token, options) {
  const float = token.value;
  if (float === false || float === true || float === null || float === void 0) {
    return 1;
  }
  if (!options || options.float64 !== true) {
    encodeFloat16(float);
    let decoded = readFloat16(ui8a, 1);
    if (float === decoded || Number.isNaN(float)) {
      return 3;
    }
    encodeFloat32(float);
    decoded = readFloat32(ui8a, 1);
    if (float === decoded) {
      return 5;
    }
  }
  return 9;
};
var buffer = new ArrayBuffer(9);
var dataView = new DataView(buffer, 1);
var ui8a = new Uint8Array(buffer, 0);
function encodeFloat16(inp) {
  if (inp === Infinity) {
    dataView.setUint16(0, 31744, false);
  } else if (inp === -Infinity) {
    dataView.setUint16(0, 64512, false);
  } else if (Number.isNaN(inp)) {
    dataView.setUint16(0, 32256, false);
  } else {
    dataView.setFloat32(0, inp);
    const valu32 = dataView.getUint32(0);
    const exponent = (valu32 & 2139095040) >> 23;
    const mantissa = valu32 & 8388607;
    if (exponent === 255) {
      dataView.setUint16(0, 31744, false);
    } else if (exponent === 0) {
      dataView.setUint16(0, (inp & 2147483648) >> 16 | mantissa >> 13, false);
    } else {
      const logicalExponent = exponent - 127;
      if (logicalExponent < -24) {
        dataView.setUint16(0, 0);
      } else if (logicalExponent < -14) {
        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | /* sign bit */
        1 << 24 + logicalExponent, false);
      } else {
        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | logicalExponent + 15 << 10 | mantissa >> 13, false);
      }
    }
  }
}
function readFloat16(ui8a2, pos) {
  if (ui8a2.length - pos < 2) {
    throw new Error(`${decodeErrPrefix} not enough data for float16`);
  }
  const half = (ui8a2[pos] << 8) + ui8a2[pos + 1];
  if (half === 31744) {
    return Infinity;
  }
  if (half === 64512) {
    return -Infinity;
  }
  if (half === 32256) {
    return NaN;
  }
  const exp = half >> 10 & 31;
  const mant = half & 1023;
  let val;
  if (exp === 0) {
    val = mant * 2 ** -24;
  } else if (exp !== 31) {
    val = (mant + 1024) * 2 ** (exp - 25);
  } else {
    val = mant === 0 ? Infinity : NaN;
  }
  return half & 32768 ? -val : val;
}
function encodeFloat32(inp) {
  dataView.setFloat32(0, inp, false);
}
function readFloat32(ui8a2, pos) {
  if (ui8a2.length - pos < 4) {
    throw new Error(`${decodeErrPrefix} not enough data for float32`);
  }
  const offset = (ui8a2.byteOffset || 0) + pos;
  return new DataView(ui8a2.buffer, offset, 4).getFloat32(0, false);
}
function encodeFloat64(inp) {
  dataView.setFloat64(0, inp, false);
}
function readFloat64(ui8a2, pos) {
  if (ui8a2.length - pos < 8) {
    throw new Error(`${decodeErrPrefix} not enough data for float64`);
  }
  const offset = (ui8a2.byteOffset || 0) + pos;
  return new DataView(ui8a2.buffer, offset, 8).getFloat64(0, false);
}
encodeFloat.compareTokens = encodeUint.compareTokens;

// node_modules/cborg/lib/jump.js
function invalidMinor(data, pos, minor) {
  throw new Error(`${decodeErrPrefix} encountered invalid minor (${minor}) for major ${data[pos] >>> 5}`);
}
function errorer(msg) {
  return () => {
    throw new Error(`${decodeErrPrefix} ${msg}`);
  };
}
var jump = [];
for (let i = 0; i <= 23; i++) {
  jump[i] = invalidMinor;
}
jump[24] = decodeUint8;
jump[25] = decodeUint16;
jump[26] = decodeUint32;
jump[27] = decodeUint64;
jump[28] = invalidMinor;
jump[29] = invalidMinor;
jump[30] = invalidMinor;
jump[31] = invalidMinor;
for (let i = 32; i <= 55; i++) {
  jump[i] = invalidMinor;
}
jump[56] = decodeNegint8;
jump[57] = decodeNegint16;
jump[58] = decodeNegint32;
jump[59] = decodeNegint64;
jump[60] = invalidMinor;
jump[61] = invalidMinor;
jump[62] = invalidMinor;
jump[63] = invalidMinor;
for (let i = 64; i <= 87; i++) {
  jump[i] = decodeBytesCompact;
}
jump[88] = decodeBytes8;
jump[89] = decodeBytes16;
jump[90] = decodeBytes32;
jump[91] = decodeBytes64;
jump[92] = invalidMinor;
jump[93] = invalidMinor;
jump[94] = invalidMinor;
jump[95] = errorer("indefinite length bytes/strings are not supported");
for (let i = 96; i <= 119; i++) {
  jump[i] = decodeStringCompact;
}
jump[120] = decodeString8;
jump[121] = decodeString16;
jump[122] = decodeString32;
jump[123] = decodeString64;
jump[124] = invalidMinor;
jump[125] = invalidMinor;
jump[126] = invalidMinor;
jump[127] = errorer("indefinite length bytes/strings are not supported");
for (let i = 128; i <= 151; i++) {
  jump[i] = decodeArrayCompact;
}
jump[152] = decodeArray8;
jump[153] = decodeArray16;
jump[154] = decodeArray32;
jump[155] = decodeArray64;
jump[156] = invalidMinor;
jump[157] = invalidMinor;
jump[158] = invalidMinor;
jump[159] = decodeArrayIndefinite;
for (let i = 160; i <= 183; i++) {
  jump[i] = decodeMapCompact;
}
jump[184] = decodeMap8;
jump[185] = decodeMap16;
jump[186] = decodeMap32;
jump[187] = decodeMap64;
jump[188] = invalidMinor;
jump[189] = invalidMinor;
jump[190] = invalidMinor;
jump[191] = decodeMapIndefinite;
for (let i = 192; i <= 215; i++) {
  jump[i] = decodeTagCompact;
}
jump[216] = decodeTag8;
jump[217] = decodeTag16;
jump[218] = decodeTag32;
jump[219] = decodeTag64;
jump[220] = invalidMinor;
jump[221] = invalidMinor;
jump[222] = invalidMinor;
jump[223] = invalidMinor;
for (let i = 224; i <= 243; i++) {
  jump[i] = errorer("simple values are not supported");
}
jump[244] = invalidMinor;
jump[245] = invalidMinor;
jump[246] = invalidMinor;
jump[247] = decodeUndefined;
jump[248] = errorer("simple values are not supported");
jump[249] = decodeFloat16;
jump[250] = decodeFloat32;
jump[251] = decodeFloat64;
jump[252] = invalidMinor;
jump[253] = invalidMinor;
jump[254] = invalidMinor;
jump[255] = decodeBreak;
var quick = [];
for (let i = 0; i < 24; i++) {
  quick[i] = new Token(Type.uint, i, 1);
}
for (let i = -1; i >= -24; i--) {
  quick[31 - i] = new Token(Type.negint, i, 1);
}
quick[64] = new Token(Type.bytes, new Uint8Array(0), 1);
quick[96] = new Token(Type.string, "", 1);
quick[128] = new Token(Type.array, 0, 1);
quick[160] = new Token(Type.map, 0, 1);
quick[244] = new Token(Type.false, false, 1);
quick[245] = new Token(Type.true, true, 1);
quick[246] = new Token(Type.null, null, 1);
function quickEncodeToken(token) {
  switch (token.type) {
    case Type.false:
      return fromArray([244]);
    case Type.true:
      return fromArray([245]);
    case Type.null:
      return fromArray([246]);
    case Type.bytes:
      if (!token.value.length) {
        return fromArray([64]);
      }
      return;
    case Type.string:
      if (token.value === "") {
        return fromArray([96]);
      }
      return;
    case Type.array:
      if (token.value === 0) {
        return fromArray([128]);
      }
      return;
    case Type.map:
      if (token.value === 0) {
        return fromArray([160]);
      }
      return;
    case Type.uint:
      if (token.value < 24) {
        return fromArray([Number(token.value)]);
      }
      return;
    case Type.negint:
      if (token.value >= -24) {
        return fromArray([31 - Number(token.value)]);
      }
  }
}

// node_modules/cborg/lib/encode.js
var defaultEncodeOptions = {
  float64: false,
  mapSorter,
  quickEncodeToken
};
var rfc8949EncodeOptions = Object.freeze({
  float64: true,
  mapSorter: rfc8949MapSorter,
  quickEncodeToken
});
function makeCborEncoders() {
  const encoders = [];
  encoders[Type.uint.major] = encodeUint;
  encoders[Type.negint.major] = encodeNegint;
  encoders[Type.bytes.major] = encodeBytes;
  encoders[Type.string.major] = encodeString;
  encoders[Type.array.major] = encodeArray;
  encoders[Type.map.major] = encodeMap;
  encoders[Type.tag.major] = encodeTag;
  encoders[Type.float.major] = encodeFloat;
  return encoders;
}
var cborEncoders = makeCborEncoders();
var buf = new Bl();
var Ref = class _Ref {
  /**
   * @param {object|any[]} obj
   * @param {Reference|undefined} parent
   */
  constructor(obj, parent) {
    this.obj = obj;
    this.parent = parent;
  }
  /**
   * @param {object|any[]} obj
   * @returns {boolean}
   */
  includes(obj) {
    let p = this;
    do {
      if (p.obj === obj) {
        return true;
      }
    } while (p = p.parent);
    return false;
  }
  /**
   * @param {Reference|undefined} stack
   * @param {object|any[]} obj
   * @returns {Reference}
   */
  static createCheck(stack, obj) {
    if (stack && stack.includes(obj)) {
      throw new Error(`${encodeErrPrefix} object contains circular references`);
    }
    return new _Ref(obj, stack);
  }
};
var simpleTokens = {
  null: new Token(Type.null, null),
  undefined: new Token(Type.undefined, void 0),
  true: new Token(Type.true, true),
  false: new Token(Type.false, false),
  emptyArray: new Token(Type.array, 0),
  emptyMap: new Token(Type.map, 0)
};
var typeEncoders = {
  /**
   * @param {any} obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  number(obj, _typ, _options, _refStack) {
    if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {
      return new Token(Type.float, obj);
    } else if (obj >= 0) {
      return new Token(Type.uint, obj);
    } else {
      return new Token(Type.negint, obj);
    }
  },
  /**
   * @param {any} obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  bigint(obj, _typ, _options, _refStack) {
    if (obj >= BigInt(0)) {
      return new Token(Type.uint, obj);
    } else {
      return new Token(Type.negint, obj);
    }
  },
  /**
   * @param {any} obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  Uint8Array(obj, _typ, _options, _refStack) {
    return new Token(Type.bytes, obj);
  },
  /**
   * @param {any} obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  string(obj, _typ, _options, _refStack) {
    return new Token(Type.string, obj);
  },
  /**
   * @param {any} obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  boolean(obj, _typ, _options, _refStack) {
    return obj ? simpleTokens.true : simpleTokens.false;
  },
  /**
   * @param {any} _obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  null(_obj, _typ, _options, _refStack) {
    return simpleTokens.null;
  },
  /**
   * @param {any} _obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  undefined(_obj, _typ, _options, _refStack) {
    return simpleTokens.undefined;
  },
  /**
   * @param {any} obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  ArrayBuffer(obj, _typ, _options, _refStack) {
    return new Token(Type.bytes, new Uint8Array(obj));
  },
  /**
   * @param {any} obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  DataView(obj, _typ, _options, _refStack) {
    return new Token(Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));
  },
  /**
   * @param {any} obj
   * @param {string} _typ
   * @param {EncodeOptions} options
   * @param {Reference} [refStack]
   * @returns {TokenOrNestedTokens}
   */
  Array(obj, _typ, options, refStack) {
    if (!obj.length) {
      if (options.addBreakTokens === true) {
        return [simpleTokens.emptyArray, new Token(Type.break)];
      }
      return simpleTokens.emptyArray;
    }
    refStack = Ref.createCheck(refStack, obj);
    const entries = [];
    let i = 0;
    for (const e of obj) {
      entries[i++] = objectToTokens(e, options, refStack);
    }
    if (options.addBreakTokens) {
      return [new Token(Type.array, obj.length), entries, new Token(Type.break)];
    }
    return [new Token(Type.array, obj.length), entries];
  },
  /**
   * @param {any} obj
   * @param {string} typ
   * @param {EncodeOptions} options
   * @param {Reference} [refStack]
   * @returns {TokenOrNestedTokens}
   */
  Object(obj, typ, options, refStack) {
    const isMap = typ !== "Object";
    const keys = isMap ? obj.keys() : Object.keys(obj);
    const length11 = isMap ? obj.size : keys.length;
    if (!length11) {
      if (options.addBreakTokens === true) {
        return [simpleTokens.emptyMap, new Token(Type.break)];
      }
      return simpleTokens.emptyMap;
    }
    refStack = Ref.createCheck(refStack, obj);
    const entries = [];
    let i = 0;
    for (const key of keys) {
      entries[i++] = [
        objectToTokens(key, options, refStack),
        objectToTokens(isMap ? obj.get(key) : obj[key], options, refStack)
      ];
    }
    sortMapEntries(entries, options);
    if (options.addBreakTokens) {
      return [new Token(Type.map, length11), entries, new Token(Type.break)];
    }
    return [new Token(Type.map, length11), entries];
  }
};
typeEncoders.Map = typeEncoders.Object;
typeEncoders.Buffer = typeEncoders.Uint8Array;
for (const typ of "Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" ")) {
  typeEncoders[`${typ}Array`] = typeEncoders.DataView;
}
function objectToTokens(obj, options = {}, refStack) {
  const typ = is(obj);
  const customTypeEncoder = options && options.typeEncoders && /** @type {OptionalTypeEncoder} */
  options.typeEncoders[typ] || typeEncoders[typ];
  if (typeof customTypeEncoder === "function") {
    const tokens = customTypeEncoder(obj, typ, options, refStack);
    if (tokens != null) {
      return tokens;
    }
  }
  const typeEncoder = typeEncoders[typ];
  if (!typeEncoder) {
    throw new Error(`${encodeErrPrefix} unsupported type: ${typ}`);
  }
  return typeEncoder(obj, typ, options, refStack);
}
function sortMapEntries(entries, options) {
  if (options.mapSorter) {
    entries.sort(options.mapSorter);
  }
}
function mapSorter(e1, e2) {
  const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0];
  const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0];
  if (keyToken1.type !== keyToken2.type) {
    return keyToken1.type.compare(keyToken2.type);
  }
  const major = keyToken1.type.major;
  const tcmp = cborEncoders[major].compareTokens(keyToken1, keyToken2);
  if (tcmp === 0) {
    console.warn("WARNING: complex key types used, CBOR key sorting guarantees are gone");
  }
  return tcmp;
}
function rfc8949MapSorter(e1, e2) {
  if (e1[0] instanceof Token && e2[0] instanceof Token) {
    const t1 = (
      /** @type {TokenEx} */
      e1[0]
    );
    const t2 = (
      /** @type {TokenEx} */
      e2[0]
    );
    if (!t1._keyBytes) {
      t1._keyBytes = encodeRfc8949(t1.value);
    }
    if (!t2._keyBytes) {
      t2._keyBytes = encodeRfc8949(t2.value);
    }
    return compare(t1._keyBytes, t2._keyBytes);
  }
  throw new Error("rfc8949MapSorter: complex key types are not supported yet");
}
function encodeRfc8949(data) {
  return encodeCustom(data, cborEncoders, rfc8949EncodeOptions);
}
function tokensToEncoded(buf2, tokens, encoders, options) {
  if (Array.isArray(tokens)) {
    for (const token of tokens) {
      tokensToEncoded(buf2, token, encoders, options);
    }
  } else {
    encoders[tokens.type.major](buf2, tokens, options);
  }
}
function encodeCustom(data, encoders, options) {
  const tokens = objectToTokens(data, options);
  if (!Array.isArray(tokens) && options.quickEncodeToken) {
    const quickBytes = options.quickEncodeToken(tokens);
    if (quickBytes) {
      return quickBytes;
    }
    const encoder = encoders[tokens.type.major];
    if (encoder.encodedSize) {
      const size = encoder.encodedSize(tokens, options);
      const buf2 = new Bl(size);
      encoder(buf2, tokens, options);
      if (buf2.chunks.length !== 1) {
        throw new Error(`Unexpected error: pre-calculated length for ${tokens} was wrong`);
      }
      return asU8A(buf2.chunks[0]);
    }
  }
  buf.reset();
  tokensToEncoded(buf, tokens, encoders, options);
  return buf.toBytes(true);
}
function encode4(data, options) {
  options = Object.assign({}, defaultEncodeOptions, options);
  return encodeCustom(data, cborEncoders, options);
}

// node_modules/cborg/lib/decode.js
var defaultDecodeOptions = {
  strict: false,
  allowIndefinite: true,
  allowUndefined: true,
  allowBigInt: true
};
var Tokeniser = class {
  /**
   * @param {Uint8Array} data
   * @param {DecodeOptions} options
   */
  constructor(data, options = {}) {
    this._pos = 0;
    this.data = data;
    this.options = options;
  }
  pos() {
    return this._pos;
  }
  done() {
    return this._pos >= this.data.length;
  }
  next() {
    const byt = this.data[this._pos];
    let token = quick[byt];
    if (token === void 0) {
      const decoder = jump[byt];
      if (!decoder) {
        throw new Error(`${decodeErrPrefix} no decoder for major type ${byt >>> 5} (byte 0x${byt.toString(16).padStart(2, "0")})`);
      }
      const minor = byt & 31;
      token = decoder(this.data, this._pos, minor, this.options);
    }
    this._pos += token.encodedLength;
    return token;
  }
};
var DONE = Symbol.for("DONE");
var BREAK = Symbol.for("BREAK");
function tokenToArray(token, tokeniser, options) {
  const arr = [];
  for (let i = 0; i < token.value; i++) {
    const value = tokensToObject(tokeniser, options);
    if (value === BREAK) {
      if (token.value === Infinity) {
        break;
      }
      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed array`);
    }
    if (value === DONE) {
      throw new Error(`${decodeErrPrefix} found array but not enough entries (got ${i}, expected ${token.value})`);
    }
    arr[i] = value;
  }
  return arr;
}
function tokenToMap(token, tokeniser, options) {
  const useMaps = options.useMaps === true;
  const obj = useMaps ? void 0 : {};
  const m = useMaps ? /* @__PURE__ */ new Map() : void 0;
  for (let i = 0; i < token.value; i++) {
    const key = tokensToObject(tokeniser, options);
    if (key === BREAK) {
      if (token.value === Infinity) {
        break;
      }
      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed map`);
    }
    if (key === DONE) {
      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i} [no key], expected ${token.value})`);
    }
    if (useMaps !== true && typeof key !== "string") {
      throw new Error(`${decodeErrPrefix} non-string keys not supported (got ${typeof key})`);
    }
    if (options.rejectDuplicateMapKeys === true) {
      if (useMaps && m.has(key) || !useMaps && key in obj) {
        throw new Error(`${decodeErrPrefix} found repeat map key "${key}"`);
      }
    }
    const value = tokensToObject(tokeniser, options);
    if (value === DONE) {
      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i} [no value], expected ${token.value})`);
    }
    if (useMaps) {
      m.set(key, value);
    } else {
      obj[key] = value;
    }
  }
  return useMaps ? m : obj;
}
function tokensToObject(tokeniser, options) {
  if (tokeniser.done()) {
    return DONE;
  }
  const token = tokeniser.next();
  if (token.type === Type.break) {
    return BREAK;
  }
  if (token.type.terminal) {
    return token.value;
  }
  if (token.type === Type.array) {
    return tokenToArray(token, tokeniser, options);
  }
  if (token.type === Type.map) {
    return tokenToMap(token, tokeniser, options);
  }
  if (token.type === Type.tag) {
    if (options.tags && typeof options.tags[token.value] === "function") {
      const tagged = tokensToObject(tokeniser, options);
      return options.tags[token.value](tagged);
    }
    throw new Error(`${decodeErrPrefix} tag not supported (${token.value})`);
  }
  throw new Error("unsupported");
}
function decodeFirst(data, options) {
  if (!(data instanceof Uint8Array)) {
    throw new Error(`${decodeErrPrefix} data to decode must be a Uint8Array`);
  }
  options = Object.assign({}, defaultDecodeOptions, options);
  const tokeniser = options.tokenizer || new Tokeniser(data, options);
  const decoded = tokensToObject(tokeniser, options);
  if (decoded === DONE) {
    throw new Error(`${decodeErrPrefix} did not find any content to decode`);
  }
  if (decoded === BREAK) {
    throw new Error(`${decodeErrPrefix} got unexpected break`);
  }
  return [decoded, data.subarray(tokeniser.pos())];
}
function decode6(data, options) {
  const [decoded, remainder] = decodeFirst(data, options);
  if (remainder.length > 0) {
    throw new Error(`${decodeErrPrefix} too many terminals, data makes no sense`);
  }
  return decoded;
}

// node_modules/@ipld/dag-cbor/node_modules/multiformats/dist/src/bytes.js
var empty2 = new Uint8Array(0);
function equals3(aa, bb) {
  if (aa === bb) {
    return true;
  }
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}
function coerce2(o) {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array") {
    return o;
  }
  if (o instanceof ArrayBuffer) {
    return new Uint8Array(o);
  }
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}

// node_modules/@ipld/dag-cbor/node_modules/multiformats/dist/src/vendor/base-x.js
function base2(ALPHABET, name12) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode42(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length11 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length11) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length11 = i2;
      pbegin++;
    }
    var it2 = size - length11;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length11 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length11) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length11 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length11;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode58(string3) {
    var buffer2 = decodeUnsafe(string3);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name12} character`);
  }
  return {
    encode: encode42,
    decodeUnsafe,
    decode: decode58
  };
}
var src2 = base2;
var _brrp__multiformats_scope_baseX2 = src2;
var base_x_default2 = _brrp__multiformats_scope_baseX2;

// node_modules/@ipld/dag-cbor/node_modules/multiformats/dist/src/bases/base.js
var Encoder2 = class {
  name;
  prefix;
  baseEncode;
  constructor(name12, prefix, baseEncode) {
    this.name = name12;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes) {
    if (bytes instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder2 = class {
  name;
  prefix;
  baseDecode;
  prefixCodePoint;
  constructor(name12, prefix, baseDecode) {
    this.name = name12;
    this.prefix = prefix;
    const prefixCodePoint = prefix.codePointAt(0);
    if (prefixCodePoint === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefixCodePoint;
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or2(this, decoder);
  }
};
var ComposedDecoder2 = class {
  decoders;
  constructor(decoders3) {
    this.decoders = decoders3;
  }
  or(decoder) {
    return or2(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder != null) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
function or2(left, right) {
  return new ComposedDecoder2({
    ...left.decoders ?? { [left.prefix]: left },
    ...right.decoders ?? { [right.prefix]: right }
  });
}
var Codec2 = class {
  name;
  prefix;
  baseEncode;
  baseDecode;
  encoder;
  decoder;
  constructor(name12, prefix, baseEncode, baseDecode) {
    this.name = name12;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder2(name12, prefix, baseEncode);
    this.decoder = new Decoder2(name12, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
function from2({ name: name12, prefix, encode: encode42, decode: decode58 }) {
  return new Codec2(name12, prefix, encode42, decode58);
}
function baseX2({ name: name12, prefix, alphabet: alphabet7 }) {
  const { encode: encode42, decode: decode58 } = base_x_default2(alphabet7, name12);
  return from2({
    prefix,
    name: name12,
    encode: encode42,
    decode: (text) => coerce2(decode58(text))
  });
}
function decode7(string3, alphabetIdx, bitsPerChar, name12) {
  let end = string3.length;
  while (string3[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = alphabetIdx[string3[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name12} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer2 >> bits;
    }
  }
  if (bits >= bitsPerChar || (255 & buffer2 << 8 - bits) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
function encode5(data, alphabet7, bitsPerChar) {
  const pad = alphabet7[alphabet7.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer2 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer2 = buffer2 << 8 | data[i];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet7[mask & buffer2 >> bits];
    }
  }
  if (bits !== 0) {
    out += alphabet7[mask & buffer2 << bitsPerChar - bits];
  }
  if (pad) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
function createAlphabetIdx2(alphabet7) {
  const alphabetIdx = {};
  for (let i = 0; i < alphabet7.length; ++i) {
    alphabetIdx[alphabet7[i]] = i;
  }
  return alphabetIdx;
}
function rfc46482({ name: name12, prefix, bitsPerChar, alphabet: alphabet7 }) {
  const alphabetIdx = createAlphabetIdx2(alphabet7);
  return from2({
    prefix,
    name: name12,
    encode(input) {
      return encode5(input, alphabet7, bitsPerChar);
    },
    decode(input) {
      return decode7(input, alphabetIdx, bitsPerChar, name12);
    }
  });
}

// node_modules/@ipld/dag-cbor/node_modules/multiformats/dist/src/bases/base32.js
var base322 = rfc46482({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper2 = rfc46482({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad2 = rfc46482({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper2 = rfc46482({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex2 = rfc46482({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper2 = rfc46482({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad2 = rfc46482({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper2 = rfc46482({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z2 = rfc46482({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@ipld/dag-cbor/node_modules/multiformats/dist/src/bases/base36.js
var base362 = baseX2({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper2 = baseX2({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/@ipld/dag-cbor/node_modules/multiformats/dist/src/bases/base58.js
var base58btc2 = baseX2({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr2 = baseX2({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@ipld/dag-cbor/node_modules/multiformats/dist/src/vendor/varint.js
var encode_12 = encode6;
var MSB2 = 128;
var REST2 = 127;
var MSBALL2 = ~REST2;
var INT2 = Math.pow(2, 31);
function encode6(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT2) {
    out[offset++] = num & 255 | MSB2;
    num /= 128;
  }
  while (num & MSBALL2) {
    out[offset++] = num & 255 | MSB2;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode6.bytes = offset - oldOffset + 1;
  return out;
}
var decode8 = read2;
var MSB$12 = 128;
var REST$12 = 127;
function read2(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
  do {
    if (counter >= l) {
      read2.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf2[counter++];
    res += shift < 28 ? (b & REST$12) << shift : (b & REST$12) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$12);
  read2.bytes = counter - offset;
  return res;
}
var N12 = Math.pow(2, 7);
var N22 = Math.pow(2, 14);
var N32 = Math.pow(2, 21);
var N42 = Math.pow(2, 28);
var N52 = Math.pow(2, 35);
var N62 = Math.pow(2, 42);
var N72 = Math.pow(2, 49);
var N82 = Math.pow(2, 56);
var N92 = Math.pow(2, 63);
var length2 = function(value) {
  return value < N12 ? 1 : value < N22 ? 2 : value < N32 ? 3 : value < N42 ? 4 : value < N52 ? 5 : value < N62 ? 6 : value < N72 ? 7 : value < N82 ? 8 : value < N92 ? 9 : 10;
};
var varint2 = {
  encode: encode_12,
  decode: decode8,
  encodingLength: length2
};
var _brrp_varint2 = varint2;
var varint_default2 = _brrp_varint2;

// node_modules/@ipld/dag-cbor/node_modules/multiformats/dist/src/varint.js
function decode9(data, offset = 0) {
  const code12 = varint_default2.decode(data, offset);
  return [code12, varint_default2.decode.bytes];
}
function encodeTo2(int, target, offset = 0) {
  varint_default2.encode(int, target, offset);
  return target;
}
function encodingLength2(int) {
  return varint_default2.encodingLength(int);
}

// node_modules/@ipld/dag-cbor/node_modules/multiformats/dist/src/hashes/digest.js
function create2(code12, digest6) {
  const size = digest6.byteLength;
  const sizeOffset = encodingLength2(code12);
  const digestOffset = sizeOffset + encodingLength2(size);
  const bytes = new Uint8Array(digestOffset + size);
  encodeTo2(code12, bytes, 0);
  encodeTo2(size, bytes, sizeOffset);
  bytes.set(digest6, digestOffset);
  return new Digest2(code12, size, digest6, bytes);
}
function decode10(multihash) {
  const bytes = coerce2(multihash);
  const [code12, sizeOffset] = decode9(bytes);
  const [size, digestOffset] = decode9(bytes.subarray(sizeOffset));
  const digest6 = bytes.subarray(sizeOffset + digestOffset);
  if (digest6.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest2(code12, size, digest6, bytes);
}
function equals4(a, b) {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals3(a.bytes, data.bytes);
  }
}
var Digest2 = class {
  code;
  size;
  digest;
  bytes;
  /**
   * Creates a multihash digest.
   */
  constructor(code12, size, digest6, bytes) {
    this.code = code12;
    this.size = size;
    this.digest = digest6;
    this.bytes = bytes;
  }
};

// node_modules/@ipld/dag-cbor/node_modules/multiformats/dist/src/cid.js
function format2(link, base14) {
  const { bytes, version } = link;
  switch (version) {
    case 0:
      return toStringV02(bytes, baseCache2(link), base14 ?? base58btc2.encoder);
    default:
      return toStringV12(bytes, baseCache2(link), base14 ?? base322.encoder);
  }
}
var cache2 = /* @__PURE__ */ new WeakMap();
function baseCache2(cid) {
  const baseCache11 = cache2.get(cid);
  if (baseCache11 == null) {
    const baseCache12 = /* @__PURE__ */ new Map();
    cache2.set(cid, baseCache12);
    return baseCache12;
  }
  return baseCache11;
}
var CID2 = class _CID {
  code;
  version;
  multihash;
  bytes;
  "/";
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param multihash - (Multi)hash of the of the content.
   */
  constructor(version, code12, multihash, bytes) {
    this.code = code12;
    this.version = version;
    this.multihash = multihash;
    this.bytes = bytes;
    this["/"] = bytes;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code12, multihash } = this;
        if (code12 !== DAG_PB_CODE2) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE2) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return _CID.createV0(multihash);
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code12, digest: digest6 } = this.multihash;
        const multihash = create2(code12, digest6);
        return _CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return _CID.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals4(self2.multihash, unknown.multihash);
  }
  toString(base14) {
    return format2(this, base14);
  }
  toJSON() {
    return { "/": format2(this) };
  }
  link() {
    return this;
  }
  [Symbol.toStringTag] = "CID";
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value = input;
    if (value instanceof _CID) {
      return value;
    } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
      const { version, code: code12, multihash, bytes } = value;
      return new _CID(version, code12, multihash, bytes ?? encodeCID2(version, code12, multihash.bytes));
    } else if (value[cidSymbol2] === true) {
      const { version, multihash, code: code12 } = value;
      const digest6 = decode10(multihash);
      return _CID.create(version, code12, digest6);
    } else {
      return null;
    }
  }
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param digest - (Multi)hash of the of the content.
   */
  static create(version, code12, digest6) {
    if (typeof code12 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest6.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version) {
      case 0: {
        if (code12 !== DAG_PB_CODE2) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE2}) block encoding`);
        } else {
          return new _CID(version, code12, digest6, digest6.bytes);
        }
      }
      case 1: {
        const bytes = encodeCID2(version, code12, digest6.bytes);
        return new _CID(version, code12, digest6, bytes);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   */
  static createV0(digest6) {
    return _CID.create(0, DAG_PB_CODE2, digest6);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @param code - Content encoding format code.
   * @param digest - Multihash of the content.
   */
  static createV1(code12, digest6) {
    return _CID.create(1, code12, digest6);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   */
  static decode(bytes) {
    const [cid, remainder] = _CID.decodeFirst(bytes);
    if (remainder.length !== 0) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   */
  static decodeFirst(bytes) {
    const specs = _CID.inspectBytes(bytes);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce2(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest6 = new Digest2(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? _CID.createV0(digest6) : _CID.createV1(specs.codec, digest6);
    return [cid, bytes.subarray(specs.size)];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i, length11] = decode9(initialBytes.subarray(offset));
      offset += length11;
      return i;
    };
    let version = next();
    let codec = DAG_PB_CODE2;
    if (version === 18) {
      version = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version !== 0 && version !== 1) {
      throw new RangeError(`Invalid CID version ${version}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   */
  static parse(source, base14) {
    const [prefix, bytes] = parseCIDtoBytes2(source, base14);
    const cid = _CID.decode(bytes);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache2(cid).set(prefix, source);
    return cid;
  }
};
function parseCIDtoBytes2(source, base14) {
  switch (source[0]) {
    // CIDv0 is parsed differently
    case "Q": {
      const decoder = base14 ?? base58btc2;
      return [
        base58btc2.prefix,
        decoder.decode(`${base58btc2.prefix}${source}`)
      ];
    }
    case base58btc2.prefix: {
      const decoder = base14 ?? base58btc2;
      return [base58btc2.prefix, decoder.decode(source)];
    }
    case base322.prefix: {
      const decoder = base14 ?? base322;
      return [base322.prefix, decoder.decode(source)];
    }
    case base362.prefix: {
      const decoder = base14 ?? base362;
      return [base362.prefix, decoder.decode(source)];
    }
    default: {
      if (base14 == null) {
        throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");
      }
      return [source[0], base14.decode(source)];
    }
  }
}
function toStringV02(bytes, cache11, base14) {
  const { prefix } = base14;
  if (prefix !== base58btc2.prefix) {
    throw Error(`Cannot string encode V0 in ${base14.name} encoding`);
  }
  const cid = cache11.get(prefix);
  if (cid == null) {
    const cid2 = base14.encode(bytes).slice(1);
    cache11.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
function toStringV12(bytes, cache11, base14) {
  const { prefix } = base14;
  const cid = cache11.get(prefix);
  if (cid == null) {
    const cid2 = base14.encode(bytes);
    cache11.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
var DAG_PB_CODE2 = 112;
var SHA_256_CODE2 = 18;
function encodeCID2(version, code12, multihash) {
  const codeOffset = encodingLength2(version);
  const hashOffset = codeOffset + encodingLength2(code12);
  const bytes = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo2(version, bytes, 0);
  encodeTo2(code12, bytes, codeOffset);
  bytes.set(multihash, hashOffset);
  return bytes;
}
var cidSymbol2 = Symbol.for("@ipld/js-cid/CID");

// node_modules/@ipld/dag-cbor/src/index.js
var CID_CBOR_TAG = 42;
function toByteView2(buf2) {
  if (buf2 instanceof ArrayBuffer) {
    return new Uint8Array(buf2, 0, buf2.byteLength);
  }
  return buf2;
}
function cidEncoder(obj) {
  if (obj.asCID !== obj && obj["/"] !== obj.bytes) {
    return null;
  }
  const cid = CID2.asCID(obj);
  if (!cid) {
    return null;
  }
  const bytes = new Uint8Array(cid.bytes.byteLength + 1);
  bytes.set(cid.bytes, 1);
  return [
    new Token(Type.tag, CID_CBOR_TAG),
    new Token(Type.bytes, bytes)
  ];
}
function undefinedEncoder() {
  throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
}
function numberEncoder(num) {
  if (Number.isNaN(num)) {
    throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
  }
  if (num === Infinity || num === -Infinity) {
    throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
  }
  return null;
}
function mapEncoder(map2) {
  for (const key of map2.keys()) {
    if (typeof key !== "string" || key.length === 0) {
      throw new Error("Non-string Map keys are not supported by the IPLD Data Model and cannot be encoded");
    }
  }
  return null;
}
var _encodeOptions = {
  float64: true,
  typeEncoders: {
    Map: mapEncoder,
    Object: cidEncoder,
    undefined: undefinedEncoder,
    number: numberEncoder
  }
};
var encodeOptions = {
  ..._encodeOptions,
  typeEncoders: {
    ..._encodeOptions.typeEncoders
  }
};
function cidDecoder(bytes) {
  if (bytes[0] !== 0) {
    throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");
  }
  return CID2.decode(bytes.subarray(1));
}
var _decodeOptions = {
  allowIndefinite: false,
  coerceUndefinedToNull: true,
  allowNaN: false,
  allowInfinity: false,
  allowBigInt: true,
  // this will lead to BigInt for ints outside of
  // safe-integer range, which may surprise users
  strict: true,
  useMaps: false,
  rejectDuplicateMapKeys: true,
  /** @type {import('cborg').TagDecoder[]} */
  tags: []
};
_decodeOptions.tags[CID_CBOR_TAG] = cidDecoder;
var decodeOptions = {
  ..._decodeOptions,
  tags: _decodeOptions.tags.slice()
};
var name2 = "dag-cbor";
var code2 = 113;
var encode7 = (node) => encode4(node, _encodeOptions);
var decode11 = (data) => decode6(toByteView2(data), _decodeOptions);

// node_modules/@ipld/dag-json/src/index.js
var src_exports3 = {};
__export(src_exports3, {
  code: () => code3,
  decode: () => decode17,
  encode: () => encode11,
  format: () => format4,
  name: () => name3,
  parse: () => parse,
  stringify: () => format4
});

// node_modules/cborg/lib/json/encode.js
var JSONEncoder = class extends Array {
  constructor() {
    super();
    this.inRecursive = [];
  }
  /**
   * @param {Bl} buf
   */
  prefix(buf2) {
    const recurs = this.inRecursive[this.inRecursive.length - 1];
    if (recurs) {
      if (recurs.type === Type.array) {
        recurs.elements++;
        if (recurs.elements !== 1) {
          buf2.push([44]);
        }
      }
      if (recurs.type === Type.map) {
        recurs.elements++;
        if (recurs.elements !== 1) {
          if (recurs.elements % 2 === 1) {
            buf2.push([44]);
          } else {
            buf2.push([58]);
          }
        }
      }
    }
  }
  /**
   * @param {Bl} buf
   * @param {Token} token
   */
  [Type.uint.major](buf2, token) {
    this.prefix(buf2);
    const is2 = String(token.value);
    const isa = [];
    for (let i = 0; i < is2.length; i++) {
      isa[i] = is2.charCodeAt(i);
    }
    buf2.push(isa);
  }
  /**
   * @param {Bl} buf
   * @param {Token} token
   */
  [Type.negint.major](buf2, token) {
    this[Type.uint.major](buf2, token);
  }
  /**
   * @param {Bl} _buf
   * @param {Token} _token
   */
  [Type.bytes.major](_buf, _token) {
    throw new Error(`${encodeErrPrefix} unsupported type: Uint8Array`);
  }
  /**
   * @param {Bl} buf
   * @param {Token} token
   */
  [Type.string.major](buf2, token) {
    this.prefix(buf2);
    const byts = fromString(JSON.stringify(token.value));
    buf2.push(byts.length > 32 ? asU8A(byts) : byts);
  }
  /**
   * @param {Bl} buf
   * @param {Token} _token
   */
  [Type.array.major](buf2, _token) {
    this.prefix(buf2);
    this.inRecursive.push({ type: Type.array, elements: 0 });
    buf2.push([91]);
  }
  /**
   * @param {Bl} buf
   * @param {Token} _token
   */
  [Type.map.major](buf2, _token) {
    this.prefix(buf2);
    this.inRecursive.push({ type: Type.map, elements: 0 });
    buf2.push([123]);
  }
  /**
   * @param {Bl} _buf
   * @param {Token} _token
   */
  [Type.tag.major](_buf, _token) {
  }
  /**
   * @param {Bl} buf
   * @param {Token} token
   */
  [Type.float.major](buf2, token) {
    if (token.type.name === "break") {
      const recurs = this.inRecursive.pop();
      if (recurs) {
        if (recurs.type === Type.array) {
          buf2.push([93]);
        } else if (recurs.type === Type.map) {
          buf2.push([125]);
        } else {
          throw new Error("Unexpected recursive type; this should not happen!");
        }
        return;
      }
      throw new Error("Unexpected break; this should not happen!");
    }
    if (token.value === void 0) {
      throw new Error(`${encodeErrPrefix} unsupported type: undefined`);
    }
    this.prefix(buf2);
    if (token.type.name === "true") {
      buf2.push([116, 114, 117, 101]);
      return;
    } else if (token.type.name === "false") {
      buf2.push([102, 97, 108, 115, 101]);
      return;
    } else if (token.type.name === "null") {
      buf2.push([110, 117, 108, 108]);
      return;
    }
    const is2 = String(token.value);
    const isa = [];
    let dp = false;
    for (let i = 0; i < is2.length; i++) {
      isa[i] = is2.charCodeAt(i);
      if (!dp && (isa[i] === 46 || isa[i] === 101 || isa[i] === 69)) {
        dp = true;
      }
    }
    if (!dp) {
      isa.push(46);
      isa.push(48);
    }
    buf2.push(isa);
  }
};
function mapSorter2(e1, e2) {
  if (Array.isArray(e1[0]) || Array.isArray(e2[0])) {
    throw new Error(`${encodeErrPrefix} complex map keys are not supported`);
  }
  const keyToken1 = e1[0];
  const keyToken2 = e2[0];
  if (keyToken1.type !== Type.string || keyToken2.type !== Type.string) {
    throw new Error(`${encodeErrPrefix} non-string map keys are not supported`);
  }
  if (keyToken1 < keyToken2) {
    return -1;
  }
  if (keyToken1 > keyToken2) {
    return 1;
  }
  throw new Error(`${encodeErrPrefix} unexpected duplicate map keys, this is not supported`);
}
var defaultEncodeOptions2 = { addBreakTokens: true, mapSorter: mapSorter2 };
function encode8(data, options) {
  options = Object.assign({}, defaultEncodeOptions2, options);
  return encodeCustom(data, new JSONEncoder(), options);
}

// node_modules/cborg/lib/json/decode.js
var Tokenizer = class {
  /**
   * @param {Uint8Array} data
   * @param {DecodeOptions} options
   */
  constructor(data, options = {}) {
    this._pos = 0;
    this.data = data;
    this.options = options;
    this.modeStack = ["value"];
    this.lastToken = "";
  }
  pos() {
    return this._pos;
  }
  /**
   * @returns {boolean}
   */
  done() {
    return this._pos >= this.data.length;
  }
  /**
   * @returns {number}
   */
  ch() {
    return this.data[this._pos];
  }
  /**
   * @returns {string}
   */
  currentMode() {
    return this.modeStack[this.modeStack.length - 1];
  }
  skipWhitespace() {
    let c = this.ch();
    while (c === 32 || c === 9 || c === 13 || c === 10) {
      c = this.data[++this._pos];
    }
  }
  /**
   * @param {number[]} str
   */
  expect(str) {
    if (this.data.length - this._pos < str.length) {
      throw new Error(`${decodeErrPrefix} unexpected end of input at position ${this._pos}`);
    }
    for (let i = 0; i < str.length; i++) {
      if (this.data[this._pos++] !== str[i]) {
        throw new Error(`${decodeErrPrefix} unexpected token at position ${this._pos}, expected to find '${String.fromCharCode(...str)}'`);
      }
    }
  }
  parseNumber() {
    const startPos = this._pos;
    let negative = false;
    let float = false;
    const swallow = (chars) => {
      while (!this.done()) {
        const ch = this.ch();
        if (chars.includes(ch)) {
          this._pos++;
        } else {
          break;
        }
      }
    };
    if (this.ch() === 45) {
      negative = true;
      this._pos++;
    }
    if (this.ch() === 48) {
      this._pos++;
      if (this.ch() === 46) {
        this._pos++;
        float = true;
      } else {
        return new Token(Type.uint, 0, this._pos - startPos);
      }
    }
    swallow([48, 49, 50, 51, 52, 53, 54, 55, 56, 57]);
    if (negative && this._pos === startPos + 1) {
      throw new Error(`${decodeErrPrefix} unexpected token at position ${this._pos}`);
    }
    if (!this.done() && this.ch() === 46) {
      if (float) {
        throw new Error(`${decodeErrPrefix} unexpected token at position ${this._pos}`);
      }
      float = true;
      this._pos++;
      swallow([48, 49, 50, 51, 52, 53, 54, 55, 56, 57]);
    }
    if (!this.done() && (this.ch() === 101 || this.ch() === 69)) {
      float = true;
      this._pos++;
      if (!this.done() && (this.ch() === 43 || this.ch() === 45)) {
        this._pos++;
      }
      swallow([48, 49, 50, 51, 52, 53, 54, 55, 56, 57]);
    }
    const numStr = String.fromCharCode.apply(null, this.data.subarray(startPos, this._pos));
    const num = parseFloat(numStr);
    if (float) {
      return new Token(Type.float, num, this._pos - startPos);
    }
    if (this.options.allowBigInt !== true || Number.isSafeInteger(num)) {
      return new Token(num >= 0 ? Type.uint : Type.negint, num, this._pos - startPos);
    }
    return new Token(num >= 0 ? Type.uint : Type.negint, BigInt(numStr), this._pos - startPos);
  }
  /**
   * @returns {Token}
   */
  parseString() {
    if (this.ch() !== 34) {
      throw new Error(`${decodeErrPrefix} unexpected character at position ${this._pos}; this shouldn't happen`);
    }
    this._pos++;
    for (let i = this._pos, l = 0; i < this.data.length && l < 65536; i++, l++) {
      const ch = this.data[i];
      if (ch === 92 || ch < 32 || ch >= 128) {
        break;
      }
      if (ch === 34) {
        const str = String.fromCharCode.apply(null, this.data.subarray(this._pos, i));
        this._pos = i + 1;
        return new Token(Type.string, str, l);
      }
    }
    const startPos = this._pos;
    const chars = [];
    const readu4 = () => {
      if (this._pos + 4 >= this.data.length) {
        throw new Error(`${decodeErrPrefix} unexpected end of unicode escape sequence at position ${this._pos}`);
      }
      let u4 = 0;
      for (let i = 0; i < 4; i++) {
        let ch = this.ch();
        if (ch >= 48 && ch <= 57) {
          ch -= 48;
        } else if (ch >= 97 && ch <= 102) {
          ch = ch - 97 + 10;
        } else if (ch >= 65 && ch <= 70) {
          ch = ch - 65 + 10;
        } else {
          throw new Error(`${decodeErrPrefix} unexpected unicode escape character at position ${this._pos}`);
        }
        u4 = u4 * 16 + ch;
        this._pos++;
      }
      return u4;
    };
    const readUtf8Char = () => {
      const firstByte = this.ch();
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (this._pos + bytesPerSequence > this.data.length) {
        throw new Error(`${decodeErrPrefix} unexpected unicode sequence at position ${this._pos}`);
      }
      let secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        /* c8 ignore next 6 */
        // this case is dealt with by the caller function
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = this.data[this._pos + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = this.data[this._pos + 1];
          thirdByte = this.data[this._pos + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = this.data[this._pos + 1];
          thirdByte = this.data[this._pos + 2];
          fourthByte = this.data[this._pos + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        chars.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      chars.push(codePoint);
      this._pos += bytesPerSequence;
    };
    while (!this.done()) {
      const ch = this.ch();
      let ch1;
      switch (ch) {
        case 92:
          this._pos++;
          if (this.done()) {
            throw new Error(`${decodeErrPrefix} unexpected string termination at position ${this._pos}`);
          }
          ch1 = this.ch();
          this._pos++;
          switch (ch1) {
            case 34:
            // '"'
            case 39:
            // '\''
            case 92:
            // '\'
            case 47:
              chars.push(ch1);
              break;
            case 98:
              chars.push(8);
              break;
            case 116:
              chars.push(9);
              break;
            case 110:
              chars.push(10);
              break;
            case 102:
              chars.push(12);
              break;
            case 114:
              chars.push(13);
              break;
            case 117:
              chars.push(readu4());
              break;
            default:
              throw new Error(`${decodeErrPrefix} unexpected string escape character at position ${this._pos}`);
          }
          break;
        case 34:
          this._pos++;
          return new Token(Type.string, decodeCodePointsArray(chars), this._pos - startPos);
        default:
          if (ch < 32) {
            throw new Error(`${decodeErrPrefix} invalid control character at position ${this._pos}`);
          } else if (ch < 128) {
            chars.push(ch);
            this._pos++;
          } else {
            readUtf8Char();
          }
      }
    }
    throw new Error(`${decodeErrPrefix} unexpected end of string at position ${this._pos}`);
  }
  /**
   * @returns {Token}
   */
  parseValue() {
    switch (this.ch()) {
      case 123:
        this.modeStack.push("obj-start");
        this._pos++;
        return new Token(Type.map, Infinity, 1);
      case 91:
        this.modeStack.push("array-start");
        this._pos++;
        return new Token(Type.array, Infinity, 1);
      case 34: {
        return this.parseString();
      }
      case 110:
        this.expect([110, 117, 108, 108]);
        return new Token(Type.null, null, 4);
      case 102:
        this.expect([102, 97, 108, 115, 101]);
        return new Token(Type.false, false, 5);
      case 116:
        this.expect([116, 114, 117, 101]);
        return new Token(Type.true, true, 4);
      case 45:
      // '-'
      case 48:
      // '0'
      case 49:
      // '1'
      case 50:
      // '2'
      case 51:
      // '3'
      case 52:
      // '4'
      case 53:
      // '5'
      case 54:
      // '6'
      case 55:
      // '7'
      case 56:
      // '8'
      case 57:
        return this.parseNumber();
      default:
        throw new Error(`${decodeErrPrefix} unexpected character at position ${this._pos}`);
    }
  }
  /**
   * @returns {Token}
   */
  next() {
    this.skipWhitespace();
    switch (this.currentMode()) {
      case "value":
        this.modeStack.pop();
        return this.parseValue();
      case "array-value": {
        this.modeStack.pop();
        if (this.ch() === 93) {
          this._pos++;
          this.skipWhitespace();
          return new Token(Type.break, void 0, 1);
        }
        if (this.ch() !== 44) {
          throw new Error(`${decodeErrPrefix} unexpected character at position ${this._pos}, was expecting array delimiter but found '${String.fromCharCode(this.ch())}'`);
        }
        this._pos++;
        this.modeStack.push("array-value");
        this.skipWhitespace();
        return this.parseValue();
      }
      case "array-start": {
        this.modeStack.pop();
        if (this.ch() === 93) {
          this._pos++;
          this.skipWhitespace();
          return new Token(Type.break, void 0, 1);
        }
        this.modeStack.push("array-value");
        this.skipWhitespace();
        return this.parseValue();
      }
      // @ts-ignore
      case "obj-key":
        if (this.ch() === 125) {
          this.modeStack.pop();
          this._pos++;
          this.skipWhitespace();
          return new Token(Type.break, void 0, 1);
        }
        if (this.ch() !== 44) {
          throw new Error(`${decodeErrPrefix} unexpected character at position ${this._pos}, was expecting object delimiter but found '${String.fromCharCode(this.ch())}'`);
        }
        this._pos++;
        this.skipWhitespace();
      case "obj-start": {
        this.modeStack.pop();
        if (this.ch() === 125) {
          this._pos++;
          this.skipWhitespace();
          return new Token(Type.break, void 0, 1);
        }
        const token = this.parseString();
        this.skipWhitespace();
        if (this.ch() !== 58) {
          throw new Error(`${decodeErrPrefix} unexpected character at position ${this._pos}, was expecting key/value delimiter ':' but found '${String.fromCharCode(this.ch())}'`);
        }
        this._pos++;
        this.modeStack.push("obj-value");
        return token;
      }
      case "obj-value": {
        this.modeStack.pop();
        this.modeStack.push("obj-key");
        this.skipWhitespace();
        return this.parseValue();
      }
      /* c8 ignore next 2 */
      default:
        throw new Error(`${decodeErrPrefix} unexpected parse state at position ${this._pos}; this shouldn't happen`);
    }
  }
};
function decode12(data, options) {
  options = Object.assign({ tokenizer: new Tokenizer(data, options) }, options);
  return decode6(data, options);
}

// node_modules/@ipld/dag-json/node_modules/multiformats/dist/src/bytes.js
var empty3 = new Uint8Array(0);
function equals5(aa, bb) {
  if (aa === bb) {
    return true;
  }
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}
function coerce3(o) {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array") {
    return o;
  }
  if (o instanceof ArrayBuffer) {
    return new Uint8Array(o);
  }
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}

// node_modules/@ipld/dag-json/node_modules/multiformats/dist/src/vendor/base-x.js
function base3(ALPHABET, name12) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode42(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length11 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length11) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length11 = i2;
      pbegin++;
    }
    var it2 = size - length11;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length11 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length11) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length11 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length11;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode58(string3) {
    var buffer2 = decodeUnsafe(string3);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name12} character`);
  }
  return {
    encode: encode42,
    decodeUnsafe,
    decode: decode58
  };
}
var src3 = base3;
var _brrp__multiformats_scope_baseX3 = src3;
var base_x_default3 = _brrp__multiformats_scope_baseX3;

// node_modules/@ipld/dag-json/node_modules/multiformats/dist/src/bases/base.js
var Encoder3 = class {
  name;
  prefix;
  baseEncode;
  constructor(name12, prefix, baseEncode) {
    this.name = name12;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes) {
    if (bytes instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder3 = class {
  name;
  prefix;
  baseDecode;
  prefixCodePoint;
  constructor(name12, prefix, baseDecode) {
    this.name = name12;
    this.prefix = prefix;
    const prefixCodePoint = prefix.codePointAt(0);
    if (prefixCodePoint === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefixCodePoint;
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or3(this, decoder);
  }
};
var ComposedDecoder3 = class {
  decoders;
  constructor(decoders3) {
    this.decoders = decoders3;
  }
  or(decoder) {
    return or3(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder != null) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
function or3(left, right) {
  return new ComposedDecoder3({
    ...left.decoders ?? { [left.prefix]: left },
    ...right.decoders ?? { [right.prefix]: right }
  });
}
var Codec3 = class {
  name;
  prefix;
  baseEncode;
  baseDecode;
  encoder;
  decoder;
  constructor(name12, prefix, baseEncode, baseDecode) {
    this.name = name12;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder3(name12, prefix, baseEncode);
    this.decoder = new Decoder3(name12, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
function from3({ name: name12, prefix, encode: encode42, decode: decode58 }) {
  return new Codec3(name12, prefix, encode42, decode58);
}
function baseX3({ name: name12, prefix, alphabet: alphabet7 }) {
  const { encode: encode42, decode: decode58 } = base_x_default3(alphabet7, name12);
  return from3({
    prefix,
    name: name12,
    encode: encode42,
    decode: (text) => coerce3(decode58(text))
  });
}
function decode13(string3, alphabetIdx, bitsPerChar, name12) {
  let end = string3.length;
  while (string3[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = alphabetIdx[string3[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name12} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer2 >> bits;
    }
  }
  if (bits >= bitsPerChar || (255 & buffer2 << 8 - bits) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
function encode9(data, alphabet7, bitsPerChar) {
  const pad = alphabet7[alphabet7.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer2 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer2 = buffer2 << 8 | data[i];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet7[mask & buffer2 >> bits];
    }
  }
  if (bits !== 0) {
    out += alphabet7[mask & buffer2 << bitsPerChar - bits];
  }
  if (pad) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
function createAlphabetIdx3(alphabet7) {
  const alphabetIdx = {};
  for (let i = 0; i < alphabet7.length; ++i) {
    alphabetIdx[alphabet7[i]] = i;
  }
  return alphabetIdx;
}
function rfc46483({ name: name12, prefix, bitsPerChar, alphabet: alphabet7 }) {
  const alphabetIdx = createAlphabetIdx3(alphabet7);
  return from3({
    prefix,
    name: name12,
    encode(input) {
      return encode9(input, alphabet7, bitsPerChar);
    },
    decode(input) {
      return decode13(input, alphabetIdx, bitsPerChar, name12);
    }
  });
}

// node_modules/@ipld/dag-json/node_modules/multiformats/dist/src/bases/base32.js
var base323 = rfc46483({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper3 = rfc46483({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad3 = rfc46483({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper3 = rfc46483({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex3 = rfc46483({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper3 = rfc46483({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad3 = rfc46483({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper3 = rfc46483({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z3 = rfc46483({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@ipld/dag-json/node_modules/multiformats/dist/src/bases/base36.js
var base363 = baseX3({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper3 = baseX3({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/@ipld/dag-json/node_modules/multiformats/dist/src/bases/base58.js
var base58btc3 = baseX3({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr3 = baseX3({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@ipld/dag-json/node_modules/multiformats/dist/src/vendor/varint.js
var encode_13 = encode10;
var MSB3 = 128;
var REST3 = 127;
var MSBALL3 = ~REST3;
var INT3 = Math.pow(2, 31);
function encode10(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT3) {
    out[offset++] = num & 255 | MSB3;
    num /= 128;
  }
  while (num & MSBALL3) {
    out[offset++] = num & 255 | MSB3;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode10.bytes = offset - oldOffset + 1;
  return out;
}
var decode14 = read3;
var MSB$13 = 128;
var REST$13 = 127;
function read3(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
  do {
    if (counter >= l) {
      read3.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf2[counter++];
    res += shift < 28 ? (b & REST$13) << shift : (b & REST$13) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$13);
  read3.bytes = counter - offset;
  return res;
}
var N13 = Math.pow(2, 7);
var N23 = Math.pow(2, 14);
var N33 = Math.pow(2, 21);
var N43 = Math.pow(2, 28);
var N53 = Math.pow(2, 35);
var N63 = Math.pow(2, 42);
var N73 = Math.pow(2, 49);
var N83 = Math.pow(2, 56);
var N93 = Math.pow(2, 63);
var length3 = function(value) {
  return value < N13 ? 1 : value < N23 ? 2 : value < N33 ? 3 : value < N43 ? 4 : value < N53 ? 5 : value < N63 ? 6 : value < N73 ? 7 : value < N83 ? 8 : value < N93 ? 9 : 10;
};
var varint3 = {
  encode: encode_13,
  decode: decode14,
  encodingLength: length3
};
var _brrp_varint3 = varint3;
var varint_default3 = _brrp_varint3;

// node_modules/@ipld/dag-json/node_modules/multiformats/dist/src/varint.js
function decode15(data, offset = 0) {
  const code12 = varint_default3.decode(data, offset);
  return [code12, varint_default3.decode.bytes];
}
function encodeTo3(int, target, offset = 0) {
  varint_default3.encode(int, target, offset);
  return target;
}
function encodingLength3(int) {
  return varint_default3.encodingLength(int);
}

// node_modules/@ipld/dag-json/node_modules/multiformats/dist/src/hashes/digest.js
function create3(code12, digest6) {
  const size = digest6.byteLength;
  const sizeOffset = encodingLength3(code12);
  const digestOffset = sizeOffset + encodingLength3(size);
  const bytes = new Uint8Array(digestOffset + size);
  encodeTo3(code12, bytes, 0);
  encodeTo3(size, bytes, sizeOffset);
  bytes.set(digest6, digestOffset);
  return new Digest3(code12, size, digest6, bytes);
}
function decode16(multihash) {
  const bytes = coerce3(multihash);
  const [code12, sizeOffset] = decode15(bytes);
  const [size, digestOffset] = decode15(bytes.subarray(sizeOffset));
  const digest6 = bytes.subarray(sizeOffset + digestOffset);
  if (digest6.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest3(code12, size, digest6, bytes);
}
function equals6(a, b) {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals5(a.bytes, data.bytes);
  }
}
var Digest3 = class {
  code;
  size;
  digest;
  bytes;
  /**
   * Creates a multihash digest.
   */
  constructor(code12, size, digest6, bytes) {
    this.code = code12;
    this.size = size;
    this.digest = digest6;
    this.bytes = bytes;
  }
};

// node_modules/@ipld/dag-json/node_modules/multiformats/dist/src/cid.js
function format3(link, base14) {
  const { bytes, version } = link;
  switch (version) {
    case 0:
      return toStringV03(bytes, baseCache3(link), base14 ?? base58btc3.encoder);
    default:
      return toStringV13(bytes, baseCache3(link), base14 ?? base323.encoder);
  }
}
var cache3 = /* @__PURE__ */ new WeakMap();
function baseCache3(cid) {
  const baseCache11 = cache3.get(cid);
  if (baseCache11 == null) {
    const baseCache12 = /* @__PURE__ */ new Map();
    cache3.set(cid, baseCache12);
    return baseCache12;
  }
  return baseCache11;
}
var CID3 = class _CID {
  code;
  version;
  multihash;
  bytes;
  "/";
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param multihash - (Multi)hash of the of the content.
   */
  constructor(version, code12, multihash, bytes) {
    this.code = code12;
    this.version = version;
    this.multihash = multihash;
    this.bytes = bytes;
    this["/"] = bytes;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code12, multihash } = this;
        if (code12 !== DAG_PB_CODE3) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE3) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return _CID.createV0(multihash);
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code12, digest: digest6 } = this.multihash;
        const multihash = create3(code12, digest6);
        return _CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return _CID.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals6(self2.multihash, unknown.multihash);
  }
  toString(base14) {
    return format3(this, base14);
  }
  toJSON() {
    return { "/": format3(this) };
  }
  link() {
    return this;
  }
  [Symbol.toStringTag] = "CID";
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value = input;
    if (value instanceof _CID) {
      return value;
    } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
      const { version, code: code12, multihash, bytes } = value;
      return new _CID(version, code12, multihash, bytes ?? encodeCID3(version, code12, multihash.bytes));
    } else if (value[cidSymbol3] === true) {
      const { version, multihash, code: code12 } = value;
      const digest6 = decode16(multihash);
      return _CID.create(version, code12, digest6);
    } else {
      return null;
    }
  }
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param digest - (Multi)hash of the of the content.
   */
  static create(version, code12, digest6) {
    if (typeof code12 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest6.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version) {
      case 0: {
        if (code12 !== DAG_PB_CODE3) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE3}) block encoding`);
        } else {
          return new _CID(version, code12, digest6, digest6.bytes);
        }
      }
      case 1: {
        const bytes = encodeCID3(version, code12, digest6.bytes);
        return new _CID(version, code12, digest6, bytes);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   */
  static createV0(digest6) {
    return _CID.create(0, DAG_PB_CODE3, digest6);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @param code - Content encoding format code.
   * @param digest - Multihash of the content.
   */
  static createV1(code12, digest6) {
    return _CID.create(1, code12, digest6);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   */
  static decode(bytes) {
    const [cid, remainder] = _CID.decodeFirst(bytes);
    if (remainder.length !== 0) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   */
  static decodeFirst(bytes) {
    const specs = _CID.inspectBytes(bytes);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce3(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest6 = new Digest3(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? _CID.createV0(digest6) : _CID.createV1(specs.codec, digest6);
    return [cid, bytes.subarray(specs.size)];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i, length11] = decode15(initialBytes.subarray(offset));
      offset += length11;
      return i;
    };
    let version = next();
    let codec = DAG_PB_CODE3;
    if (version === 18) {
      version = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version !== 0 && version !== 1) {
      throw new RangeError(`Invalid CID version ${version}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   */
  static parse(source, base14) {
    const [prefix, bytes] = parseCIDtoBytes3(source, base14);
    const cid = _CID.decode(bytes);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache3(cid).set(prefix, source);
    return cid;
  }
};
function parseCIDtoBytes3(source, base14) {
  switch (source[0]) {
    // CIDv0 is parsed differently
    case "Q": {
      const decoder = base14 ?? base58btc3;
      return [
        base58btc3.prefix,
        decoder.decode(`${base58btc3.prefix}${source}`)
      ];
    }
    case base58btc3.prefix: {
      const decoder = base14 ?? base58btc3;
      return [base58btc3.prefix, decoder.decode(source)];
    }
    case base323.prefix: {
      const decoder = base14 ?? base323;
      return [base323.prefix, decoder.decode(source)];
    }
    case base363.prefix: {
      const decoder = base14 ?? base363;
      return [base363.prefix, decoder.decode(source)];
    }
    default: {
      if (base14 == null) {
        throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");
      }
      return [source[0], base14.decode(source)];
    }
  }
}
function toStringV03(bytes, cache11, base14) {
  const { prefix } = base14;
  if (prefix !== base58btc3.prefix) {
    throw Error(`Cannot string encode V0 in ${base14.name} encoding`);
  }
  const cid = cache11.get(prefix);
  if (cid == null) {
    const cid2 = base14.encode(bytes).slice(1);
    cache11.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
function toStringV13(bytes, cache11, base14) {
  const { prefix } = base14;
  const cid = cache11.get(prefix);
  if (cid == null) {
    const cid2 = base14.encode(bytes);
    cache11.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
var DAG_PB_CODE3 = 112;
var SHA_256_CODE3 = 18;
function encodeCID3(version, code12, multihash) {
  const codeOffset = encodingLength3(version);
  const hashOffset = codeOffset + encodingLength3(code12);
  const bytes = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo3(version, bytes, 0);
  encodeTo3(code12, bytes, codeOffset);
  bytes.set(multihash, hashOffset);
  return bytes;
}
var cidSymbol3 = Symbol.for("@ipld/js-cid/CID");

// node_modules/@ipld/dag-json/node_modules/multiformats/dist/src/bases/base64.js
var base64 = rfc46483({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad = rfc46483({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url = rfc46483({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad = rfc46483({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/@ipld/dag-json/src/index.js
function toByteView3(buf2) {
  if (buf2 instanceof ArrayBuffer) {
    return new Uint8Array(buf2, 0, buf2.byteLength);
  }
  return buf2;
}
function cidEncoder2(obj) {
  if (obj.asCID !== obj && obj["/"] !== obj.bytes) {
    return null;
  }
  const cid = CID3.asCID(obj);
  if (!cid) {
    return null;
  }
  const cidString = cid.toString();
  return [
    new Token(Type.map, Infinity, 1),
    new Token(Type.string, "/", 1),
    // key
    new Token(Type.string, cidString, cidString.length),
    // value
    new Token(Type.break, void 0, 1)
  ];
}
function bytesEncoder(bytes) {
  const bytesString = base64.encode(bytes).slice(1);
  return [
    new Token(Type.map, Infinity, 1),
    new Token(Type.string, "/", 1),
    // key
    new Token(Type.map, Infinity, 1),
    // value
    new Token(Type.string, "bytes", 5),
    // inner key
    new Token(Type.string, bytesString, bytesString.length),
    // inner value
    new Token(Type.break, void 0, 1),
    new Token(Type.break, void 0, 1)
  ];
}
function taBytesEncoder(obj) {
  return bytesEncoder(new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));
}
function abBytesEncoder(ab) {
  return bytesEncoder(new Uint8Array(ab));
}
function undefinedEncoder2() {
  throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
}
function numberEncoder2(num) {
  if (Number.isNaN(num)) {
    throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
  }
  if (num === Infinity || num === -Infinity) {
    throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
  }
  return null;
}
var encodeOptions2 = {
  typeEncoders: {
    Object: cidEncoder2,
    Buffer: bytesEncoder,
    Uint8Array: bytesEncoder,
    Int8Array: taBytesEncoder,
    Uint16Array: taBytesEncoder,
    Int16Array: taBytesEncoder,
    Uint32Array: taBytesEncoder,
    Int32Array: taBytesEncoder,
    Float32Array: taBytesEncoder,
    Float64Array: taBytesEncoder,
    Uint8ClampedArray: taBytesEncoder,
    BigInt64Array: taBytesEncoder,
    BigUint64Array: taBytesEncoder,
    DataView: taBytesEncoder,
    ArrayBuffer: abBytesEncoder,
    undefined: undefinedEncoder2,
    number: numberEncoder2
  }
};
var DagJsonTokenizer = class extends Tokenizer {
  /**
   * @param {Uint8Array} data
   * @param {object} [options]
   */
  constructor(data, options) {
    super(data, options);
    this.tokenBuffer = [];
  }
  /**
   * @returns {boolean}
   */
  done() {
    return this.tokenBuffer.length === 0 && super.done();
  }
  /**
   * @returns {Token}
   */
  _next() {
    if (this.tokenBuffer.length > 0) {
      return this.tokenBuffer.pop();
    }
    return super.next();
  }
  /**
   * Implements rules outlined in https://github.com/ipld/specs/pull/356
   *
   * @returns {Token}
   */
  next() {
    const token = this._next();
    if (token.type === Type.map) {
      const keyToken = this._next();
      if (keyToken.type === Type.string && keyToken.value === "/") {
        const valueToken = this._next();
        if (valueToken.type === Type.string) {
          const breakToken = this._next();
          if (breakToken.type !== Type.break) {
            throw new Error("Invalid encoded CID form");
          }
          this.tokenBuffer.push(valueToken);
          return new Token(Type.tag, 42, 0);
        }
        if (valueToken.type === Type.map) {
          const innerKeyToken = this._next();
          if (innerKeyToken.type === Type.string && innerKeyToken.value === "bytes") {
            const innerValueToken = this._next();
            if (innerValueToken.type === Type.string) {
              for (let i = 0; i < 2; i++) {
                const breakToken = this._next();
                if (breakToken.type !== Type.break) {
                  throw new Error("Invalid encoded Bytes form");
                }
              }
              const bytes = base64.decode(`m${innerValueToken.value}`);
              return new Token(Type.bytes, bytes, innerValueToken.value.length);
            }
            this.tokenBuffer.push(innerValueToken);
          }
          this.tokenBuffer.push(innerKeyToken);
        }
        this.tokenBuffer.push(valueToken);
      }
      this.tokenBuffer.push(keyToken);
    }
    return token;
  }
};
var decodeOptions2 = {
  allowIndefinite: false,
  allowUndefined: false,
  allowNaN: false,
  allowInfinity: false,
  allowBigInt: true,
  // this will lead to BigInt for ints outside of
  // safe-integer range, which may surprise users
  strict: true,
  useMaps: false,
  rejectDuplicateMapKeys: true,
  /** @type {import('cborg').TagDecoder[]} */
  tags: []
};
decodeOptions2.tags[42] = CID3.parse;
var name3 = "dag-json";
var code3 = 297;
var encode11 = (node) => encode8(node, encodeOptions2);
var decode17 = (data) => {
  const buf2 = toByteView3(data);
  const options = Object.assign(decodeOptions2, { tokenizer: new DagJsonTokenizer(buf2, decodeOptions2) });
  return decode12(buf2, options);
};
var format4 = (node) => utf8Decoder.decode(encode11(node));
var utf8Decoder = new TextDecoder();
var parse = (data) => decode17(utf8Encoder.encode(data));
var utf8Encoder = new TextEncoder();

// node_modules/dag-jose/lib/index.js
var lib_exports = {};
__export(lib_exports, {
  code: () => code4,
  decode: () => decode24,
  encode: () => encode16,
  name: () => name4,
  toGeneral: () => toGeneral
});

// node_modules/dag-jose/node_modules/multiformats/vendor/base-x.js
function base4(ALPHABET, name12) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode42(source) {
    if (source instanceof Uint8Array) ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length11 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length11) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length11 = i2;
      pbegin++;
    }
    var it2 = size - length11;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length11 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length11) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length11 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length11;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode58(string3) {
    var buffer2 = decodeUnsafe(string3);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name12} character`);
  }
  return {
    encode: encode42,
    decodeUnsafe,
    decode: decode58
  };
}
var src4 = base4;
var _brrp__multiformats_scope_baseX4 = src4;
var base_x_default4 = _brrp__multiformats_scope_baseX4;

// node_modules/dag-jose/node_modules/multiformats/src/bytes.js
var empty4 = new Uint8Array(0);
var equals7 = (aa, bb) => {
  if (aa === bb) return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
};
var coerce4 = (o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array") return o;
  if (o instanceof ArrayBuffer) return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};

// node_modules/dag-jose/node_modules/multiformats/src/bases/base.js
var Encoder4 = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   */
  constructor(name12, prefix, baseEncode) {
    this.name = name12;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {API.Multibase<Prefix>}
   */
  encode(bytes) {
    if (bytes instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder4 = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name12, prefix, baseDecode) {
    this.name = name12;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = /** @type {number} */
    prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  /**
   * @param {string} text
   */
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or4(this, decoder);
  }
};
var ComposedDecoder4 = class {
  /**
   * @param {Decoders<Prefix>} decoders
   */
  constructor(decoders3) {
    this.decoders = decoders3;
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or4(this, decoder);
  }
  /**
   * @param {string} input
   * @returns {Uint8Array}
   */
  decode(input) {
    const prefix = (
      /** @type {Prefix} */
      input[0]
    );
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or4 = (left, right) => new ComposedDecoder4(
  /** @type {Decoders<L|R>} */
  {
    ...left.decoders || { [
      /** @type API.UnibaseDecoder<L> */
      left.prefix
    ]: left },
    ...right.decoders || { [
      /** @type API.UnibaseDecoder<R> */
      right.prefix
    ]: right }
  }
);
var Codec4 = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name12, prefix, baseEncode, baseDecode) {
    this.name = name12;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder4(name12, prefix, baseEncode);
    this.decoder = new Decoder4(name12, prefix, baseDecode);
  }
  /**
   * @param {Uint8Array} input
   */
  encode(input) {
    return this.encoder.encode(input);
  }
  /**
   * @param {string} input
   */
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from4 = ({ name: name12, prefix, encode: encode42, decode: decode58 }) => new Codec4(name12, prefix, encode42, decode58);
var baseX4 = ({ prefix, name: name12, alphabet: alphabet7 }) => {
  const { encode: encode42, decode: decode58 } = base_x_default4(alphabet7, name12);
  return from4({
    prefix,
    name: name12,
    encode: encode42,
    /**
     * @param {string} text
     */
    decode: (text) => coerce4(decode58(text))
  });
};
var decode18 = (string3, alphabet7, bitsPerChar, name12) => {
  const codes2 = {};
  for (let i = 0; i < alphabet7.length; ++i) {
    codes2[alphabet7[i]] = i;
  }
  let end = string3.length;
  while (string3[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes2[string3[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name12} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer2 >> bits;
    }
  }
  if (bits >= bitsPerChar || 255 & buffer2 << 8 - bits) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
var encode12 = (data, alphabet7, bitsPerChar) => {
  const pad = alphabet7[alphabet7.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer2 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer2 = buffer2 << 8 | data[i];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet7[mask & buffer2 >> bits];
    }
  }
  if (bits) {
    out += alphabet7[mask & buffer2 << bitsPerChar - bits];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
var rfc46484 = ({ name: name12, prefix, bitsPerChar, alphabet: alphabet7 }) => {
  return from4({
    prefix,
    name: name12,
    encode(input) {
      return encode12(input, alphabet7, bitsPerChar);
    },
    decode(input) {
      return decode18(input, alphabet7, bitsPerChar, name12);
    }
  });
};

// node_modules/dag-jose/node_modules/multiformats/src/bases/base64.js
var base642 = rfc46484({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad2 = rfc46484({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url2 = rfc46484({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad2 = rfc46484({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/dag-jose/lib/utils.js
function toBase64url(b) {
  return base64url2.encode(b).slice(1);
}
function fromBase64url(s) {
  return base64url2.decode(`u${s}`);
}

// node_modules/dag-jose/node_modules/multiformats/vendor/varint.js
var encode_14 = encode13;
var MSB4 = 128;
var REST4 = 127;
var MSBALL4 = ~REST4;
var INT4 = Math.pow(2, 31);
function encode13(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT4) {
    out[offset++] = num & 255 | MSB4;
    num /= 128;
  }
  while (num & MSBALL4) {
    out[offset++] = num & 255 | MSB4;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode13.bytes = offset - oldOffset + 1;
  return out;
}
var decode19 = read4;
var MSB$14 = 128;
var REST$14 = 127;
function read4(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
  do {
    if (counter >= l) {
      read4.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf2[counter++];
    res += shift < 28 ? (b & REST$14) << shift : (b & REST$14) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$14);
  read4.bytes = counter - offset;
  return res;
}
var N14 = Math.pow(2, 7);
var N24 = Math.pow(2, 14);
var N34 = Math.pow(2, 21);
var N44 = Math.pow(2, 28);
var N54 = Math.pow(2, 35);
var N64 = Math.pow(2, 42);
var N74 = Math.pow(2, 49);
var N84 = Math.pow(2, 56);
var N94 = Math.pow(2, 63);
var length4 = function(value) {
  return value < N14 ? 1 : value < N24 ? 2 : value < N34 ? 3 : value < N44 ? 4 : value < N54 ? 5 : value < N64 ? 6 : value < N74 ? 7 : value < N84 ? 8 : value < N94 ? 9 : 10;
};
var varint4 = {
  encode: encode_14,
  decode: decode19,
  encodingLength: length4
};
var _brrp_varint4 = varint4;
var varint_default4 = _brrp_varint4;

// node_modules/dag-jose/node_modules/multiformats/src/varint.js
var decode20 = (data, offset = 0) => {
  const code12 = varint_default4.decode(data, offset);
  return [code12, varint_default4.decode.bytes];
};
var encodeTo4 = (int, target, offset = 0) => {
  varint_default4.encode(int, target, offset);
  return target;
};
var encodingLength4 = (int) => {
  return varint_default4.encodingLength(int);
};

// node_modules/dag-jose/node_modules/multiformats/src/hashes/digest.js
var create4 = (code12, digest6) => {
  const size = digest6.byteLength;
  const sizeOffset = encodingLength4(code12);
  const digestOffset = sizeOffset + encodingLength4(size);
  const bytes = new Uint8Array(digestOffset + size);
  encodeTo4(code12, bytes, 0);
  encodeTo4(size, bytes, sizeOffset);
  bytes.set(digest6, digestOffset);
  return new Digest4(code12, size, digest6, bytes);
};
var decode21 = (multihash) => {
  const bytes = coerce4(multihash);
  const [code12, sizeOffset] = decode20(bytes);
  const [size, digestOffset] = decode20(bytes.subarray(sizeOffset));
  const digest6 = bytes.subarray(sizeOffset + digestOffset);
  if (digest6.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest4(code12, size, digest6, bytes);
};
var equals8 = (a, b) => {
  if (a === b) {
    return true;
  } else {
    const data = (
      /** @type {{code?:unknown, size?:unknown, bytes?:unknown}} */
      b
    );
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals7(a.bytes, data.bytes);
  }
};
var Digest4 = class {
  /**
   * Creates a multihash digest.
   *
   * @param {Code} code
   * @param {Size} size
   * @param {Uint8Array} digest
   * @param {Uint8Array} bytes
   */
  constructor(code12, size, digest6, bytes) {
    this.code = code12;
    this.size = size;
    this.digest = digest6;
    this.bytes = bytes;
  }
};

// node_modules/dag-jose/node_modules/multiformats/src/bases/base58.js
var base58btc4 = baseX4({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr4 = baseX4({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/dag-jose/node_modules/multiformats/src/bases/base32.js
var base324 = rfc46484({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper4 = rfc46484({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad4 = rfc46484({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper4 = rfc46484({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex4 = rfc46484({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper4 = rfc46484({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad4 = rfc46484({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper4 = rfc46484({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z4 = rfc46484({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/dag-jose/node_modules/multiformats/src/cid.js
var format5 = (link, base14) => {
  const { bytes, version } = link;
  switch (version) {
    case 0:
      return toStringV04(
        bytes,
        baseCache4(link),
        /** @type {API.MultibaseEncoder<"z">} */
        base14 || base58btc4.encoder
      );
    default:
      return toStringV14(
        bytes,
        baseCache4(link),
        /** @type {API.MultibaseEncoder<Prefix>} */
        base14 || base324.encoder
      );
  }
};
var cache4 = /* @__PURE__ */ new WeakMap();
var baseCache4 = (cid) => {
  const baseCache11 = cache4.get(cid);
  if (baseCache11 == null) {
    const baseCache12 = /* @__PURE__ */ new Map();
    cache4.set(cid, baseCache12);
    return baseCache12;
  }
  return baseCache11;
};
var CID4 = class _CID {
  /**
   * @param {Version} version - Version of the CID
   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.
   * @param {Uint8Array} bytes
   *
   */
  constructor(version, code12, multihash, bytes) {
    this.code = code12;
    this.version = version;
    this.multihash = multihash;
    this.bytes = bytes;
    this["/"] = bytes;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  /**
   * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}
   */
  toV0() {
    switch (this.version) {
      case 0: {
        return (
          /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
          this
        );
      }
      case 1: {
        const { code: code12, multihash } = this;
        if (code12 !== DAG_PB_CODE4) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE4) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return (
          /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
          _CID.createV0(
            /** @type {API.MultihashDigest<API.SHA_256>} */
            multihash
          )
        );
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 0. This is a bug please report`
        );
      }
    }
  }
  /**
   * @returns {CID<Data, Format, Alg, 1>}
   */
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code12, digest: digest6 } = this.multihash;
        const multihash = create4(code12, digest6);
        return (
          /** @type {CID<Data, Format, Alg, 1>} */
          _CID.createV1(this.code, multihash)
        );
      }
      case 1: {
        return (
          /** @type {CID<Data, Format, Alg, 1>} */
          this
        );
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 1. This is a bug please report`
        );
      }
    }
  }
  /**
   * @param {unknown} other
   * @returns {other is CID<Data, Format, Alg, Version>}
   */
  equals(other) {
    return _CID.equals(this, other);
  }
  /**
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @param {API.Link<Data, Format, Alg, Version>} self
   * @param {unknown} other
   * @returns {other is CID}
   */
  static equals(self2, other) {
    const unknown = (
      /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */
      other
    );
    return unknown && self2.code === unknown.code && self2.version === unknown.version && equals8(self2.multihash, unknown.multihash);
  }
  /**
   * @param {API.MultibaseEncoder<string>} [base]
   * @returns {string}
   */
  toString(base14) {
    return format5(this, base14);
  }
  toJSON() {
    return { "/": format5(this) };
  }
  link() {
    return this;
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   *
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @template {unknown} U
   * @param {API.Link<Data, Format, Alg, Version>|U} input
   * @returns {CID<Data, Format, Alg, Version>|null}
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value = (
      /** @type {any} */
      input
    );
    if (value instanceof _CID) {
      return value;
    } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
      const { version, code: code12, multihash, bytes } = value;
      return new _CID(
        version,
        code12,
        /** @type {API.MultihashDigest<Alg>} */
        multihash,
        bytes || encodeCID4(version, code12, multihash.bytes)
      );
    } else if (value[cidSymbol4] === true) {
      const { version, multihash, code: code12 } = value;
      const digest6 = (
        /** @type {API.MultihashDigest<Alg>} */
        decode21(multihash)
      );
      return _CID.create(version, code12, digest6);
    } else {
      return null;
    }
  }
  /**
   *
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @param {Version} version - Version of the CID
   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.
   * @returns {CID<Data, Format, Alg, Version>}
   */
  static create(version, code12, digest6) {
    if (typeof code12 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest6.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version) {
      case 0: {
        if (code12 !== DAG_PB_CODE4) {
          throw new Error(
            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE4}) block encoding`
          );
        } else {
          return new _CID(version, code12, digest6, digest6.bytes);
        }
      }
      case 1: {
        const bytes = encodeCID4(version, code12, digest6.bytes);
        return new _CID(version, code12, digest6, bytes);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   *
   * @template {unknown} [T=unknown]
   * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.
   * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}
   */
  static createV0(digest6) {
    return _CID.create(0, DAG_PB_CODE4, digest6);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @param {Code} code - Content encoding format code.
   * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.
   * @returns {CID<Data, Code, Alg, 1>}
   */
  static createV1(code12, digest6) {
    return _CID.create(1, code12, digest6);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   *
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @template {API.Version} Ver
   * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes
   * @returns {CID<Data, Code, Alg, Ver>}
   */
  static decode(bytes) {
    const [cid, remainder] = _CID.decodeFirst(bytes);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   *
   * @template {unknown} T
   * @template {number} C
   * @template {number} A
   * @template {API.Version} V
   * @param {API.ByteView<API.Link<T, C, A, V>>} bytes
   * @returns {[CID<T, C, A, V>, Uint8Array]}
   */
  static decodeFirst(bytes) {
    const specs = _CID.inspectBytes(bytes);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce4(
      bytes.subarray(prefixSize, prefixSize + specs.multihashSize)
    );
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(
      specs.multihashSize - specs.digestSize
    );
    const digest6 = new Digest4(
      specs.multihashCode,
      specs.digestSize,
      digestBytes,
      multihashBytes
    );
    const cid = specs.version === 0 ? _CID.createV0(
      /** @type {API.MultihashDigest<API.SHA_256>} */
      digest6
    ) : _CID.createV1(specs.codec, digest6);
    return [
      /** @type {CID<T, C, A, V>} */
      cid,
      bytes.subarray(specs.size)
    ];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   *
   * @template {unknown} T
   * @template {number} C
   * @template {number} A
   * @template {API.Version} V
   * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes
   * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i, length11] = decode20(initialBytes.subarray(offset));
      offset += length11;
      return i;
    };
    let version = (
      /** @type {V} */
      next()
    );
    let codec = (
      /** @type {C} */
      DAG_PB_CODE4
    );
    if (
      /** @type {number} */
      version === 18
    ) {
      version = /** @type {V} */
      0;
      offset = 0;
    } else {
      codec = /** @type {C} */
      next();
    }
    if (version !== 0 && version !== 1) {
      throw new RangeError(`Invalid CID version ${version}`);
    }
    const prefixSize = offset;
    const multihashCode = (
      /** @type {A} */
      next()
    );
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   *
   * @template {string} Prefix
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @template {API.Version} Ver
   * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source
   * @param {API.MultibaseDecoder<Prefix>} [base]
   * @returns {CID<Data, Code, Alg, Ver>}
   */
  static parse(source, base14) {
    const [prefix, bytes] = parseCIDtoBytes4(source, base14);
    const cid = _CID.decode(bytes);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache4(cid).set(prefix, source);
    return cid;
  }
};
var parseCIDtoBytes4 = (source, base14) => {
  switch (source[0]) {
    // CIDv0 is parsed differently
    case "Q": {
      const decoder = base14 || base58btc4;
      return [
        /** @type {Prefix} */
        base58btc4.prefix,
        decoder.decode(`${base58btc4.prefix}${source}`)
      ];
    }
    case base58btc4.prefix: {
      const decoder = base14 || base58btc4;
      return [
        /** @type {Prefix} */
        base58btc4.prefix,
        decoder.decode(source)
      ];
    }
    case base324.prefix: {
      const decoder = base14 || base324;
      return [
        /** @type {Prefix} */
        base324.prefix,
        decoder.decode(source)
      ];
    }
    default: {
      if (base14 == null) {
        throw Error(
          "To parse non base32 or base58btc encoded CID multibase decoder must be provided"
        );
      }
      return [
        /** @type {Prefix} */
        source[0],
        base14.decode(source)
      ];
    }
  }
};
var toStringV04 = (bytes, cache11, base14) => {
  const { prefix } = base14;
  if (prefix !== base58btc4.prefix) {
    throw Error(`Cannot string encode V0 in ${base14.name} encoding`);
  }
  const cid = cache11.get(prefix);
  if (cid == null) {
    const cid2 = base14.encode(bytes).slice(1);
    cache11.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var toStringV14 = (bytes, cache11, base14) => {
  const { prefix } = base14;
  const cid = cache11.get(prefix);
  if (cid == null) {
    const cid2 = base14.encode(bytes);
    cache11.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var DAG_PB_CODE4 = 112;
var SHA_256_CODE4 = 18;
var encodeCID4 = (version, code12, multihash) => {
  const codeOffset = encodingLength4(version);
  const hashOffset = codeOffset + encodingLength4(code12);
  const bytes = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo4(version, bytes, 0);
  encodeTo4(code12, bytes, codeOffset);
  bytes.set(multihash, hashOffset);
  return bytes;
};
var cidSymbol4 = Symbol.for("@ipld/js-cid/CID");

// node_modules/dag-jose/lib/signing.js
function fromSplit(split2) {
  const [protectedHeader, payload, signature] = split2;
  return {
    payload,
    signatures: [{ protected: protectedHeader, signature }],
    link: CID4.decode(fromBase64url(payload))
  };
}
function encodeSignature(signature) {
  const encoded = {
    signature: fromBase64url(signature.signature)
  };
  if (signature.header)
    encoded.header = signature.header;
  if (signature.protected)
    encoded.protected = fromBase64url(signature.protected);
  return encoded;
}
function encode14(jws) {
  const payload = fromBase64url(jws.payload);
  try {
    CID4.decode(payload);
  } catch (e) {
    throw new Error("Not a valid DagJWS");
  }
  return {
    payload,
    signatures: jws.signatures.map(encodeSignature)
  };
}
function decodeSignature(encoded) {
  const sign = {
    signature: toBase64url(encoded.signature)
  };
  if (encoded.header)
    sign.header = encoded.header;
  if (encoded.protected)
    sign.protected = toBase64url(encoded.protected);
  return sign;
}
function decode22(encoded) {
  const decoded = {
    payload: toBase64url(encoded.payload),
    signatures: encoded.signatures.map(decodeSignature)
  };
  decoded.link = CID4.decode(new Uint8Array(encoded.payload));
  return decoded;
}

// node_modules/dag-jose/lib/encryption.js
function fromSplit2(split2) {
  const [protectedHeader, encrypted_key, iv, ciphertext, tag] = split2;
  const jwe = {
    ciphertext,
    iv,
    protected: protectedHeader,
    tag
  };
  if (encrypted_key)
    jwe.recipients = [{ encrypted_key }];
  return jwe;
}
function encodeRecipient(recipient) {
  const encRec = {};
  if (recipient.encrypted_key)
    encRec.encrypted_key = fromBase64url(recipient.encrypted_key);
  if (recipient.header)
    encRec.header = recipient.header;
  return encRec;
}
function encode15(jwe) {
  const encJwe = {
    ciphertext: fromBase64url(jwe.ciphertext),
    protected: fromBase64url(jwe.protected),
    iv: fromBase64url(jwe.iv),
    tag: fromBase64url(jwe.tag)
  };
  if (jwe.aad)
    encJwe.aad = fromBase64url(jwe.aad);
  if (jwe.recipients)
    encJwe.recipients = jwe.recipients.map(encodeRecipient);
  if (jwe.unprotected)
    encJwe.unprotected = jwe.unprotected;
  return encJwe;
}
function decodeRecipient(encoded) {
  const recipient = {};
  if (encoded.encrypted_key)
    recipient.encrypted_key = toBase64url(encoded.encrypted_key);
  if (encoded.header)
    recipient.header = encoded.header;
  return recipient;
}
function decode23(encoded) {
  const jwe = {
    ciphertext: toBase64url(encoded.ciphertext),
    protected: toBase64url(encoded.protected),
    iv: toBase64url(encoded.iv),
    tag: toBase64url(encoded.tag)
  };
  if (encoded.aad)
    jwe.aad = toBase64url(encoded.aad);
  if (encoded.recipients)
    jwe.recipients = encoded.recipients.map(decodeRecipient);
  if (encoded.unprotected)
    jwe.unprotected = encoded.unprotected;
  return jwe;
}

// node_modules/dag-jose/lib/index.js
var name4 = "dag-jose";
var code4 = 133;
function isDagJWS(jose) {
  return "payload" in jose && typeof jose.payload === "string" && "signatures" in jose && Array.isArray(jose.signatures);
}
function isEncodedJWS(jose) {
  return "payload" in jose && jose.payload instanceof Uint8Array && "signatures" in jose && Array.isArray(jose.signatures);
}
function isEncodedJWE(jose) {
  return "ciphertext" in jose && jose.ciphertext instanceof Uint8Array && "iv" in jose && jose.iv instanceof Uint8Array && "protected" in jose && jose.protected instanceof Uint8Array && "tag" in jose && jose.tag instanceof Uint8Array;
}
function isDagJWE(jose) {
  return "ciphertext" in jose && typeof jose.ciphertext === "string" && "iv" in jose && typeof jose.iv === "string" && "protected" in jose && typeof jose.protected === "string" && "tag" in jose && typeof jose.tag === "string";
}
function toGeneral(jose) {
  if (typeof jose === "string") {
    const split2 = jose.split(".");
    if (split2.length === 3) {
      return fromSplit(split2);
    } else if (split2.length === 5) {
      return fromSplit2(split2);
    }
    throw new Error("Not a valid JOSE string");
  }
  if (isDagJWS(jose) || isDagJWE(jose)) {
    return jose;
  }
  throw new Error("Not a valid unencoded JOSE object");
}
function encode16(obj) {
  if (typeof obj === "string") {
    obj = toGeneral(obj);
  }
  let encodedJose;
  if (isDagJWS(obj)) {
    encodedJose = encode14(obj);
  } else if (isDagJWE(obj)) {
    encodedJose = encode15(obj);
  } else {
    throw new Error("Not a valid JOSE object");
  }
  return new Uint8Array(encode7(encodedJose));
}
function decode24(data) {
  let encoded;
  try {
    encoded = decode11(data);
  } catch (e) {
    throw new Error("Not a valid DAG-JOSE object");
  }
  if (isEncodedJWS(encoded)) {
    return decode22(encoded);
  } else if (isEncodedJWE(encoded)) {
    return decode23(encoded);
  } else {
    throw new Error("Not a valid DAG-JOSE object");
  }
}

// node_modules/ipfs-http-client/node_modules/multiformats/src/hashes/identity.js
var identity_exports = {};
__export(identity_exports, {
  identity: () => identity
});

// node_modules/ipfs-http-client/node_modules/multiformats/src/bytes.js
var empty5 = new Uint8Array(0);
var equals9 = (aa, bb) => {
  if (aa === bb) return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
};
var coerce5 = (o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array") return o;
  if (o instanceof ArrayBuffer) return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};
var fromString2 = (str) => new TextEncoder().encode(str);
var toString2 = (b) => new TextDecoder().decode(b);

// node_modules/ipfs-http-client/node_modules/multiformats/vendor/varint.js
var encode_15 = encode17;
var MSB5 = 128;
var REST5 = 127;
var MSBALL5 = ~REST5;
var INT5 = Math.pow(2, 31);
function encode17(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT5) {
    out[offset++] = num & 255 | MSB5;
    num /= 128;
  }
  while (num & MSBALL5) {
    out[offset++] = num & 255 | MSB5;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode17.bytes = offset - oldOffset + 1;
  return out;
}
var decode25 = read5;
var MSB$15 = 128;
var REST$15 = 127;
function read5(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
  do {
    if (counter >= l) {
      read5.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf2[counter++];
    res += shift < 28 ? (b & REST$15) << shift : (b & REST$15) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$15);
  read5.bytes = counter - offset;
  return res;
}
var N15 = Math.pow(2, 7);
var N25 = Math.pow(2, 14);
var N35 = Math.pow(2, 21);
var N45 = Math.pow(2, 28);
var N55 = Math.pow(2, 35);
var N65 = Math.pow(2, 42);
var N75 = Math.pow(2, 49);
var N85 = Math.pow(2, 56);
var N95 = Math.pow(2, 63);
var length5 = function(value) {
  return value < N15 ? 1 : value < N25 ? 2 : value < N35 ? 3 : value < N45 ? 4 : value < N55 ? 5 : value < N65 ? 6 : value < N75 ? 7 : value < N85 ? 8 : value < N95 ? 9 : 10;
};
var varint5 = {
  encode: encode_15,
  decode: decode25,
  encodingLength: length5
};
var _brrp_varint5 = varint5;
var varint_default5 = _brrp_varint5;

// node_modules/ipfs-http-client/node_modules/multiformats/src/varint.js
var decode26 = (data, offset = 0) => {
  const code12 = varint_default5.decode(data, offset);
  return [code12, varint_default5.decode.bytes];
};
var encodeTo5 = (int, target, offset = 0) => {
  varint_default5.encode(int, target, offset);
  return target;
};
var encodingLength5 = (int) => {
  return varint_default5.encodingLength(int);
};

// node_modules/ipfs-http-client/node_modules/multiformats/src/hashes/digest.js
var create5 = (code12, digest6) => {
  const size = digest6.byteLength;
  const sizeOffset = encodingLength5(code12);
  const digestOffset = sizeOffset + encodingLength5(size);
  const bytes = new Uint8Array(digestOffset + size);
  encodeTo5(code12, bytes, 0);
  encodeTo5(size, bytes, sizeOffset);
  bytes.set(digest6, digestOffset);
  return new Digest5(code12, size, digest6, bytes);
};
var decode27 = (multihash) => {
  const bytes = coerce5(multihash);
  const [code12, sizeOffset] = decode26(bytes);
  const [size, digestOffset] = decode26(bytes.subarray(sizeOffset));
  const digest6 = bytes.subarray(sizeOffset + digestOffset);
  if (digest6.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest5(code12, size, digest6, bytes);
};
var equals10 = (a, b) => {
  if (a === b) {
    return true;
  } else {
    const data = (
      /** @type {{code?:unknown, size?:unknown, bytes?:unknown}} */
      b
    );
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals9(a.bytes, data.bytes);
  }
};
var Digest5 = class {
  /**
   * Creates a multihash digest.
   *
   * @param {Code} code
   * @param {Size} size
   * @param {Uint8Array} digest
   * @param {Uint8Array} bytes
   */
  constructor(code12, size, digest6, bytes) {
    this.code = code12;
    this.size = size;
    this.digest = digest6;
    this.bytes = bytes;
  }
};

// node_modules/ipfs-http-client/node_modules/multiformats/src/hashes/identity.js
var code5 = 0;
var name5 = "identity";
var encode18 = coerce5;
var digest = (input) => create5(code5, encode18(input));
var identity = { code: code5, name: name5, encode: encode18, digest };

// node_modules/ipfs-http-client/node_modules/multiformats/src/bases/identity.js
var identity_exports2 = {};
__export(identity_exports2, {
  identity: () => identity2
});

// node_modules/ipfs-http-client/node_modules/multiformats/vendor/base-x.js
function base5(ALPHABET, name12) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode42(source) {
    if (source instanceof Uint8Array) ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length11 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length11) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length11 = i2;
      pbegin++;
    }
    var it2 = size - length11;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length11 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length11) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length11 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length11;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode58(string3) {
    var buffer2 = decodeUnsafe(string3);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name12} character`);
  }
  return {
    encode: encode42,
    decodeUnsafe,
    decode: decode58
  };
}
var src5 = base5;
var _brrp__multiformats_scope_baseX5 = src5;
var base_x_default5 = _brrp__multiformats_scope_baseX5;

// node_modules/ipfs-http-client/node_modules/multiformats/src/bases/base.js
var Encoder5 = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   */
  constructor(name12, prefix, baseEncode) {
    this.name = name12;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {API.Multibase<Prefix>}
   */
  encode(bytes) {
    if (bytes instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder5 = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name12, prefix, baseDecode) {
    this.name = name12;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = /** @type {number} */
    prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  /**
   * @param {string} text
   */
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or5(this, decoder);
  }
};
var ComposedDecoder5 = class {
  /**
   * @param {Decoders<Prefix>} decoders
   */
  constructor(decoders3) {
    this.decoders = decoders3;
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or5(this, decoder);
  }
  /**
   * @param {string} input
   * @returns {Uint8Array}
   */
  decode(input) {
    const prefix = (
      /** @type {Prefix} */
      input[0]
    );
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or5 = (left, right) => new ComposedDecoder5(
  /** @type {Decoders<L|R>} */
  {
    ...left.decoders || { [
      /** @type API.UnibaseDecoder<L> */
      left.prefix
    ]: left },
    ...right.decoders || { [
      /** @type API.UnibaseDecoder<R> */
      right.prefix
    ]: right }
  }
);
var Codec5 = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name12, prefix, baseEncode, baseDecode) {
    this.name = name12;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder5(name12, prefix, baseEncode);
    this.decoder = new Decoder5(name12, prefix, baseDecode);
  }
  /**
   * @param {Uint8Array} input
   */
  encode(input) {
    return this.encoder.encode(input);
  }
  /**
   * @param {string} input
   */
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from5 = ({ name: name12, prefix, encode: encode42, decode: decode58 }) => new Codec5(name12, prefix, encode42, decode58);
var baseX5 = ({ prefix, name: name12, alphabet: alphabet7 }) => {
  const { encode: encode42, decode: decode58 } = base_x_default5(alphabet7, name12);
  return from5({
    prefix,
    name: name12,
    encode: encode42,
    /**
     * @param {string} text
     */
    decode: (text) => coerce5(decode58(text))
  });
};
var decode28 = (string3, alphabet7, bitsPerChar, name12) => {
  const codes2 = {};
  for (let i = 0; i < alphabet7.length; ++i) {
    codes2[alphabet7[i]] = i;
  }
  let end = string3.length;
  while (string3[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes2[string3[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name12} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer2 >> bits;
    }
  }
  if (bits >= bitsPerChar || 255 & buffer2 << 8 - bits) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
var encode19 = (data, alphabet7, bitsPerChar) => {
  const pad = alphabet7[alphabet7.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer2 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer2 = buffer2 << 8 | data[i];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet7[mask & buffer2 >> bits];
    }
  }
  if (bits) {
    out += alphabet7[mask & buffer2 << bitsPerChar - bits];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
var rfc46485 = ({ name: name12, prefix, bitsPerChar, alphabet: alphabet7 }) => {
  return from5({
    prefix,
    name: name12,
    encode(input) {
      return encode19(input, alphabet7, bitsPerChar);
    },
    decode(input) {
      return decode28(input, alphabet7, bitsPerChar, name12);
    }
  });
};

// node_modules/ipfs-http-client/node_modules/multiformats/src/bases/identity.js
var identity2 = from5({
  prefix: "\0",
  name: "identity",
  encode: (buf2) => toString2(buf2),
  decode: (str) => fromString2(str)
});

// node_modules/ipfs-http-client/node_modules/multiformats/src/bases/base2.js
var base2_exports = {};
__export(base2_exports, {
  base2: () => base22
});
var base22 = rfc46485({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/ipfs-http-client/node_modules/multiformats/src/bases/base8.js
var base8_exports = {};
__export(base8_exports, {
  base8: () => base8
});
var base8 = rfc46485({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/ipfs-http-client/node_modules/multiformats/src/bases/base10.js
var base10_exports = {};
__export(base10_exports, {
  base10: () => base10
});
var base10 = baseX5({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/ipfs-http-client/node_modules/multiformats/src/bases/base16.js
var base16_exports = {};
__export(base16_exports, {
  base16: () => base16,
  base16upper: () => base16upper
});
var base16 = rfc46485({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper = rfc46485({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/ipfs-http-client/node_modules/multiformats/src/bases/base32.js
var base32_exports = {};
__export(base32_exports, {
  base32: () => base325,
  base32hex: () => base32hex5,
  base32hexpad: () => base32hexpad5,
  base32hexpadupper: () => base32hexpadupper5,
  base32hexupper: () => base32hexupper5,
  base32pad: () => base32pad5,
  base32padupper: () => base32padupper5,
  base32upper: () => base32upper5,
  base32z: () => base32z5
});
var base325 = rfc46485({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper5 = rfc46485({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad5 = rfc46485({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper5 = rfc46485({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex5 = rfc46485({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper5 = rfc46485({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad5 = rfc46485({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper5 = rfc46485({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z5 = rfc46485({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/ipfs-http-client/node_modules/multiformats/src/bases/base36.js
var base36_exports = {};
__export(base36_exports, {
  base36: () => base364,
  base36upper: () => base36upper4
});
var base364 = baseX5({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper4 = baseX5({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/ipfs-http-client/node_modules/multiformats/src/bases/base58.js
var base58_exports = {};
__export(base58_exports, {
  base58btc: () => base58btc5,
  base58flickr: () => base58flickr5
});
var base58btc5 = baseX5({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr5 = baseX5({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/ipfs-http-client/node_modules/multiformats/src/bases/base64.js
var base64_exports = {};
__export(base64_exports, {
  base64: () => base643,
  base64pad: () => base64pad3,
  base64url: () => base64url3,
  base64urlpad: () => base64urlpad3
});
var base643 = rfc46485({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad3 = rfc46485({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url3 = rfc46485({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad3 = rfc46485({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/ipfs-http-client/node_modules/multiformats/src/bases/base256emoji.js
var base256emoji_exports = {};
__export(base256emoji_exports, {
  base256emoji: () => base256emoji
});
var alphabet2 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars = (
  /** @type {string[]} */
  alphabet2.reduce(
    (p, c, i) => {
      p[i] = c;
      return p;
    },
    /** @type {string[]} */
    []
  )
);
var alphabetCharsToBytes = (
  /** @type {number[]} */
  alphabet2.reduce(
    (p, c, i) => {
      p[
        /** @type {number} */
        c.codePointAt(0)
      ] = i;
      return p;
    },
    /** @type {number[]} */
    []
  )
);
function encode20(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars[c];
    return p;
  }, "");
}
function decode29(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes[
      /** @type {number} */
      char.codePointAt(0)
    ];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji = from5({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode20,
  decode: decode29
});

// node_modules/ipfs-http-client/node_modules/multiformats/src/hashes/sha2-browser.js
var sha2_browser_exports = {};
__export(sha2_browser_exports, {
  sha256: () => sha2563,
  sha512: () => sha5122
});

// node_modules/ipfs-http-client/node_modules/multiformats/src/hashes/hasher.js
var from6 = ({ name: name12, code: code12, encode: encode42 }) => new Hasher(name12, code12, encode42);
var Hasher = class {
  /**
   *
   * @param {Name} name
   * @param {Code} code
   * @param {(input: Uint8Array) => Await<Uint8Array>} encode
   */
  constructor(name12, code12, encode42) {
    this.name = name12;
    this.code = code12;
    this.encode = encode42;
  }
  /**
   * @param {Uint8Array} input
   * @returns {Await<Digest.Digest<Code, number>>}
   */
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create5(this.code, result) : result.then((digest6) => create5(this.code, digest6));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/ipfs-http-client/node_modules/multiformats/src/hashes/sha2-browser.js
var sha = (name12) => (
  /**
   * @param {Uint8Array} data
   */
  async (data) => new Uint8Array(await crypto.subtle.digest(name12, data))
);
var sha2563 = from6({
  name: "sha2-256",
  code: 18,
  encode: sha("SHA-256")
});
var sha5122 = from6({
  name: "sha2-512",
  code: 19,
  encode: sha("SHA-512")
});

// node_modules/ipfs-http-client/node_modules/multiformats/src/codecs/raw.js
var raw_exports = {};
__export(raw_exports, {
  code: () => code6,
  decode: () => decode30,
  encode: () => encode21,
  name: () => name6
});
var name6 = "raw";
var code6 = 85;
var encode21 = (node) => coerce5(node);
var decode30 = (data) => coerce5(data);

// node_modules/ipfs-http-client/node_modules/multiformats/src/codecs/json.js
var json_exports2 = {};
__export(json_exports2, {
  code: () => code7,
  decode: () => decode31,
  encode: () => encode22,
  name: () => name7
});
var textEncoder4 = new TextEncoder();
var textDecoder3 = new TextDecoder();
var name7 = "json";
var code7 = 512;
var encode22 = (node) => textEncoder4.encode(JSON.stringify(node));
var decode31 = (data) => JSON.parse(textDecoder3.decode(data));

// node_modules/ipfs-http-client/node_modules/multiformats/src/cid.js
var format6 = (link, base14) => {
  const { bytes, version } = link;
  switch (version) {
    case 0:
      return toStringV05(
        bytes,
        baseCache5(link),
        /** @type {API.MultibaseEncoder<"z">} */
        base14 || base58btc5.encoder
      );
    default:
      return toStringV15(
        bytes,
        baseCache5(link),
        /** @type {API.MultibaseEncoder<Prefix>} */
        base14 || base325.encoder
      );
  }
};
var cache5 = /* @__PURE__ */ new WeakMap();
var baseCache5 = (cid) => {
  const baseCache11 = cache5.get(cid);
  if (baseCache11 == null) {
    const baseCache12 = /* @__PURE__ */ new Map();
    cache5.set(cid, baseCache12);
    return baseCache12;
  }
  return baseCache11;
};
var CID5 = class _CID {
  /**
   * @param {Version} version - Version of the CID
   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.
   * @param {Uint8Array} bytes
   *
   */
  constructor(version, code12, multihash, bytes) {
    this.code = code12;
    this.version = version;
    this.multihash = multihash;
    this.bytes = bytes;
    this["/"] = bytes;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  /**
   * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}
   */
  toV0() {
    switch (this.version) {
      case 0: {
        return (
          /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
          this
        );
      }
      case 1: {
        const { code: code12, multihash } = this;
        if (code12 !== DAG_PB_CODE5) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE5) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return (
          /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
          _CID.createV0(
            /** @type {API.MultihashDigest<API.SHA_256>} */
            multihash
          )
        );
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 0. This is a bug please report`
        );
      }
    }
  }
  /**
   * @returns {CID<Data, Format, Alg, 1>}
   */
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code12, digest: digest6 } = this.multihash;
        const multihash = create5(code12, digest6);
        return (
          /** @type {CID<Data, Format, Alg, 1>} */
          _CID.createV1(this.code, multihash)
        );
      }
      case 1: {
        return (
          /** @type {CID<Data, Format, Alg, 1>} */
          this
        );
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 1. This is a bug please report`
        );
      }
    }
  }
  /**
   * @param {unknown} other
   * @returns {other is CID<Data, Format, Alg, Version>}
   */
  equals(other) {
    return _CID.equals(this, other);
  }
  /**
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @param {API.Link<Data, Format, Alg, Version>} self
   * @param {unknown} other
   * @returns {other is CID}
   */
  static equals(self2, other) {
    const unknown = (
      /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */
      other
    );
    return unknown && self2.code === unknown.code && self2.version === unknown.version && equals10(self2.multihash, unknown.multihash);
  }
  /**
   * @param {API.MultibaseEncoder<string>} [base]
   * @returns {string}
   */
  toString(base14) {
    return format6(this, base14);
  }
  toJSON() {
    return { "/": format6(this) };
  }
  link() {
    return this;
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   *
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @template {unknown} U
   * @param {API.Link<Data, Format, Alg, Version>|U} input
   * @returns {CID<Data, Format, Alg, Version>|null}
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value = (
      /** @type {any} */
      input
    );
    if (value instanceof _CID) {
      return value;
    } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
      const { version, code: code12, multihash, bytes } = value;
      return new _CID(
        version,
        code12,
        /** @type {API.MultihashDigest<Alg>} */
        multihash,
        bytes || encodeCID5(version, code12, multihash.bytes)
      );
    } else if (value[cidSymbol5] === true) {
      const { version, multihash, code: code12 } = value;
      const digest6 = (
        /** @type {API.MultihashDigest<Alg>} */
        decode27(multihash)
      );
      return _CID.create(version, code12, digest6);
    } else {
      return null;
    }
  }
  /**
   *
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @param {Version} version - Version of the CID
   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.
   * @returns {CID<Data, Format, Alg, Version>}
   */
  static create(version, code12, digest6) {
    if (typeof code12 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest6.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version) {
      case 0: {
        if (code12 !== DAG_PB_CODE5) {
          throw new Error(
            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE5}) block encoding`
          );
        } else {
          return new _CID(version, code12, digest6, digest6.bytes);
        }
      }
      case 1: {
        const bytes = encodeCID5(version, code12, digest6.bytes);
        return new _CID(version, code12, digest6, bytes);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   *
   * @template {unknown} [T=unknown]
   * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.
   * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}
   */
  static createV0(digest6) {
    return _CID.create(0, DAG_PB_CODE5, digest6);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @param {Code} code - Content encoding format code.
   * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.
   * @returns {CID<Data, Code, Alg, 1>}
   */
  static createV1(code12, digest6) {
    return _CID.create(1, code12, digest6);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   *
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @template {API.Version} Ver
   * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes
   * @returns {CID<Data, Code, Alg, Ver>}
   */
  static decode(bytes) {
    const [cid, remainder] = _CID.decodeFirst(bytes);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   *
   * @template {unknown} T
   * @template {number} C
   * @template {number} A
   * @template {API.Version} V
   * @param {API.ByteView<API.Link<T, C, A, V>>} bytes
   * @returns {[CID<T, C, A, V>, Uint8Array]}
   */
  static decodeFirst(bytes) {
    const specs = _CID.inspectBytes(bytes);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce5(
      bytes.subarray(prefixSize, prefixSize + specs.multihashSize)
    );
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(
      specs.multihashSize - specs.digestSize
    );
    const digest6 = new Digest5(
      specs.multihashCode,
      specs.digestSize,
      digestBytes,
      multihashBytes
    );
    const cid = specs.version === 0 ? _CID.createV0(
      /** @type {API.MultihashDigest<API.SHA_256>} */
      digest6
    ) : _CID.createV1(specs.codec, digest6);
    return [
      /** @type {CID<T, C, A, V>} */
      cid,
      bytes.subarray(specs.size)
    ];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   *
   * @template {unknown} T
   * @template {number} C
   * @template {number} A
   * @template {API.Version} V
   * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes
   * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i, length11] = decode26(initialBytes.subarray(offset));
      offset += length11;
      return i;
    };
    let version = (
      /** @type {V} */
      next()
    );
    let codec = (
      /** @type {C} */
      DAG_PB_CODE5
    );
    if (
      /** @type {number} */
      version === 18
    ) {
      version = /** @type {V} */
      0;
      offset = 0;
    } else {
      codec = /** @type {C} */
      next();
    }
    if (version !== 0 && version !== 1) {
      throw new RangeError(`Invalid CID version ${version}`);
    }
    const prefixSize = offset;
    const multihashCode = (
      /** @type {A} */
      next()
    );
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   *
   * @template {string} Prefix
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @template {API.Version} Ver
   * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source
   * @param {API.MultibaseDecoder<Prefix>} [base]
   * @returns {CID<Data, Code, Alg, Ver>}
   */
  static parse(source, base14) {
    const [prefix, bytes] = parseCIDtoBytes5(source, base14);
    const cid = _CID.decode(bytes);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache5(cid).set(prefix, source);
    return cid;
  }
};
var parseCIDtoBytes5 = (source, base14) => {
  switch (source[0]) {
    // CIDv0 is parsed differently
    case "Q": {
      const decoder = base14 || base58btc5;
      return [
        /** @type {Prefix} */
        base58btc5.prefix,
        decoder.decode(`${base58btc5.prefix}${source}`)
      ];
    }
    case base58btc5.prefix: {
      const decoder = base14 || base58btc5;
      return [
        /** @type {Prefix} */
        base58btc5.prefix,
        decoder.decode(source)
      ];
    }
    case base325.prefix: {
      const decoder = base14 || base325;
      return [
        /** @type {Prefix} */
        base325.prefix,
        decoder.decode(source)
      ];
    }
    default: {
      if (base14 == null) {
        throw Error(
          "To parse non base32 or base58btc encoded CID multibase decoder must be provided"
        );
      }
      return [
        /** @type {Prefix} */
        source[0],
        base14.decode(source)
      ];
    }
  }
};
var toStringV05 = (bytes, cache11, base14) => {
  const { prefix } = base14;
  if (prefix !== base58btc5.prefix) {
    throw Error(`Cannot string encode V0 in ${base14.name} encoding`);
  }
  const cid = cache11.get(prefix);
  if (cid == null) {
    const cid2 = base14.encode(bytes).slice(1);
    cache11.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var toStringV15 = (bytes, cache11, base14) => {
  const { prefix } = base14;
  const cid = cache11.get(prefix);
  if (cid == null) {
    const cid2 = base14.encode(bytes);
    cache11.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var DAG_PB_CODE5 = 112;
var SHA_256_CODE5 = 18;
var encodeCID5 = (version, code12, multihash) => {
  const codeOffset = encodingLength5(version);
  const hashOffset = codeOffset + encodingLength5(code12);
  const bytes = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo5(version, bytes, 0);
  encodeTo5(code12, bytes, codeOffset);
  bytes.set(multihash, hashOffset);
  return bytes;
};
var cidSymbol5 = Symbol.for("@ipld/js-cid/CID");

// node_modules/ipfs-http-client/node_modules/multiformats/src/basics.js
var bases = { ...identity_exports2, ...base2_exports, ...base8_exports, ...base10_exports, ...base16_exports, ...base32_exports, ...base36_exports, ...base58_exports, ...base64_exports, ...base256emoji_exports };
var hashes = { ...sha2_browser_exports, ...identity_exports };
var codecs = { raw: raw_exports, json: json_exports2 };

// node_modules/@chainsafe/is-ip/lib/parser.js
var Parser = class {
  index = 0;
  input = "";
  new(input) {
    this.index = 0;
    this.input = input;
    return this;
  }
  /** Run a parser, and restore the pre-parse state if it fails. */
  readAtomically(fn) {
    const index = this.index;
    const result = fn();
    if (result === void 0) {
      this.index = index;
    }
    return result;
  }
  /** Run a parser, but fail if the entire input wasn't consumed. Doesn't run atomically. */
  parseWith(fn) {
    const result = fn();
    if (this.index !== this.input.length) {
      return void 0;
    }
    return result;
  }
  /** Peek the next character from the input */
  peekChar() {
    if (this.index >= this.input.length) {
      return void 0;
    }
    return this.input[this.index];
  }
  /** Read the next character from the input */
  readChar() {
    if (this.index >= this.input.length) {
      return void 0;
    }
    return this.input[this.index++];
  }
  /** Read the next character from the input if it matches the target. */
  readGivenChar(target) {
    return this.readAtomically(() => {
      const char = this.readChar();
      if (char !== target) {
        return void 0;
      }
      return char;
    });
  }
  /**
   * Helper for reading separators in an indexed loop. Reads the separator
   * character iff index > 0, then runs the parser. When used in a loop,
   * the separator character will only be read on index > 0 (see
   * readIPv4Addr for an example)
   */
  readSeparator(sep, index, inner) {
    return this.readAtomically(() => {
      if (index > 0) {
        if (this.readGivenChar(sep) === void 0) {
          return void 0;
        }
      }
      return inner();
    });
  }
  /**
   * Read a number off the front of the input in the given radix, stopping
   * at the first non-digit character or eof. Fails if the number has more
   * digits than max_digits or if there is no number.
   */
  readNumber(radix2, maxDigits, allowZeroPrefix, maxBytes) {
    return this.readAtomically(() => {
      let result = 0;
      let digitCount = 0;
      const leadingChar = this.peekChar();
      if (leadingChar === void 0) {
        return void 0;
      }
      const hasLeadingZero = leadingChar === "0";
      const maxValue2 = 2 ** (8 * maxBytes) - 1;
      while (true) {
        const digit = this.readAtomically(() => {
          const char = this.readChar();
          if (char === void 0) {
            return void 0;
          }
          const num = Number.parseInt(char, radix2);
          if (Number.isNaN(num)) {
            return void 0;
          }
          return num;
        });
        if (digit === void 0) {
          break;
        }
        result *= radix2;
        result += digit;
        if (result > maxValue2) {
          return void 0;
        }
        digitCount += 1;
        if (maxDigits !== void 0) {
          if (digitCount > maxDigits) {
            return void 0;
          }
        }
      }
      if (digitCount === 0) {
        return void 0;
      } else if (!allowZeroPrefix && hasLeadingZero && digitCount > 1) {
        return void 0;
      } else {
        return result;
      }
    });
  }
  /** Read an IPv4 address. */
  readIPv4Addr() {
    return this.readAtomically(() => {
      const out = new Uint8Array(4);
      for (let i = 0; i < out.length; i++) {
        const ix = this.readSeparator(".", i, () => this.readNumber(10, 3, false, 1));
        if (ix === void 0) {
          return void 0;
        }
        out[i] = ix;
      }
      return out;
    });
  }
  /** Read an IPv6 Address. */
  readIPv6Addr() {
    const readGroups = (groups) => {
      for (let i = 0; i < groups.length / 2; i++) {
        const ix = i * 2;
        if (i < groups.length - 3) {
          const ipv4 = this.readSeparator(":", i, () => this.readIPv4Addr());
          if (ipv4 !== void 0) {
            groups[ix] = ipv4[0];
            groups[ix + 1] = ipv4[1];
            groups[ix + 2] = ipv4[2];
            groups[ix + 3] = ipv4[3];
            return [ix + 4, true];
          }
        }
        const group = this.readSeparator(":", i, () => this.readNumber(16, 4, true, 2));
        if (group === void 0) {
          return [ix, false];
        }
        groups[ix] = group >> 8;
        groups[ix + 1] = group & 255;
      }
      return [groups.length, false];
    };
    return this.readAtomically(() => {
      const head = new Uint8Array(16);
      const [headSize, headIp4] = readGroups(head);
      if (headSize === 16) {
        return head;
      }
      if (headIp4) {
        return void 0;
      }
      if (this.readGivenChar(":") === void 0) {
        return void 0;
      }
      if (this.readGivenChar(":") === void 0) {
        return void 0;
      }
      const tail = new Uint8Array(14);
      const limit = 16 - (headSize + 2);
      const [tailSize] = readGroups(tail.subarray(0, limit));
      head.set(tail.subarray(0, tailSize), 16 - tailSize);
      return head;
    });
  }
  /** Read an IP Address, either IPv4 or IPv6. */
  readIPAddr() {
    return this.readIPv4Addr() ?? this.readIPv6Addr();
  }
};

// node_modules/@chainsafe/is-ip/lib/parse.js
var MAX_IPV6_LENGTH = 45;
var MAX_IPV4_LENGTH = 15;
var parser = new Parser();
function parseIPv4(input) {
  if (input.length > MAX_IPV4_LENGTH) {
    return void 0;
  }
  return parser.new(input).parseWith(() => parser.readIPv4Addr());
}
function parseIPv6(input) {
  if (input.includes("%")) {
    input = input.split("%")[0];
  }
  if (input.length > MAX_IPV6_LENGTH) {
    return void 0;
  }
  return parser.new(input).parseWith(() => parser.readIPv6Addr());
}
function parseIP(input, mapIPv4ToIPv6 = false) {
  if (input.includes("%")) {
    input = input.split("%")[0];
  }
  if (input.length > MAX_IPV6_LENGTH) {
    return void 0;
  }
  const addr = parser.new(input).parseWith(() => parser.readIPAddr());
  if (!addr) {
    return void 0;
  }
  if (mapIPv4ToIPv6 && addr.length === 4) {
    return Uint8Array.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, addr[0], addr[1], addr[2], addr[3]]);
  }
  return addr;
}

// node_modules/@chainsafe/is-ip/lib/is-ip.js
function isIPv4(input) {
  return Boolean(parseIPv4(input));
}
function isIPv6(input) {
  return Boolean(parseIPv6(input));
}
function isIP(input) {
  return Boolean(parseIP(input));
}

// node_modules/uint8arrays/node_modules/multiformats/src/bases/base10.js
var base10_exports2 = {};
__export(base10_exports2, {
  base10: () => base102
});

// node_modules/uint8arrays/node_modules/multiformats/vendor/base-x.js
function base6(ALPHABET, name12) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode42(source) {
    if (source instanceof Uint8Array) ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length11 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length11) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length11 = i2;
      pbegin++;
    }
    var it2 = size - length11;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length11 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length11) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length11 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length11;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode58(string3) {
    var buffer2 = decodeUnsafe(string3);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name12} character`);
  }
  return {
    encode: encode42,
    decodeUnsafe,
    decode: decode58
  };
}
var src6 = base6;
var _brrp__multiformats_scope_baseX6 = src6;
var base_x_default6 = _brrp__multiformats_scope_baseX6;

// node_modules/uint8arrays/node_modules/multiformats/src/bytes.js
var empty6 = new Uint8Array(0);
var equals11 = (aa, bb) => {
  if (aa === bb) return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
};
var coerce6 = (o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array") return o;
  if (o instanceof ArrayBuffer) return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};
var fromString3 = (str) => new TextEncoder().encode(str);
var toString3 = (b) => new TextDecoder().decode(b);

// node_modules/uint8arrays/node_modules/multiformats/src/bases/base.js
var Encoder6 = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   */
  constructor(name12, prefix, baseEncode) {
    this.name = name12;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {API.Multibase<Prefix>}
   */
  encode(bytes) {
    if (bytes instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder6 = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name12, prefix, baseDecode) {
    this.name = name12;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = /** @type {number} */
    prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  /**
   * @param {string} text
   */
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or6(this, decoder);
  }
};
var ComposedDecoder6 = class {
  /**
   * @param {Decoders<Prefix>} decoders
   */
  constructor(decoders3) {
    this.decoders = decoders3;
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or6(this, decoder);
  }
  /**
   * @param {string} input
   * @returns {Uint8Array}
   */
  decode(input) {
    const prefix = (
      /** @type {Prefix} */
      input[0]
    );
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or6 = (left, right) => new ComposedDecoder6(
  /** @type {Decoders<L|R>} */
  {
    ...left.decoders || { [
      /** @type API.UnibaseDecoder<L> */
      left.prefix
    ]: left },
    ...right.decoders || { [
      /** @type API.UnibaseDecoder<R> */
      right.prefix
    ]: right }
  }
);
var Codec6 = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name12, prefix, baseEncode, baseDecode) {
    this.name = name12;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder6(name12, prefix, baseEncode);
    this.decoder = new Decoder6(name12, prefix, baseDecode);
  }
  /**
   * @param {Uint8Array} input
   */
  encode(input) {
    return this.encoder.encode(input);
  }
  /**
   * @param {string} input
   */
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from7 = ({ name: name12, prefix, encode: encode42, decode: decode58 }) => new Codec6(name12, prefix, encode42, decode58);
var baseX6 = ({ prefix, name: name12, alphabet: alphabet7 }) => {
  const { encode: encode42, decode: decode58 } = base_x_default6(alphabet7, name12);
  return from7({
    prefix,
    name: name12,
    encode: encode42,
    /**
     * @param {string} text
     */
    decode: (text) => coerce6(decode58(text))
  });
};
var decode32 = (string3, alphabet7, bitsPerChar, name12) => {
  const codes2 = {};
  for (let i = 0; i < alphabet7.length; ++i) {
    codes2[alphabet7[i]] = i;
  }
  let end = string3.length;
  while (string3[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes2[string3[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name12} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer2 >> bits;
    }
  }
  if (bits >= bitsPerChar || 255 & buffer2 << 8 - bits) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
var encode23 = (data, alphabet7, bitsPerChar) => {
  const pad = alphabet7[alphabet7.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer2 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer2 = buffer2 << 8 | data[i];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet7[mask & buffer2 >> bits];
    }
  }
  if (bits) {
    out += alphabet7[mask & buffer2 << bitsPerChar - bits];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
var rfc46486 = ({ name: name12, prefix, bitsPerChar, alphabet: alphabet7 }) => {
  return from7({
    prefix,
    name: name12,
    encode(input) {
      return encode23(input, alphabet7, bitsPerChar);
    },
    decode(input) {
      return decode32(input, alphabet7, bitsPerChar, name12);
    }
  });
};

// node_modules/uint8arrays/node_modules/multiformats/src/bases/base10.js
var base102 = baseX6({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/uint8arrays/node_modules/multiformats/src/bases/base16.js
var base16_exports2 = {};
__export(base16_exports2, {
  base16: () => base162,
  base16upper: () => base16upper2
});
var base162 = rfc46486({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper2 = rfc46486({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/uint8arrays/node_modules/multiformats/src/bases/base2.js
var base2_exports2 = {};
__export(base2_exports2, {
  base2: () => base23
});
var base23 = rfc46486({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/uint8arrays/node_modules/multiformats/src/bases/base256emoji.js
var base256emoji_exports2 = {};
__export(base256emoji_exports2, {
  base256emoji: () => base256emoji2
});
var alphabet3 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars2 = (
  /** @type {string[]} */
  alphabet3.reduce(
    (p, c, i) => {
      p[i] = c;
      return p;
    },
    /** @type {string[]} */
    []
  )
);
var alphabetCharsToBytes2 = (
  /** @type {number[]} */
  alphabet3.reduce(
    (p, c, i) => {
      p[
        /** @type {number} */
        c.codePointAt(0)
      ] = i;
      return p;
    },
    /** @type {number[]} */
    []
  )
);
function encode24(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars2[c];
    return p;
  }, "");
}
function decode33(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes2[
      /** @type {number} */
      char.codePointAt(0)
    ];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji2 = from7({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode24,
  decode: decode33
});

// node_modules/uint8arrays/node_modules/multiformats/src/bases/base32.js
var base32_exports2 = {};
__export(base32_exports2, {
  base32: () => base326,
  base32hex: () => base32hex6,
  base32hexpad: () => base32hexpad6,
  base32hexpadupper: () => base32hexpadupper6,
  base32hexupper: () => base32hexupper6,
  base32pad: () => base32pad6,
  base32padupper: () => base32padupper6,
  base32upper: () => base32upper6,
  base32z: () => base32z6
});
var base326 = rfc46486({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper6 = rfc46486({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad6 = rfc46486({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper6 = rfc46486({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex6 = rfc46486({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper6 = rfc46486({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad6 = rfc46486({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper6 = rfc46486({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z6 = rfc46486({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/uint8arrays/node_modules/multiformats/src/bases/base36.js
var base36_exports2 = {};
__export(base36_exports2, {
  base36: () => base365,
  base36upper: () => base36upper5
});
var base365 = baseX6({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper5 = baseX6({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/uint8arrays/node_modules/multiformats/src/bases/base58.js
var base58_exports2 = {};
__export(base58_exports2, {
  base58btc: () => base58btc6,
  base58flickr: () => base58flickr6
});
var base58btc6 = baseX6({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr6 = baseX6({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/uint8arrays/node_modules/multiformats/src/bases/base64.js
var base64_exports2 = {};
__export(base64_exports2, {
  base64: () => base644,
  base64pad: () => base64pad4,
  base64url: () => base64url4,
  base64urlpad: () => base64urlpad4
});
var base644 = rfc46486({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad4 = rfc46486({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url4 = rfc46486({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad4 = rfc46486({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/uint8arrays/node_modules/multiformats/src/bases/base8.js
var base8_exports2 = {};
__export(base8_exports2, {
  base8: () => base82
});
var base82 = rfc46486({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/uint8arrays/node_modules/multiformats/src/bases/identity.js
var identity_exports3 = {};
__export(identity_exports3, {
  identity: () => identity3
});
var identity3 = from7({
  prefix: "\0",
  name: "identity",
  encode: (buf2) => toString3(buf2),
  decode: (str) => fromString3(str)
});

// node_modules/uint8arrays/node_modules/multiformats/src/codecs/json.js
var textEncoder5 = new TextEncoder();
var textDecoder4 = new TextDecoder();

// node_modules/uint8arrays/node_modules/multiformats/src/hashes/identity.js
var identity_exports4 = {};
__export(identity_exports4, {
  identity: () => identity4
});

// node_modules/uint8arrays/node_modules/multiformats/vendor/varint.js
var encode_16 = encode25;
var MSB6 = 128;
var REST6 = 127;
var MSBALL6 = ~REST6;
var INT6 = Math.pow(2, 31);
function encode25(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT6) {
    out[offset++] = num & 255 | MSB6;
    num /= 128;
  }
  while (num & MSBALL6) {
    out[offset++] = num & 255 | MSB6;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode25.bytes = offset - oldOffset + 1;
  return out;
}
var decode34 = read6;
var MSB$16 = 128;
var REST$16 = 127;
function read6(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
  do {
    if (counter >= l) {
      read6.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf2[counter++];
    res += shift < 28 ? (b & REST$16) << shift : (b & REST$16) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$16);
  read6.bytes = counter - offset;
  return res;
}
var N16 = Math.pow(2, 7);
var N26 = Math.pow(2, 14);
var N36 = Math.pow(2, 21);
var N46 = Math.pow(2, 28);
var N56 = Math.pow(2, 35);
var N66 = Math.pow(2, 42);
var N76 = Math.pow(2, 49);
var N86 = Math.pow(2, 56);
var N96 = Math.pow(2, 63);
var length6 = function(value) {
  return value < N16 ? 1 : value < N26 ? 2 : value < N36 ? 3 : value < N46 ? 4 : value < N56 ? 5 : value < N66 ? 6 : value < N76 ? 7 : value < N86 ? 8 : value < N96 ? 9 : 10;
};
var varint6 = {
  encode: encode_16,
  decode: decode34,
  encodingLength: length6
};
var _brrp_varint6 = varint6;
var varint_default6 = _brrp_varint6;

// node_modules/uint8arrays/node_modules/multiformats/src/varint.js
var decode35 = (data, offset = 0) => {
  const code12 = varint_default6.decode(data, offset);
  return [code12, varint_default6.decode.bytes];
};
var encodeTo6 = (int, target, offset = 0) => {
  varint_default6.encode(int, target, offset);
  return target;
};
var encodingLength6 = (int) => {
  return varint_default6.encodingLength(int);
};

// node_modules/uint8arrays/node_modules/multiformats/src/hashes/digest.js
var create6 = (code12, digest6) => {
  const size = digest6.byteLength;
  const sizeOffset = encodingLength6(code12);
  const digestOffset = sizeOffset + encodingLength6(size);
  const bytes = new Uint8Array(digestOffset + size);
  encodeTo6(code12, bytes, 0);
  encodeTo6(size, bytes, sizeOffset);
  bytes.set(digest6, digestOffset);
  return new Digest6(code12, size, digest6, bytes);
};
var decode36 = (multihash) => {
  const bytes = coerce6(multihash);
  const [code12, sizeOffset] = decode35(bytes);
  const [size, digestOffset] = decode35(bytes.subarray(sizeOffset));
  const digest6 = bytes.subarray(sizeOffset + digestOffset);
  if (digest6.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest6(code12, size, digest6, bytes);
};
var equals12 = (a, b) => {
  if (a === b) {
    return true;
  } else {
    const data = (
      /** @type {{code?:unknown, size?:unknown, bytes?:unknown}} */
      b
    );
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals11(a.bytes, data.bytes);
  }
};
var Digest6 = class {
  /**
   * Creates a multihash digest.
   *
   * @param {Code} code
   * @param {Size} size
   * @param {Uint8Array} digest
   * @param {Uint8Array} bytes
   */
  constructor(code12, size, digest6, bytes) {
    this.code = code12;
    this.size = size;
    this.digest = digest6;
    this.bytes = bytes;
  }
};

// node_modules/uint8arrays/node_modules/multiformats/src/hashes/identity.js
var code8 = 0;
var name8 = "identity";
var encode26 = coerce6;
var digest2 = (input) => create6(code8, encode26(input));
var identity4 = { code: code8, name: name8, encode: encode26, digest: digest2 };

// node_modules/uint8arrays/node_modules/multiformats/src/hashes/sha2-browser.js
var sha2_browser_exports2 = {};
__export(sha2_browser_exports2, {
  sha256: () => sha2564,
  sha512: () => sha5123
});

// node_modules/uint8arrays/node_modules/multiformats/src/hashes/hasher.js
var from8 = ({ name: name12, code: code12, encode: encode42 }) => new Hasher2(name12, code12, encode42);
var Hasher2 = class {
  /**
   *
   * @param {Name} name
   * @param {Code} code
   * @param {(input: Uint8Array) => Await<Uint8Array>} encode
   */
  constructor(name12, code12, encode42) {
    this.name = name12;
    this.code = code12;
    this.encode = encode42;
  }
  /**
   * @param {Uint8Array} input
   * @returns {Await<Digest.Digest<Code, number>>}
   */
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create6(this.code, result) : result.then((digest6) => create6(this.code, digest6));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/uint8arrays/node_modules/multiformats/src/hashes/sha2-browser.js
var sha2 = (name12) => (
  /**
   * @param {Uint8Array} data
   */
  async (data) => new Uint8Array(await crypto.subtle.digest(name12, data))
);
var sha2564 = from8({
  name: "sha2-256",
  code: 18,
  encode: sha2("SHA-256")
});
var sha5123 = from8({
  name: "sha2-512",
  code: 19,
  encode: sha2("SHA-512")
});

// node_modules/uint8arrays/node_modules/multiformats/src/cid.js
var format7 = (link, base14) => {
  const { bytes, version } = link;
  switch (version) {
    case 0:
      return toStringV06(
        bytes,
        baseCache6(link),
        /** @type {API.MultibaseEncoder<"z">} */
        base14 || base58btc6.encoder
      );
    default:
      return toStringV16(
        bytes,
        baseCache6(link),
        /** @type {API.MultibaseEncoder<Prefix>} */
        base14 || base326.encoder
      );
  }
};
var cache6 = /* @__PURE__ */ new WeakMap();
var baseCache6 = (cid) => {
  const baseCache11 = cache6.get(cid);
  if (baseCache11 == null) {
    const baseCache12 = /* @__PURE__ */ new Map();
    cache6.set(cid, baseCache12);
    return baseCache12;
  }
  return baseCache11;
};
var CID6 = class _CID {
  /**
   * @param {Version} version - Version of the CID
   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.
   * @param {Uint8Array} bytes
   */
  constructor(version, code12, multihash, bytes) {
    this.code = code12;
    this.version = version;
    this.multihash = multihash;
    this.bytes = bytes;
    this["/"] = bytes;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  /**
   * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}
   */
  toV0() {
    switch (this.version) {
      case 0: {
        return (
          /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
          this
        );
      }
      case 1: {
        const { code: code12, multihash } = this;
        if (code12 !== DAG_PB_CODE6) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE6) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return (
          /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
          _CID.createV0(
            /** @type {API.MultihashDigest<API.SHA_256>} */
            multihash
          )
        );
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 0. This is a bug please report`
        );
      }
    }
  }
  /**
   * @returns {CID<Data, Format, Alg, 1>}
   */
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code12, digest: digest6 } = this.multihash;
        const multihash = create6(code12, digest6);
        return (
          /** @type {CID<Data, Format, Alg, 1>} */
          _CID.createV1(this.code, multihash)
        );
      }
      case 1: {
        return (
          /** @type {CID<Data, Format, Alg, 1>} */
          this
        );
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 1. This is a bug please report`
        );
      }
    }
  }
  /**
   * @param {unknown} other
   * @returns {other is CID<Data, Format, Alg, Version>}
   */
  equals(other) {
    return _CID.equals(this, other);
  }
  /**
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @param {API.Link<Data, Format, Alg, Version>} self
   * @param {unknown} other
   * @returns {other is CID}
   */
  static equals(self2, other) {
    const unknown = (
      /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */
      other
    );
    return unknown && self2.code === unknown.code && self2.version === unknown.version && equals12(self2.multihash, unknown.multihash);
  }
  /**
   * @param {API.MultibaseEncoder<string>} [base]
   * @returns {string}
   */
  toString(base14) {
    return format7(this, base14);
  }
  /**
   * @returns {API.LinkJSON<this>}
   */
  toJSON() {
    return { "/": format7(this) };
  }
  link() {
    return this;
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   *
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @template {unknown} U
   * @param {API.Link<Data, Format, Alg, Version>|U} input
   * @returns {CID<Data, Format, Alg, Version>|null}
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value = (
      /** @type {any} */
      input
    );
    if (value instanceof _CID) {
      return value;
    } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
      const { version, code: code12, multihash, bytes } = value;
      return new _CID(
        version,
        code12,
        /** @type {API.MultihashDigest<Alg>} */
        multihash,
        bytes || encodeCID6(version, code12, multihash.bytes)
      );
    } else if (value[cidSymbol6] === true) {
      const { version, multihash, code: code12 } = value;
      const digest6 = (
        /** @type {API.MultihashDigest<Alg>} */
        decode36(multihash)
      );
      return _CID.create(version, code12, digest6);
    } else {
      return null;
    }
  }
  /**
   *
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @param {Version} version - Version of the CID
   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.
   * @returns {CID<Data, Format, Alg, Version>}
   */
  static create(version, code12, digest6) {
    if (typeof code12 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest6.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version) {
      case 0: {
        if (code12 !== DAG_PB_CODE6) {
          throw new Error(
            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE6}) block encoding`
          );
        } else {
          return new _CID(version, code12, digest6, digest6.bytes);
        }
      }
      case 1: {
        const bytes = encodeCID6(version, code12, digest6.bytes);
        return new _CID(version, code12, digest6, bytes);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   *
   * @template {unknown} [T=unknown]
   * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.
   * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}
   */
  static createV0(digest6) {
    return _CID.create(0, DAG_PB_CODE6, digest6);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @param {Code} code - Content encoding format code.
   * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.
   * @returns {CID<Data, Code, Alg, 1>}
   */
  static createV1(code12, digest6) {
    return _CID.create(1, code12, digest6);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   *
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @template {API.Version} Ver
   * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes
   * @returns {CID<Data, Code, Alg, Ver>}
   */
  static decode(bytes) {
    const [cid, remainder] = _CID.decodeFirst(bytes);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   *
   * @template {unknown} T
   * @template {number} C
   * @template {number} A
   * @template {API.Version} V
   * @param {API.ByteView<API.Link<T, C, A, V>>} bytes
   * @returns {[CID<T, C, A, V>, Uint8Array]}
   */
  static decodeFirst(bytes) {
    const specs = _CID.inspectBytes(bytes);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce6(
      bytes.subarray(prefixSize, prefixSize + specs.multihashSize)
    );
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(
      specs.multihashSize - specs.digestSize
    );
    const digest6 = new Digest6(
      specs.multihashCode,
      specs.digestSize,
      digestBytes,
      multihashBytes
    );
    const cid = specs.version === 0 ? _CID.createV0(
      /** @type {API.MultihashDigest<API.SHA_256>} */
      digest6
    ) : _CID.createV1(specs.codec, digest6);
    return [
      /** @type {CID<T, C, A, V>} */
      cid,
      bytes.subarray(specs.size)
    ];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   *
   * @template {unknown} T
   * @template {number} C
   * @template {number} A
   * @template {API.Version} V
   * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes
   * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i, length11] = decode35(initialBytes.subarray(offset));
      offset += length11;
      return i;
    };
    let version = (
      /** @type {V} */
      next()
    );
    let codec = (
      /** @type {C} */
      DAG_PB_CODE6
    );
    if (
      /** @type {number} */
      version === 18
    ) {
      version = /** @type {V} */
      0;
      offset = 0;
    } else {
      codec = /** @type {C} */
      next();
    }
    if (version !== 0 && version !== 1) {
      throw new RangeError(`Invalid CID version ${version}`);
    }
    const prefixSize = offset;
    const multihashCode = (
      /** @type {A} */
      next()
    );
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   *
   * @template {string} Prefix
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @template {API.Version} Ver
   * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source
   * @param {API.MultibaseDecoder<Prefix>} [base]
   * @returns {CID<Data, Code, Alg, Ver>}
   */
  static parse(source, base14) {
    const [prefix, bytes] = parseCIDtoBytes6(source, base14);
    const cid = _CID.decode(bytes);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache6(cid).set(prefix, source);
    return cid;
  }
};
var parseCIDtoBytes6 = (source, base14) => {
  switch (source[0]) {
    // CIDv0 is parsed differently
    case "Q": {
      const decoder = base14 || base58btc6;
      return [
        /** @type {Prefix} */
        base58btc6.prefix,
        decoder.decode(`${base58btc6.prefix}${source}`)
      ];
    }
    case base58btc6.prefix: {
      const decoder = base14 || base58btc6;
      return [
        /** @type {Prefix} */
        base58btc6.prefix,
        decoder.decode(source)
      ];
    }
    case base326.prefix: {
      const decoder = base14 || base326;
      return [
        /** @type {Prefix} */
        base326.prefix,
        decoder.decode(source)
      ];
    }
    default: {
      if (base14 == null) {
        throw Error(
          "To parse non base32 or base58btc encoded CID multibase decoder must be provided"
        );
      }
      return [
        /** @type {Prefix} */
        source[0],
        base14.decode(source)
      ];
    }
  }
};
var toStringV06 = (bytes, cache11, base14) => {
  const { prefix } = base14;
  if (prefix !== base58btc6.prefix) {
    throw Error(`Cannot string encode V0 in ${base14.name} encoding`);
  }
  const cid = cache11.get(prefix);
  if (cid == null) {
    const cid2 = base14.encode(bytes).slice(1);
    cache11.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var toStringV16 = (bytes, cache11, base14) => {
  const { prefix } = base14;
  const cid = cache11.get(prefix);
  if (cid == null) {
    const cid2 = base14.encode(bytes);
    cache11.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var DAG_PB_CODE6 = 112;
var SHA_256_CODE6 = 18;
var encodeCID6 = (version, code12, multihash) => {
  const codeOffset = encodingLength6(version);
  const hashOffset = codeOffset + encodingLength6(code12);
  const bytes = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo6(version, bytes, 0);
  encodeTo6(code12, bytes, codeOffset);
  bytes.set(multihash, hashOffset);
  return bytes;
};
var cidSymbol6 = Symbol.for("@ipld/js-cid/CID");

// node_modules/uint8arrays/node_modules/multiformats/src/basics.js
var bases2 = { ...identity_exports3, ...base2_exports2, ...base8_exports2, ...base10_exports2, ...base16_exports2, ...base32_exports2, ...base36_exports2, ...base58_exports2, ...base64_exports2, ...base256emoji_exports2 };
var hashes2 = { ...sha2_browser_exports2, ...identity_exports4 };

// node_modules/uint8arrays/dist/src/util/as-uint8array.js
function asUint8Array(buf2) {
  if (globalThis.Buffer != null) {
    return new Uint8Array(buf2.buffer, buf2.byteOffset, buf2.byteLength);
  }
  return buf2;
}

// node_modules/uint8arrays/dist/src/alloc.js
function allocUnsafe(size = 0) {
  if (globalThis.Buffer?.allocUnsafe != null) {
    return asUint8Array(globalThis.Buffer.allocUnsafe(size));
  }
  return new Uint8Array(size);
}

// node_modules/uint8arrays/dist/src/util/bases.js
function createCodec(name12, prefix, encode42, decode58) {
  return {
    name: name12,
    prefix,
    encoder: {
      name: name12,
      prefix,
      encode: encode42
    },
    decoder: {
      decode: decode58
    }
  };
}
var string = createCodec("utf8", "u", (buf2) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf2);
}, (str) => {
  const encoder = new TextEncoder();
  return encoder.encode(str.substring(1));
});
var ascii = createCodec("ascii", "a", (buf2) => {
  let string3 = "a";
  for (let i = 0; i < buf2.length; i++) {
    string3 += String.fromCharCode(buf2[i]);
  }
  return string3;
}, (str) => {
  str = str.substring(1);
  const buf2 = allocUnsafe(str.length);
  for (let i = 0; i < str.length; i++) {
    buf2[i] = str.charCodeAt(i);
  }
  return buf2;
});
var BASES = {
  utf8: string,
  "utf-8": string,
  hex: bases2.base16,
  latin1: ascii,
  ascii,
  binary: ascii,
  ...bases2
};
var bases_default = BASES;

// node_modules/uint8arrays/dist/src/to-string.js
function toString4(array, encoding = "utf8") {
  const base14 = bases_default[encoding];
  if (base14 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString("utf8");
  }
  return base14.encoder.encode(array).substring(1);
}

// node_modules/@multiformats/multiaddr/dist/src/ip.js
var isV4 = isIPv4;
var isV6 = isIPv6;
var toBytes3 = function(ip) {
  let offset = 0;
  ip = ip.toString().trim();
  if (isV4(ip)) {
    const bytes = new Uint8Array(offset + 4);
    ip.split(/\./g).forEach((byte) => {
      bytes[offset++] = parseInt(byte, 10) & 255;
    });
    return bytes;
  }
  if (isV6(ip)) {
    const sections = ip.split(":", 8);
    let i;
    for (i = 0; i < sections.length; i++) {
      const isv4 = isV4(sections[i]);
      let v4Buffer;
      if (isv4) {
        v4Buffer = toBytes3(sections[i]);
        sections[i] = toString4(v4Buffer.slice(0, 2), "base16");
      }
      if (v4Buffer != null && ++i < 8) {
        sections.splice(i, 0, toString4(v4Buffer.slice(2, 4), "base16"));
      }
    }
    if (sections[0] === "") {
      while (sections.length < 8)
        sections.unshift("0");
    } else if (sections[sections.length - 1] === "") {
      while (sections.length < 8)
        sections.push("0");
    } else if (sections.length < 8) {
      for (i = 0; i < sections.length && sections[i] !== ""; i++)
        ;
      const argv = [i, 1];
      for (i = 9 - sections.length; i > 0; i--) {
        argv.push("0");
      }
      sections.splice.apply(sections, argv);
    }
    const bytes = new Uint8Array(offset + 16);
    for (i = 0; i < sections.length; i++) {
      const word = parseInt(sections[i], 16);
      bytes[offset++] = word >> 8 & 255;
      bytes[offset++] = word & 255;
    }
    return bytes;
  }
  throw new Error("invalid ip address");
};
var toString5 = function(buf2, offset = 0, length11) {
  offset = ~~offset;
  length11 = length11 ?? buf2.length - offset;
  const view = new DataView(buf2.buffer);
  if (length11 === 4) {
    const result = [];
    for (let i = 0; i < length11; i++) {
      result.push(buf2[offset + i]);
    }
    return result.join(".");
  }
  if (length11 === 16) {
    const result = [];
    for (let i = 0; i < length11; i += 2) {
      result.push(view.getUint16(offset + i).toString(16));
    }
    return result.join(":").replace(/(^|:)0(:0)*:0(:|$)/, "$1::$3").replace(/:{3,4}/, "::");
  }
  return "";
};

// node_modules/@multiformats/multiaddr/dist/src/protocols-table.js
var V = -1;
var names = {};
var codes = {};
var table = [
  [4, 32, "ip4"],
  [6, 16, "tcp"],
  [33, 16, "dccp"],
  [41, 128, "ip6"],
  [42, V, "ip6zone"],
  [43, 8, "ipcidr"],
  [53, V, "dns", true],
  [54, V, "dns4", true],
  [55, V, "dns6", true],
  [56, V, "dnsaddr", true],
  [132, 16, "sctp"],
  [273, 16, "udp"],
  [275, 0, "p2p-webrtc-star"],
  [276, 0, "p2p-webrtc-direct"],
  [277, 0, "p2p-stardust"],
  [280, 0, "webrtc"],
  [281, 0, "webrtc-w3c"],
  [290, 0, "p2p-circuit"],
  [301, 0, "udt"],
  [302, 0, "utp"],
  [400, V, "unix", false, true],
  // `ipfs` is added before `p2p` for legacy support.
  // All text representations will default to `p2p`, but `ipfs` will
  // still be supported
  [421, V, "ipfs"],
  // `p2p` is the preferred name for 421, and is now the default
  [421, V, "p2p"],
  [443, 0, "https"],
  [444, 96, "onion"],
  [445, 296, "onion3"],
  [446, V, "garlic64"],
  [448, 0, "tls"],
  [449, V, "sni"],
  [460, 0, "quic"],
  [461, 0, "quic-v1"],
  [465, 0, "webtransport"],
  [466, V, "certhash"],
  [477, 0, "ws"],
  [478, 0, "wss"],
  [479, 0, "p2p-websocket-star"],
  [480, 0, "http"],
  [777, V, "memory"]
];
table.forEach((row) => {
  const proto = createProtocol(...row);
  codes[proto.code] = proto;
  names[proto.name] = proto;
});
function createProtocol(code12, size, name12, resolvable, path) {
  return {
    code: code12,
    size,
    name: name12,
    resolvable: Boolean(resolvable),
    path: Boolean(path)
  };
}
function getProtocol(proto) {
  if (typeof proto === "number") {
    if (codes[proto] != null) {
      return codes[proto];
    }
    throw new Error(`no protocol with code: ${proto}`);
  } else if (typeof proto === "string") {
    if (names[proto] != null) {
      return names[proto];
    }
    throw new Error(`no protocol with name: ${proto}`);
  }
  throw new Error(`invalid protocol id type: ${typeof proto}`);
}

// node_modules/@multiformats/multiaddr/node_modules/multiformats/vendor/varint.js
var encode_17 = encode27;
var MSB7 = 128;
var REST7 = 127;
var MSBALL7 = ~REST7;
var INT7 = Math.pow(2, 31);
function encode27(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT7) {
    out[offset++] = num & 255 | MSB7;
    num /= 128;
  }
  while (num & MSBALL7) {
    out[offset++] = num & 255 | MSB7;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode27.bytes = offset - oldOffset + 1;
  return out;
}
var decode37 = read7;
var MSB$17 = 128;
var REST$17 = 127;
function read7(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
  do {
    if (counter >= l) {
      read7.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf2[counter++];
    res += shift < 28 ? (b & REST$17) << shift : (b & REST$17) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$17);
  read7.bytes = counter - offset;
  return res;
}
var N17 = Math.pow(2, 7);
var N27 = Math.pow(2, 14);
var N37 = Math.pow(2, 21);
var N47 = Math.pow(2, 28);
var N57 = Math.pow(2, 35);
var N67 = Math.pow(2, 42);
var N77 = Math.pow(2, 49);
var N87 = Math.pow(2, 56);
var N97 = Math.pow(2, 63);
var length7 = function(value) {
  return value < N17 ? 1 : value < N27 ? 2 : value < N37 ? 3 : value < N47 ? 4 : value < N57 ? 5 : value < N67 ? 6 : value < N77 ? 7 : value < N87 ? 8 : value < N97 ? 9 : 10;
};
var varint7 = {
  encode: encode_17,
  decode: decode37,
  encodingLength: length7
};
var _brrp_varint7 = varint7;
var varint_default7 = _brrp_varint7;

// node_modules/@multiformats/multiaddr/node_modules/multiformats/src/varint.js
var decode38 = (data, offset = 0) => {
  const code12 = varint_default7.decode(data, offset);
  return [code12, varint_default7.decode.bytes];
};
var encodeTo7 = (int, target, offset = 0) => {
  varint_default7.encode(int, target, offset);
  return target;
};
var encodingLength7 = (int) => {
  return varint_default7.encodingLength(int);
};

// node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bytes.js
var empty7 = new Uint8Array(0);
var equals13 = (aa, bb) => {
  if (aa === bb) return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
};
var coerce7 = (o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array") return o;
  if (o instanceof ArrayBuffer) return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};
var fromString4 = (str) => new TextEncoder().encode(str);
var toString6 = (b) => new TextDecoder().decode(b);

// node_modules/@multiformats/multiaddr/node_modules/multiformats/src/hashes/digest.js
var create7 = (code12, digest6) => {
  const size = digest6.byteLength;
  const sizeOffset = encodingLength7(code12);
  const digestOffset = sizeOffset + encodingLength7(size);
  const bytes = new Uint8Array(digestOffset + size);
  encodeTo7(code12, bytes, 0);
  encodeTo7(size, bytes, sizeOffset);
  bytes.set(digest6, digestOffset);
  return new Digest7(code12, size, digest6, bytes);
};
var decode39 = (multihash) => {
  const bytes = coerce7(multihash);
  const [code12, sizeOffset] = decode38(bytes);
  const [size, digestOffset] = decode38(bytes.subarray(sizeOffset));
  const digest6 = bytes.subarray(sizeOffset + digestOffset);
  if (digest6.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest7(code12, size, digest6, bytes);
};
var equals14 = (a, b) => {
  if (a === b) {
    return true;
  } else {
    const data = (
      /** @type {{code?:unknown, size?:unknown, bytes?:unknown}} */
      b
    );
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals13(a.bytes, data.bytes);
  }
};
var Digest7 = class {
  /**
   * Creates a multihash digest.
   *
   * @param {Code} code
   * @param {Size} size
   * @param {Uint8Array} digest
   * @param {Uint8Array} bytes
   */
  constructor(code12, size, digest6, bytes) {
    this.code = code12;
    this.size = size;
    this.digest = digest6;
    this.bytes = bytes;
  }
};

// node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/base58.js
var base58_exports3 = {};
__export(base58_exports3, {
  base58btc: () => base58btc7,
  base58flickr: () => base58flickr7
});

// node_modules/@multiformats/multiaddr/node_modules/multiformats/vendor/base-x.js
function base7(ALPHABET, name12) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode42(source) {
    if (source instanceof Uint8Array) ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length11 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length11) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length11 = i2;
      pbegin++;
    }
    var it2 = size - length11;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length11 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length11) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length11 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length11;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode58(string3) {
    var buffer2 = decodeUnsafe(string3);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name12} character`);
  }
  return {
    encode: encode42,
    decodeUnsafe,
    decode: decode58
  };
}
var src7 = base7;
var _brrp__multiformats_scope_baseX7 = src7;
var base_x_default7 = _brrp__multiformats_scope_baseX7;

// node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/base.js
var Encoder7 = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   */
  constructor(name12, prefix, baseEncode) {
    this.name = name12;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {API.Multibase<Prefix>}
   */
  encode(bytes) {
    if (bytes instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder7 = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name12, prefix, baseDecode) {
    this.name = name12;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = /** @type {number} */
    prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  /**
   * @param {string} text
   */
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or7(this, decoder);
  }
};
var ComposedDecoder7 = class {
  /**
   * @param {Decoders<Prefix>} decoders
   */
  constructor(decoders3) {
    this.decoders = decoders3;
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or7(this, decoder);
  }
  /**
   * @param {string} input
   * @returns {Uint8Array}
   */
  decode(input) {
    const prefix = (
      /** @type {Prefix} */
      input[0]
    );
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or7 = (left, right) => new ComposedDecoder7(
  /** @type {Decoders<L|R>} */
  {
    ...left.decoders || { [
      /** @type API.UnibaseDecoder<L> */
      left.prefix
    ]: left },
    ...right.decoders || { [
      /** @type API.UnibaseDecoder<R> */
      right.prefix
    ]: right }
  }
);
var Codec7 = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name12, prefix, baseEncode, baseDecode) {
    this.name = name12;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder7(name12, prefix, baseEncode);
    this.decoder = new Decoder7(name12, prefix, baseDecode);
  }
  /**
   * @param {Uint8Array} input
   */
  encode(input) {
    return this.encoder.encode(input);
  }
  /**
   * @param {string} input
   */
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from9 = ({ name: name12, prefix, encode: encode42, decode: decode58 }) => new Codec7(name12, prefix, encode42, decode58);
var baseX7 = ({ prefix, name: name12, alphabet: alphabet7 }) => {
  const { encode: encode42, decode: decode58 } = base_x_default7(alphabet7, name12);
  return from9({
    prefix,
    name: name12,
    encode: encode42,
    /**
     * @param {string} text
     */
    decode: (text) => coerce7(decode58(text))
  });
};
var decode40 = (string3, alphabet7, bitsPerChar, name12) => {
  const codes2 = {};
  for (let i = 0; i < alphabet7.length; ++i) {
    codes2[alphabet7[i]] = i;
  }
  let end = string3.length;
  while (string3[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes2[string3[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name12} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer2 >> bits;
    }
  }
  if (bits >= bitsPerChar || 255 & buffer2 << 8 - bits) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
var encode28 = (data, alphabet7, bitsPerChar) => {
  const pad = alphabet7[alphabet7.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer2 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer2 = buffer2 << 8 | data[i];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet7[mask & buffer2 >> bits];
    }
  }
  if (bits) {
    out += alphabet7[mask & buffer2 << bitsPerChar - bits];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
var rfc46487 = ({ name: name12, prefix, bitsPerChar, alphabet: alphabet7 }) => {
  return from9({
    prefix,
    name: name12,
    encode(input) {
      return encode28(input, alphabet7, bitsPerChar);
    },
    decode(input) {
      return decode40(input, alphabet7, bitsPerChar, name12);
    }
  });
};

// node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/base58.js
var base58btc7 = baseX7({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr7 = baseX7({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/base32.js
var base32_exports3 = {};
__export(base32_exports3, {
  base32: () => base327,
  base32hex: () => base32hex7,
  base32hexpad: () => base32hexpad7,
  base32hexpadupper: () => base32hexpadupper7,
  base32hexupper: () => base32hexupper7,
  base32pad: () => base32pad7,
  base32padupper: () => base32padupper7,
  base32upper: () => base32upper7,
  base32z: () => base32z7
});
var base327 = rfc46487({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper7 = rfc46487({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad7 = rfc46487({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper7 = rfc46487({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex7 = rfc46487({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper7 = rfc46487({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad7 = rfc46487({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper7 = rfc46487({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z7 = rfc46487({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@multiformats/multiaddr/node_modules/multiformats/src/cid.js
var format8 = (link, base14) => {
  const { bytes, version } = link;
  switch (version) {
    case 0:
      return toStringV07(
        bytes,
        baseCache7(link),
        /** @type {API.MultibaseEncoder<"z">} */
        base14 || base58btc7.encoder
      );
    default:
      return toStringV17(
        bytes,
        baseCache7(link),
        /** @type {API.MultibaseEncoder<Prefix>} */
        base14 || base327.encoder
      );
  }
};
var cache7 = /* @__PURE__ */ new WeakMap();
var baseCache7 = (cid) => {
  const baseCache11 = cache7.get(cid);
  if (baseCache11 == null) {
    const baseCache12 = /* @__PURE__ */ new Map();
    cache7.set(cid, baseCache12);
    return baseCache12;
  }
  return baseCache11;
};
var CID7 = class _CID {
  /**
   * @param {Version} version - Version of the CID
   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.
   * @param {Uint8Array} bytes
   *
   */
  constructor(version, code12, multihash, bytes) {
    this.code = code12;
    this.version = version;
    this.multihash = multihash;
    this.bytes = bytes;
    this["/"] = bytes;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  /**
   * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}
   */
  toV0() {
    switch (this.version) {
      case 0: {
        return (
          /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
          this
        );
      }
      case 1: {
        const { code: code12, multihash } = this;
        if (code12 !== DAG_PB_CODE7) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE7) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return (
          /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
          _CID.createV0(
            /** @type {API.MultihashDigest<API.SHA_256>} */
            multihash
          )
        );
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 0. This is a bug please report`
        );
      }
    }
  }
  /**
   * @returns {CID<Data, Format, Alg, 1>}
   */
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code12, digest: digest6 } = this.multihash;
        const multihash = create7(code12, digest6);
        return (
          /** @type {CID<Data, Format, Alg, 1>} */
          _CID.createV1(this.code, multihash)
        );
      }
      case 1: {
        return (
          /** @type {CID<Data, Format, Alg, 1>} */
          this
        );
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 1. This is a bug please report`
        );
      }
    }
  }
  /**
   * @param {unknown} other
   * @returns {other is CID<Data, Format, Alg, Version>}
   */
  equals(other) {
    return _CID.equals(this, other);
  }
  /**
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @param {API.Link<Data, Format, Alg, Version>} self
   * @param {unknown} other
   * @returns {other is CID}
   */
  static equals(self2, other) {
    const unknown = (
      /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */
      other
    );
    return unknown && self2.code === unknown.code && self2.version === unknown.version && equals14(self2.multihash, unknown.multihash);
  }
  /**
   * @param {API.MultibaseEncoder<string>} [base]
   * @returns {string}
   */
  toString(base14) {
    return format8(this, base14);
  }
  toJSON() {
    return { "/": format8(this) };
  }
  link() {
    return this;
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   *
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @template {unknown} U
   * @param {API.Link<Data, Format, Alg, Version>|U} input
   * @returns {CID<Data, Format, Alg, Version>|null}
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value = (
      /** @type {any} */
      input
    );
    if (value instanceof _CID) {
      return value;
    } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
      const { version, code: code12, multihash, bytes } = value;
      return new _CID(
        version,
        code12,
        /** @type {API.MultihashDigest<Alg>} */
        multihash,
        bytes || encodeCID7(version, code12, multihash.bytes)
      );
    } else if (value[cidSymbol7] === true) {
      const { version, multihash, code: code12 } = value;
      const digest6 = (
        /** @type {API.MultihashDigest<Alg>} */
        decode39(multihash)
      );
      return _CID.create(version, code12, digest6);
    } else {
      return null;
    }
  }
  /**
   *
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @param {Version} version - Version of the CID
   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.
   * @returns {CID<Data, Format, Alg, Version>}
   */
  static create(version, code12, digest6) {
    if (typeof code12 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest6.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version) {
      case 0: {
        if (code12 !== DAG_PB_CODE7) {
          throw new Error(
            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE7}) block encoding`
          );
        } else {
          return new _CID(version, code12, digest6, digest6.bytes);
        }
      }
      case 1: {
        const bytes = encodeCID7(version, code12, digest6.bytes);
        return new _CID(version, code12, digest6, bytes);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   *
   * @template {unknown} [T=unknown]
   * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.
   * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}
   */
  static createV0(digest6) {
    return _CID.create(0, DAG_PB_CODE7, digest6);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @param {Code} code - Content encoding format code.
   * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.
   * @returns {CID<Data, Code, Alg, 1>}
   */
  static createV1(code12, digest6) {
    return _CID.create(1, code12, digest6);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   *
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @template {API.Version} Ver
   * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes
   * @returns {CID<Data, Code, Alg, Ver>}
   */
  static decode(bytes) {
    const [cid, remainder] = _CID.decodeFirst(bytes);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   *
   * @template {unknown} T
   * @template {number} C
   * @template {number} A
   * @template {API.Version} V
   * @param {API.ByteView<API.Link<T, C, A, V>>} bytes
   * @returns {[CID<T, C, A, V>, Uint8Array]}
   */
  static decodeFirst(bytes) {
    const specs = _CID.inspectBytes(bytes);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce7(
      bytes.subarray(prefixSize, prefixSize + specs.multihashSize)
    );
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(
      specs.multihashSize - specs.digestSize
    );
    const digest6 = new Digest7(
      specs.multihashCode,
      specs.digestSize,
      digestBytes,
      multihashBytes
    );
    const cid = specs.version === 0 ? _CID.createV0(
      /** @type {API.MultihashDigest<API.SHA_256>} */
      digest6
    ) : _CID.createV1(specs.codec, digest6);
    return [
      /** @type {CID<T, C, A, V>} */
      cid,
      bytes.subarray(specs.size)
    ];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   *
   * @template {unknown} T
   * @template {number} C
   * @template {number} A
   * @template {API.Version} V
   * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes
   * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i, length11] = decode38(initialBytes.subarray(offset));
      offset += length11;
      return i;
    };
    let version = (
      /** @type {V} */
      next()
    );
    let codec = (
      /** @type {C} */
      DAG_PB_CODE7
    );
    if (
      /** @type {number} */
      version === 18
    ) {
      version = /** @type {V} */
      0;
      offset = 0;
    } else {
      codec = /** @type {C} */
      next();
    }
    if (version !== 0 && version !== 1) {
      throw new RangeError(`Invalid CID version ${version}`);
    }
    const prefixSize = offset;
    const multihashCode = (
      /** @type {A} */
      next()
    );
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   *
   * @template {string} Prefix
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @template {API.Version} Ver
   * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source
   * @param {API.MultibaseDecoder<Prefix>} [base]
   * @returns {CID<Data, Code, Alg, Ver>}
   */
  static parse(source, base14) {
    const [prefix, bytes] = parseCIDtoBytes7(source, base14);
    const cid = _CID.decode(bytes);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache7(cid).set(prefix, source);
    return cid;
  }
};
var parseCIDtoBytes7 = (source, base14) => {
  switch (source[0]) {
    // CIDv0 is parsed differently
    case "Q": {
      const decoder = base14 || base58btc7;
      return [
        /** @type {Prefix} */
        base58btc7.prefix,
        decoder.decode(`${base58btc7.prefix}${source}`)
      ];
    }
    case base58btc7.prefix: {
      const decoder = base14 || base58btc7;
      return [
        /** @type {Prefix} */
        base58btc7.prefix,
        decoder.decode(source)
      ];
    }
    case base327.prefix: {
      const decoder = base14 || base327;
      return [
        /** @type {Prefix} */
        base327.prefix,
        decoder.decode(source)
      ];
    }
    default: {
      if (base14 == null) {
        throw Error(
          "To parse non base32 or base58btc encoded CID multibase decoder must be provided"
        );
      }
      return [
        /** @type {Prefix} */
        source[0],
        base14.decode(source)
      ];
    }
  }
};
var toStringV07 = (bytes, cache11, base14) => {
  const { prefix } = base14;
  if (prefix !== base58btc7.prefix) {
    throw Error(`Cannot string encode V0 in ${base14.name} encoding`);
  }
  const cid = cache11.get(prefix);
  if (cid == null) {
    const cid2 = base14.encode(bytes).slice(1);
    cache11.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var toStringV17 = (bytes, cache11, base14) => {
  const { prefix } = base14;
  const cid = cache11.get(prefix);
  if (cid == null) {
    const cid2 = base14.encode(bytes);
    cache11.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var DAG_PB_CODE7 = 112;
var SHA_256_CODE7 = 18;
var encodeCID7 = (version, code12, multihash) => {
  const codeOffset = encodingLength7(version);
  const hashOffset = codeOffset + encodingLength7(code12);
  const bytes = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo7(version, bytes, 0);
  encodeTo7(code12, bytes, codeOffset);
  bytes.set(multihash, hashOffset);
  return bytes;
};
var cidSymbol7 = Symbol.for("@ipld/js-cid/CID");

// node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/identity.js
var identity_exports5 = {};
__export(identity_exports5, {
  identity: () => identity5
});
var identity5 = from9({
  prefix: "\0",
  name: "identity",
  encode: (buf2) => toString6(buf2),
  decode: (str) => fromString4(str)
});

// node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/base2.js
var base2_exports3 = {};
__export(base2_exports3, {
  base2: () => base24
});
var base24 = rfc46487({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/base8.js
var base8_exports3 = {};
__export(base8_exports3, {
  base8: () => base83
});
var base83 = rfc46487({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/base10.js
var base10_exports3 = {};
__export(base10_exports3, {
  base10: () => base103
});
var base103 = baseX7({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/base16.js
var base16_exports3 = {};
__export(base16_exports3, {
  base16: () => base163,
  base16upper: () => base16upper3
});
var base163 = rfc46487({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper3 = rfc46487({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/base36.js
var base36_exports3 = {};
__export(base36_exports3, {
  base36: () => base366,
  base36upper: () => base36upper6
});
var base366 = baseX7({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper6 = baseX7({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/base64.js
var base64_exports3 = {};
__export(base64_exports3, {
  base64: () => base645,
  base64pad: () => base64pad5,
  base64url: () => base64url5,
  base64urlpad: () => base64urlpad5
});
var base645 = rfc46487({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad5 = rfc46487({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url5 = rfc46487({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad5 = rfc46487({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/@multiformats/multiaddr/node_modules/multiformats/src/bases/base256emoji.js
var base256emoji_exports3 = {};
__export(base256emoji_exports3, {
  base256emoji: () => base256emoji3
});
var alphabet4 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars3 = (
  /** @type {string[]} */
  alphabet4.reduce(
    (p, c, i) => {
      p[i] = c;
      return p;
    },
    /** @type {string[]} */
    []
  )
);
var alphabetCharsToBytes3 = (
  /** @type {number[]} */
  alphabet4.reduce(
    (p, c, i) => {
      p[
        /** @type {number} */
        c.codePointAt(0)
      ] = i;
      return p;
    },
    /** @type {number[]} */
    []
  )
);
function encode29(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars3[c];
    return p;
  }, "");
}
function decode41(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes3[
      /** @type {number} */
      char.codePointAt(0)
    ];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji3 = from9({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode29,
  decode: decode41
});

// node_modules/@multiformats/multiaddr/node_modules/multiformats/src/hashes/sha2-browser.js
var sha2_browser_exports3 = {};
__export(sha2_browser_exports3, {
  sha256: () => sha2565,
  sha512: () => sha5124
});

// node_modules/@multiformats/multiaddr/node_modules/multiformats/src/hashes/hasher.js
var from10 = ({ name: name12, code: code12, encode: encode42 }) => new Hasher3(name12, code12, encode42);
var Hasher3 = class {
  /**
   *
   * @param {Name} name
   * @param {Code} code
   * @param {(input: Uint8Array) => Await<Uint8Array>} encode
   */
  constructor(name12, code12, encode42) {
    this.name = name12;
    this.code = code12;
    this.encode = encode42;
  }
  /**
   * @param {Uint8Array} input
   * @returns {Await<Digest.Digest<Code, number>>}
   */
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create7(this.code, result) : result.then((digest6) => create7(this.code, digest6));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/@multiformats/multiaddr/node_modules/multiformats/src/hashes/sha2-browser.js
var sha3 = (name12) => (
  /**
   * @param {Uint8Array} data
   */
  async (data) => new Uint8Array(await crypto.subtle.digest(name12, data))
);
var sha2565 = from10({
  name: "sha2-256",
  code: 18,
  encode: sha3("SHA-256")
});
var sha5124 = from10({
  name: "sha2-512",
  code: 19,
  encode: sha3("SHA-512")
});

// node_modules/@multiformats/multiaddr/node_modules/multiformats/src/hashes/identity.js
var identity_exports6 = {};
__export(identity_exports6, {
  identity: () => identity6
});
var code9 = 0;
var name9 = "identity";
var encode30 = coerce7;
var digest3 = (input) => create7(code9, encode30(input));
var identity6 = { code: code9, name: name9, encode: encode30, digest: digest3 };

// node_modules/@multiformats/multiaddr/node_modules/multiformats/src/codecs/json.js
var textEncoder6 = new TextEncoder();
var textDecoder5 = new TextDecoder();

// node_modules/@multiformats/multiaddr/node_modules/multiformats/src/basics.js
var bases3 = { ...identity_exports5, ...base2_exports3, ...base8_exports3, ...base10_exports3, ...base16_exports3, ...base32_exports3, ...base36_exports3, ...base58_exports3, ...base64_exports3, ...base256emoji_exports3 };
var hashes3 = { ...sha2_browser_exports3, ...identity_exports6 };

// node_modules/@multiformats/multiaddr/dist/src/convert.js
var import_varint8 = __toESM(require_varint(), 1);

// node_modules/uint8arrays/dist/src/from-string.js
function fromString5(string3, encoding = "utf8") {
  const base14 = bases_default[encoding];
  if (base14 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return asUint8Array(globalThis.Buffer.from(string3, "utf-8"));
  }
  return base14.decoder.decode(`${base14.prefix}${string3}`);
}

// node_modules/uint8arrays/dist/src/concat.js
function concat2(arrays, length11) {
  if (length11 == null) {
    length11 = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output = allocUnsafe(length11);
  let offset = 0;
  for (const arr of arrays) {
    output.set(arr, offset);
    offset += arr.length;
  }
  return asUint8Array(output);
}

// node_modules/@multiformats/multiaddr/dist/src/convert.js
function convertToString(proto, buf2) {
  const protocol = getProtocol(proto);
  switch (protocol.code) {
    case 4:
    // ipv4
    case 41:
      return bytes2ip(buf2);
    case 42:
      return bytes2str(buf2);
    case 6:
    // tcp
    case 273:
    // udp
    case 33:
    // dccp
    case 132:
      return bytes2port(buf2).toString();
    case 53:
    // dns
    case 54:
    // dns4
    case 55:
    // dns6
    case 56:
    // dnsaddr
    case 400:
    // unix
    case 449:
    // sni
    case 777:
      return bytes2str(buf2);
    case 421:
      return bytes2mh(buf2);
    case 444:
      return bytes2onion(buf2);
    case 445:
      return bytes2onion(buf2);
    case 466:
      return bytes2mb(buf2);
    default:
      return toString4(buf2, "base16");
  }
}
function convertToBytes(proto, str) {
  const protocol = getProtocol(proto);
  switch (protocol.code) {
    case 4:
      return ip2bytes(str);
    case 41:
      return ip2bytes(str);
    case 42:
      return str2bytes(str);
    case 6:
    // tcp
    case 273:
    // udp
    case 33:
    // dccp
    case 132:
      return port2bytes(parseInt(str, 10));
    case 53:
    // dns
    case 54:
    // dns4
    case 55:
    // dns6
    case 56:
    // dnsaddr
    case 400:
    // unix
    case 449:
    // sni
    case 777:
      return str2bytes(str);
    case 421:
      return mh2bytes(str);
    case 444:
      return onion2bytes(str);
    case 445:
      return onion32bytes(str);
    case 466:
      return mb2bytes(str);
    default:
      return fromString5(str, "base16");
  }
}
var decoders = Object.values(bases3).map((c) => c.decoder);
var anybaseDecoder = (function() {
  let acc = decoders[0].or(decoders[1]);
  decoders.slice(2).forEach((d) => acc = acc.or(d));
  return acc;
})();
function ip2bytes(ipString) {
  if (!isIP(ipString)) {
    throw new Error("invalid ip address");
  }
  return toBytes3(ipString);
}
function bytes2ip(ipBuff) {
  const ipString = toString5(ipBuff, 0, ipBuff.length);
  if (ipString == null) {
    throw new Error("ipBuff is required");
  }
  if (!isIP(ipString)) {
    throw new Error("invalid ip address");
  }
  return ipString;
}
function port2bytes(port) {
  const buf2 = new ArrayBuffer(2);
  const view = new DataView(buf2);
  view.setUint16(0, port);
  return new Uint8Array(buf2);
}
function bytes2port(buf2) {
  const view = new DataView(buf2.buffer);
  return view.getUint16(buf2.byteOffset);
}
function str2bytes(str) {
  const buf2 = fromString5(str);
  const size = Uint8Array.from(import_varint8.default.encode(buf2.length));
  return concat2([size, buf2], size.length + buf2.length);
}
function bytes2str(buf2) {
  const size = import_varint8.default.decode(buf2);
  buf2 = buf2.slice(import_varint8.default.decode.bytes);
  if (buf2.length !== size) {
    throw new Error("inconsistent lengths");
  }
  return toString4(buf2);
}
function mh2bytes(hash) {
  let mh;
  if (hash[0] === "Q" || hash[0] === "1") {
    mh = decode39(base58btc7.decode(`z${hash}`)).bytes;
  } else {
    mh = CID7.parse(hash).multihash.bytes;
  }
  const size = Uint8Array.from(import_varint8.default.encode(mh.length));
  return concat2([size, mh], size.length + mh.length);
}
function mb2bytes(mbstr) {
  const mb = anybaseDecoder.decode(mbstr);
  const size = Uint8Array.from(import_varint8.default.encode(mb.length));
  return concat2([size, mb], size.length + mb.length);
}
function bytes2mb(buf2) {
  const size = import_varint8.default.decode(buf2);
  const hash = buf2.slice(import_varint8.default.decode.bytes);
  if (hash.length !== size) {
    throw new Error("inconsistent lengths");
  }
  return "u" + toString4(hash, "base64url");
}
function bytes2mh(buf2) {
  const size = import_varint8.default.decode(buf2);
  const address = buf2.slice(import_varint8.default.decode.bytes);
  if (address.length !== size) {
    throw new Error("inconsistent lengths");
  }
  return toString4(address, "base58btc");
}
function onion2bytes(str) {
  const addr = str.split(":");
  if (addr.length !== 2) {
    throw new Error(`failed to parse onion addr: ["'${addr.join('", "')}'"]' does not contain a port number`);
  }
  if (addr[0].length !== 16) {
    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion address.`);
  }
  const buf2 = base327.decode("b" + addr[0]);
  const port = parseInt(addr[1], 10);
  if (port < 1 || port > 65536) {
    throw new Error("Port number is not in range(1, 65536)");
  }
  const portBuf = port2bytes(port);
  return concat2([buf2, portBuf], buf2.length + portBuf.length);
}
function onion32bytes(str) {
  const addr = str.split(":");
  if (addr.length !== 2) {
    throw new Error(`failed to parse onion addr: ["'${addr.join('", "')}'"]' does not contain a port number`);
  }
  if (addr[0].length !== 56) {
    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion3 address.`);
  }
  const buf2 = base327.decode(`b${addr[0]}`);
  const port = parseInt(addr[1], 10);
  if (port < 1 || port > 65536) {
    throw new Error("Port number is not in range(1, 65536)");
  }
  const portBuf = port2bytes(port);
  return concat2([buf2, portBuf], buf2.length + portBuf.length);
}
function bytes2onion(buf2) {
  const addrBytes = buf2.slice(0, buf2.length - 2);
  const portBytes = buf2.slice(buf2.length - 2);
  const addr = toString4(addrBytes, "base32");
  const port = bytes2port(portBytes);
  return `${addr}:${port}`;
}

// node_modules/@multiformats/multiaddr/dist/src/codec.js
var import_varint9 = __toESM(require_varint(), 1);
function stringToStringTuples(str) {
  const tuples = [];
  const parts = str.split("/").slice(1);
  if (parts.length === 1 && parts[0] === "") {
    return [];
  }
  for (let p = 0; p < parts.length; p++) {
    const part = parts[p];
    const proto = getProtocol(part);
    if (proto.size === 0) {
      tuples.push([part]);
      continue;
    }
    p++;
    if (p >= parts.length) {
      throw ParseError("invalid address: " + str);
    }
    if (proto.path === true) {
      tuples.push([
        part,
        // should we need to check each path part to see if it's a proto?
        // This would allow for other protocols to be added after a unix path,
        // however it would have issues if the path had a protocol name in the path
        cleanPath(parts.slice(p).join("/"))
      ]);
      break;
    }
    tuples.push([part, parts[p]]);
  }
  return tuples;
}
function stringTuplesToString(tuples) {
  const parts = [];
  tuples.map((tup) => {
    const proto = protoFromTuple(tup);
    parts.push(proto.name);
    if (tup.length > 1 && tup[1] != null) {
      parts.push(tup[1]);
    }
    return null;
  });
  return cleanPath(parts.join("/"));
}
function stringTuplesToTuples(tuples) {
  return tuples.map((tup) => {
    if (!Array.isArray(tup)) {
      tup = [tup];
    }
    const proto = protoFromTuple(tup);
    if (tup.length > 1) {
      return [proto.code, convertToBytes(proto.code, tup[1])];
    }
    return [proto.code];
  });
}
function tuplesToStringTuples(tuples) {
  return tuples.map((tup) => {
    const proto = protoFromTuple(tup);
    if (tup[1] != null) {
      return [proto.code, convertToString(proto.code, tup[1])];
    }
    return [proto.code];
  });
}
function tuplesToBytes(tuples) {
  return fromBytes(concat2(tuples.map((tup) => {
    const proto = protoFromTuple(tup);
    let buf2 = Uint8Array.from(import_varint9.default.encode(proto.code));
    if (tup.length > 1 && tup[1] != null) {
      buf2 = concat2([buf2, tup[1]]);
    }
    return buf2;
  })));
}
function sizeForAddr(p, addr) {
  if (p.size > 0) {
    return p.size / 8;
  } else if (p.size === 0) {
    return 0;
  } else {
    const size = import_varint9.default.decode(addr);
    return size + (import_varint9.default.decode.bytes ?? 0);
  }
}
function bytesToTuples(buf2) {
  const tuples = [];
  let i = 0;
  while (i < buf2.length) {
    const code12 = import_varint9.default.decode(buf2, i);
    const n = import_varint9.default.decode.bytes ?? 0;
    const p = getProtocol(code12);
    const size = sizeForAddr(p, buf2.slice(i + n));
    if (size === 0) {
      tuples.push([code12]);
      i += n;
      continue;
    }
    const addr = buf2.slice(i + n, i + n + size);
    i += size + n;
    if (i > buf2.length) {
      throw ParseError("Invalid address Uint8Array: " + toString4(buf2, "base16"));
    }
    tuples.push([code12, addr]);
  }
  return tuples;
}
function bytesToString(buf2) {
  const a = bytesToTuples(buf2);
  const b = tuplesToStringTuples(a);
  return stringTuplesToString(b);
}
function stringToBytes(str) {
  str = cleanPath(str);
  const a = stringToStringTuples(str);
  const b = stringTuplesToTuples(a);
  return tuplesToBytes(b);
}
function fromString6(str) {
  return stringToBytes(str);
}
function fromBytes(buf2) {
  const err = validateBytes2(buf2);
  if (err != null) {
    throw err;
  }
  return Uint8Array.from(buf2);
}
function validateBytes2(buf2) {
  try {
    bytesToTuples(buf2);
  } catch (err) {
    return err;
  }
}
function cleanPath(str) {
  return "/" + str.trim().split("/").filter((a) => a).join("/");
}
function ParseError(str) {
  return new Error("Error parsing address: " + str);
}
function protoFromTuple(tup) {
  const proto = getProtocol(tup[0]);
  return proto;
}

// node_modules/@multiformats/multiaddr/dist/src/index.js
var import_varint10 = __toESM(require_varint(), 1);
var import_err_code = __toESM(require_err_code(), 1);

// node_modules/uint8arrays/dist/src/equals.js
function equals15(a, b) {
  if (a === b) {
    return true;
  }
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  for (let i = 0; i < a.byteLength; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}

// node_modules/@multiformats/multiaddr/dist/src/index.js
var __classPrivateFieldGet = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = function(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var _DefaultMultiaddr_string;
var _DefaultMultiaddr_tuples;
var _DefaultMultiaddr_stringTuples;
var _a;
var inspect = Symbol.for("nodejs.util.inspect.custom");
var DNS_CODES = [
  getProtocol("dns").code,
  getProtocol("dns4").code,
  getProtocol("dns6").code,
  getProtocol("dnsaddr").code
];
var resolvers = /* @__PURE__ */ new Map();
var symbol = Symbol.for("@multiformats/js-multiaddr/multiaddr");
function isMultiaddr(value) {
  return Boolean(value?.[symbol]);
}
var DefaultMultiaddr = class _DefaultMultiaddr {
  constructor(addr) {
    _DefaultMultiaddr_string.set(this, void 0);
    _DefaultMultiaddr_tuples.set(this, void 0);
    _DefaultMultiaddr_stringTuples.set(this, void 0);
    this[_a] = true;
    if (addr == null) {
      addr = "";
    }
    if (addr instanceof Uint8Array) {
      this.bytes = fromBytes(addr);
    } else if (typeof addr === "string") {
      if (addr.length > 0 && addr.charAt(0) !== "/") {
        throw new Error(`multiaddr "${addr}" must start with a "/"`);
      }
      this.bytes = fromString6(addr);
    } else if (isMultiaddr(addr)) {
      this.bytes = fromBytes(addr.bytes);
    } else {
      throw new Error("addr must be a string, Buffer, or another Multiaddr");
    }
  }
  toString() {
    if (__classPrivateFieldGet(this, _DefaultMultiaddr_string, "f") == null) {
      __classPrivateFieldSet(this, _DefaultMultiaddr_string, bytesToString(this.bytes), "f");
    }
    return __classPrivateFieldGet(this, _DefaultMultiaddr_string, "f");
  }
  toJSON() {
    return this.toString();
  }
  toOptions() {
    let family;
    let transport;
    let host;
    let port;
    let zone = "";
    const tcp = getProtocol("tcp");
    const udp = getProtocol("udp");
    const ip4 = getProtocol("ip4");
    const ip6 = getProtocol("ip6");
    const dns6 = getProtocol("dns6");
    const ip6zone = getProtocol("ip6zone");
    for (const [code12, value] of this.stringTuples()) {
      if (code12 === ip6zone.code) {
        zone = `%${value ?? ""}`;
      }
      if (DNS_CODES.includes(code12)) {
        transport = tcp.name;
        port = 443;
        host = `${value ?? ""}${zone}`;
        family = code12 === dns6.code ? 6 : 4;
      }
      if (code12 === tcp.code || code12 === udp.code) {
        transport = getProtocol(code12).name;
        port = parseInt(value ?? "");
      }
      if (code12 === ip4.code || code12 === ip6.code) {
        transport = getProtocol(code12).name;
        host = `${value ?? ""}${zone}`;
        family = code12 === ip6.code ? 6 : 4;
      }
    }
    if (family == null || transport == null || host == null || port == null) {
      throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}".');
    }
    const opts = {
      family,
      host,
      transport,
      port
    };
    return opts;
  }
  protos() {
    return this.protoCodes().map((code12) => Object.assign({}, getProtocol(code12)));
  }
  protoCodes() {
    const codes2 = [];
    const buf2 = this.bytes;
    let i = 0;
    while (i < buf2.length) {
      const code12 = import_varint10.default.decode(buf2, i);
      const n = import_varint10.default.decode.bytes ?? 0;
      const p = getProtocol(code12);
      const size = sizeForAddr(p, buf2.slice(i + n));
      i += size + n;
      codes2.push(code12);
    }
    return codes2;
  }
  protoNames() {
    return this.protos().map((proto) => proto.name);
  }
  tuples() {
    if (__classPrivateFieldGet(this, _DefaultMultiaddr_tuples, "f") == null) {
      __classPrivateFieldSet(this, _DefaultMultiaddr_tuples, bytesToTuples(this.bytes), "f");
    }
    return __classPrivateFieldGet(this, _DefaultMultiaddr_tuples, "f");
  }
  stringTuples() {
    if (__classPrivateFieldGet(this, _DefaultMultiaddr_stringTuples, "f") == null) {
      __classPrivateFieldSet(this, _DefaultMultiaddr_stringTuples, tuplesToStringTuples(this.tuples()), "f");
    }
    return __classPrivateFieldGet(this, _DefaultMultiaddr_stringTuples, "f");
  }
  encapsulate(addr) {
    addr = new _DefaultMultiaddr(addr);
    return new _DefaultMultiaddr(this.toString() + addr.toString());
  }
  decapsulate(addr) {
    const addrString = addr.toString();
    const s = this.toString();
    const i = s.lastIndexOf(addrString);
    if (i < 0) {
      throw new Error(`Address ${this.toString()} does not contain subaddress: ${addr.toString()}`);
    }
    return new _DefaultMultiaddr(s.slice(0, i));
  }
  decapsulateCode(code12) {
    const tuples = this.tuples();
    for (let i = tuples.length - 1; i >= 0; i--) {
      if (tuples[i][0] === code12) {
        return new _DefaultMultiaddr(tuplesToBytes(tuples.slice(0, i)));
      }
    }
    return this;
  }
  getPeerId() {
    try {
      const tuples = this.stringTuples().filter((tuple2) => {
        if (tuple2[0] === names.ipfs.code) {
          return true;
        }
        return false;
      });
      const tuple = tuples.pop();
      if (tuple?.[1] != null) {
        const peerIdStr = tuple[1];
        if (peerIdStr[0] === "Q" || peerIdStr[0] === "1") {
          return toString4(base58btc7.decode(`z${peerIdStr}`), "base58btc");
        }
        return toString4(CID7.parse(peerIdStr).multihash.bytes, "base58btc");
      }
      return null;
    } catch (e) {
      return null;
    }
  }
  getPath() {
    let path = null;
    try {
      path = this.stringTuples().filter((tuple) => {
        const proto = getProtocol(tuple[0]);
        if (proto.path === true) {
          return true;
        }
        return false;
      })[0][1];
      if (path == null) {
        path = null;
      }
    } catch {
      path = null;
    }
    return path;
  }
  equals(addr) {
    return equals15(this.bytes, addr.bytes);
  }
  async resolve(options) {
    const resolvableProto = this.protos().find((p) => p.resolvable);
    if (resolvableProto == null) {
      return [this];
    }
    const resolver = resolvers.get(resolvableProto.name);
    if (resolver == null) {
      throw (0, import_err_code.default)(new Error(`no available resolver for ${resolvableProto.name}`), "ERR_NO_AVAILABLE_RESOLVER");
    }
    const addresses = await resolver(this, options);
    return addresses.map((a) => new _DefaultMultiaddr(a));
  }
  nodeAddress() {
    const options = this.toOptions();
    if (options.transport !== "tcp" && options.transport !== "udp") {
      throw new Error(`multiaddr must have a valid format - no protocol with name: "${options.transport}". Must have a valid transport protocol: "{tcp, udp}"`);
    }
    return {
      family: options.family,
      address: options.host,
      port: options.port
    };
  }
  isThinWaistAddress(addr) {
    const protos = (addr ?? this).protos();
    if (protos.length !== 2) {
      return false;
    }
    if (protos[0].code !== 4 && protos[0].code !== 41) {
      return false;
    }
    if (protos[1].code !== 6 && protos[1].code !== 273) {
      return false;
    }
    return true;
  }
  /**
   * Returns Multiaddr as a human-readable string
   * https://nodejs.org/api/util.html#utilinspectcustom
   *
   * @example
   * ```js
   * import { multiaddr } from '@multiformats/multiaddr'
   *
   * console.info(multiaddr('/ip4/127.0.0.1/tcp/4001'))
   * // 'Multiaddr(/ip4/127.0.0.1/tcp/4001)'
   * ```
   */
  [(_DefaultMultiaddr_string = /* @__PURE__ */ new WeakMap(), _DefaultMultiaddr_tuples = /* @__PURE__ */ new WeakMap(), _DefaultMultiaddr_stringTuples = /* @__PURE__ */ new WeakMap(), _a = symbol, inspect)]() {
    return `Multiaddr(${bytesToString(this.bytes)})`;
  }
};
function multiaddr(addr) {
  return new DefaultMultiaddr(addr);
}

// node_modules/ipfs-http-client/src/lib/core.js
var import_env = __toESM(require_env(), 1);

// node_modules/parse-duration/index.mjs
var durationRE = /(-?(?:\d+\.?\d*|\d*\.?\d+)(?:e[-+]?\d+)?)\s*([\p{L}]*)/uig;
parse2.year = parse2.yr = parse2.y = 6e4 * 60 * 24 * 365.25;
parse2.month = parse2.b = 6e4 * 60 * 24 * (365.25 / 12);
parse2.week = parse2.wk = parse2.w = 6e4 * 60 * 24 * 7;
parse2.day = parse2.d = 6e4 * 60 * 24;
parse2.hour = parse2.hr = parse2.h = 6e4 * 60;
parse2.minute = parse2.min = parse2.m = 6e4;
parse2.second = parse2.sec = parse2.s = 1e3;
parse2.millisecond = parse2.millisec = parse2.ms = 1;
parse2["\xB5s"] = parse2["\u03BCs"] = parse2.us = parse2.microsecond = 1 / 1e3;
parse2.nanosecond = parse2.ns = 1 / 1e6;
function parse2(str = "", format12 = "ms") {
  var result = null, prevUnits;
  str = (str + "").replace(/(\d)[,_](\d)/g, "$1$2");
  str.replace(durationRE, function(_, n, units) {
    if (!units) {
      if (prevUnits) {
        for (var u in parse2) if (parse2[u] < prevUnits) {
          units = u;
          break;
        }
      } else units = format12;
    } else units = units.toLowerCase();
    if (Object.prototype.hasOwnProperty.call(parse2, units)) {
      units = parse2[units];
    } else if (Object.prototype.hasOwnProperty.call(parse2, units.replace(/s$/, ""))) {
      units = parse2[units.replace(/s$/, "")];
    } else {
      units = null;
    }
    if (units) result = (result || 0) + Math.abs(parseFloat(n, 10)) * units, prevUnits = units;
  });
  return result && result / (parse2[format12] || 1) * (str[0] === "-" ? -1 : 1);
}
var parse_duration_default = parse2;

// node_modules/@libp2p/logger/dist/src/index.js
var import_debug = __toESM(require_browser(), 1);

// node_modules/@libp2p/logger/node_modules/multiformats/vendor/base-x.js
function base9(ALPHABET, name12) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode42(source) {
    if (source instanceof Uint8Array) ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length11 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length11) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length11 = i2;
      pbegin++;
    }
    var it2 = size - length11;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length11 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length11) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length11 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length11;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode58(string3) {
    var buffer2 = decodeUnsafe(string3);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name12} character`);
  }
  return {
    encode: encode42,
    decodeUnsafe,
    decode: decode58
  };
}
var src8 = base9;
var _brrp__multiformats_scope_baseX8 = src8;
var base_x_default8 = _brrp__multiformats_scope_baseX8;

// node_modules/@libp2p/logger/node_modules/multiformats/src/bytes.js
var empty8 = new Uint8Array(0);
var coerce8 = (o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array") return o;
  if (o instanceof ArrayBuffer) return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};

// node_modules/@libp2p/logger/node_modules/multiformats/src/bases/base.js
var Encoder8 = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   */
  constructor(name12, prefix, baseEncode) {
    this.name = name12;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {API.Multibase<Prefix>}
   */
  encode(bytes) {
    if (bytes instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder8 = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name12, prefix, baseDecode) {
    this.name = name12;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = /** @type {number} */
    prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  /**
   * @param {string} text
   */
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or8(this, decoder);
  }
};
var ComposedDecoder8 = class {
  /**
   * @param {Decoders<Prefix>} decoders
   */
  constructor(decoders3) {
    this.decoders = decoders3;
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or8(this, decoder);
  }
  /**
   * @param {string} input
   * @returns {Uint8Array}
   */
  decode(input) {
    const prefix = (
      /** @type {Prefix} */
      input[0]
    );
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or8 = (left, right) => new ComposedDecoder8(
  /** @type {Decoders<L|R>} */
  {
    ...left.decoders || { [
      /** @type API.UnibaseDecoder<L> */
      left.prefix
    ]: left },
    ...right.decoders || { [
      /** @type API.UnibaseDecoder<R> */
      right.prefix
    ]: right }
  }
);
var Codec8 = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name12, prefix, baseEncode, baseDecode) {
    this.name = name12;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder8(name12, prefix, baseEncode);
    this.decoder = new Decoder8(name12, prefix, baseDecode);
  }
  /**
   * @param {Uint8Array} input
   */
  encode(input) {
    return this.encoder.encode(input);
  }
  /**
   * @param {string} input
   */
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from11 = ({ name: name12, prefix, encode: encode42, decode: decode58 }) => new Codec8(name12, prefix, encode42, decode58);
var baseX8 = ({ prefix, name: name12, alphabet: alphabet7 }) => {
  const { encode: encode42, decode: decode58 } = base_x_default8(alphabet7, name12);
  return from11({
    prefix,
    name: name12,
    encode: encode42,
    /**
     * @param {string} text
     */
    decode: (text) => coerce8(decode58(text))
  });
};
var decode42 = (string3, alphabet7, bitsPerChar, name12) => {
  const codes2 = {};
  for (let i = 0; i < alphabet7.length; ++i) {
    codes2[alphabet7[i]] = i;
  }
  let end = string3.length;
  while (string3[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes2[string3[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name12} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer2 >> bits;
    }
  }
  if (bits >= bitsPerChar || 255 & buffer2 << 8 - bits) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
var encode31 = (data, alphabet7, bitsPerChar) => {
  const pad = alphabet7[alphabet7.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer2 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer2 = buffer2 << 8 | data[i];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet7[mask & buffer2 >> bits];
    }
  }
  if (bits) {
    out += alphabet7[mask & buffer2 << bitsPerChar - bits];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
var rfc46488 = ({ name: name12, prefix, bitsPerChar, alphabet: alphabet7 }) => {
  return from11({
    prefix,
    name: name12,
    encode(input) {
      return encode31(input, alphabet7, bitsPerChar);
    },
    decode(input) {
      return decode42(input, alphabet7, bitsPerChar, name12);
    }
  });
};

// node_modules/@libp2p/logger/node_modules/multiformats/src/bases/base58.js
var base58btc8 = baseX8({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr8 = baseX8({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@libp2p/logger/node_modules/multiformats/src/bases/base32.js
var base328 = rfc46488({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper8 = rfc46488({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad8 = rfc46488({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper8 = rfc46488({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex8 = rfc46488({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper8 = rfc46488({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad8 = rfc46488({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper8 = rfc46488({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z8 = rfc46488({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@libp2p/logger/node_modules/multiformats/src/bases/base64.js
var base646 = rfc46488({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad6 = rfc46488({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url6 = rfc46488({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad6 = rfc46488({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/@libp2p/logger/dist/src/index.js
import_debug.default.formatters.b = (v) => {
  return v == null ? "undefined" : base58btc8.baseEncode(v);
};
import_debug.default.formatters.t = (v) => {
  return v == null ? "undefined" : base328.baseEncode(v);
};
import_debug.default.formatters.m = (v) => {
  return v == null ? "undefined" : base646.baseEncode(v);
};
import_debug.default.formatters.p = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug.default.formatters.c = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug.default.formatters.k = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug.default.formatters.a = (v) => {
  return v == null ? "undefined" : v.toString();
};
function createDisabledLogger(namespace) {
  const logger2 = () => {
  };
  logger2.enabled = false;
  logger2.color = "";
  logger2.diff = 0;
  logger2.log = () => {
  };
  logger2.namespace = namespace;
  logger2.destroy = () => true;
  logger2.extend = () => logger2;
  return logger2;
}
function logger(name12) {
  let trace = createDisabledLogger(`${name12}:trace`);
  if (import_debug.default.enabled(`${name12}:trace`) && import_debug.default.names.map((r) => r.toString()).find((n) => n.includes(":trace")) != null) {
    trace = (0, import_debug.default)(`${name12}:trace`);
  }
  return Object.assign((0, import_debug.default)(name12), {
    error: (0, import_debug.default)(`${name12}:error`),
    trace
  });
}

// node_modules/ipfs-http-client/src/lib/core.js
var import_http = __toESM(require_http(), 1);

// node_modules/merge-options/index.mjs
var import_index4 = __toESM(require_merge_options(), 1);
var merge_options_default = import_index4.default;

// node_modules/@multiformats/multiaddr-to-uri/node_modules/multiformats/dist/src/bases/base10.js
var base10_exports4 = {};
__export(base10_exports4, {
  base10: () => base104
});

// node_modules/@multiformats/multiaddr-to-uri/node_modules/multiformats/dist/src/bytes.js
var empty9 = new Uint8Array(0);
function equals16(aa, bb) {
  if (aa === bb) {
    return true;
  }
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}
function coerce9(o) {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array") {
    return o;
  }
  if (o instanceof ArrayBuffer) {
    return new Uint8Array(o);
  }
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}
function fromString7(str) {
  return new TextEncoder().encode(str);
}
function toString7(b) {
  return new TextDecoder().decode(b);
}

// node_modules/@multiformats/multiaddr-to-uri/node_modules/multiformats/dist/src/vendor/base-x.js
function base11(ALPHABET, name12) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode42(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length11 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length11) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length11 = i2;
      pbegin++;
    }
    var it2 = size - length11;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length11 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length11) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length11 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length11;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode58(string3) {
    var buffer2 = decodeUnsafe(string3);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name12} character`);
  }
  return {
    encode: encode42,
    decodeUnsafe,
    decode: decode58
  };
}
var src9 = base11;
var _brrp__multiformats_scope_baseX9 = src9;
var base_x_default9 = _brrp__multiformats_scope_baseX9;

// node_modules/@multiformats/multiaddr-to-uri/node_modules/multiformats/dist/src/bases/base.js
var Encoder9 = class {
  name;
  prefix;
  baseEncode;
  constructor(name12, prefix, baseEncode) {
    this.name = name12;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes) {
    if (bytes instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder9 = class {
  name;
  prefix;
  baseDecode;
  prefixCodePoint;
  constructor(name12, prefix, baseDecode) {
    this.name = name12;
    this.prefix = prefix;
    const prefixCodePoint = prefix.codePointAt(0);
    if (prefixCodePoint === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefixCodePoint;
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or9(this, decoder);
  }
};
var ComposedDecoder9 = class {
  decoders;
  constructor(decoders3) {
    this.decoders = decoders3;
  }
  or(decoder) {
    return or9(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder != null) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
function or9(left, right) {
  return new ComposedDecoder9({
    ...left.decoders ?? { [left.prefix]: left },
    ...right.decoders ?? { [right.prefix]: right }
  });
}
var Codec9 = class {
  name;
  prefix;
  baseEncode;
  baseDecode;
  encoder;
  decoder;
  constructor(name12, prefix, baseEncode, baseDecode) {
    this.name = name12;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder9(name12, prefix, baseEncode);
    this.decoder = new Decoder9(name12, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
function from12({ name: name12, prefix, encode: encode42, decode: decode58 }) {
  return new Codec9(name12, prefix, encode42, decode58);
}
function baseX9({ name: name12, prefix, alphabet: alphabet7 }) {
  const { encode: encode42, decode: decode58 } = base_x_default9(alphabet7, name12);
  return from12({
    prefix,
    name: name12,
    encode: encode42,
    decode: (text) => coerce9(decode58(text))
  });
}
function decode43(string3, alphabetIdx, bitsPerChar, name12) {
  let end = string3.length;
  while (string3[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = alphabetIdx[string3[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name12} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer2 >> bits;
    }
  }
  if (bits >= bitsPerChar || (255 & buffer2 << 8 - bits) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
function encode32(data, alphabet7, bitsPerChar) {
  const pad = alphabet7[alphabet7.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer2 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer2 = buffer2 << 8 | data[i];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet7[mask & buffer2 >> bits];
    }
  }
  if (bits !== 0) {
    out += alphabet7[mask & buffer2 << bitsPerChar - bits];
  }
  if (pad) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
function createAlphabetIdx4(alphabet7) {
  const alphabetIdx = {};
  for (let i = 0; i < alphabet7.length; ++i) {
    alphabetIdx[alphabet7[i]] = i;
  }
  return alphabetIdx;
}
function rfc46489({ name: name12, prefix, bitsPerChar, alphabet: alphabet7 }) {
  const alphabetIdx = createAlphabetIdx4(alphabet7);
  return from12({
    prefix,
    name: name12,
    encode(input) {
      return encode32(input, alphabet7, bitsPerChar);
    },
    decode(input) {
      return decode43(input, alphabetIdx, bitsPerChar, name12);
    }
  });
}

// node_modules/@multiformats/multiaddr-to-uri/node_modules/multiformats/dist/src/bases/base10.js
var base104 = baseX9({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/@multiformats/multiaddr-to-uri/node_modules/multiformats/dist/src/bases/base16.js
var base16_exports4 = {};
__export(base16_exports4, {
  base16: () => base164,
  base16upper: () => base16upper4
});
var base164 = rfc46489({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper4 = rfc46489({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/@multiformats/multiaddr-to-uri/node_modules/multiformats/dist/src/bases/base2.js
var base2_exports4 = {};
__export(base2_exports4, {
  base2: () => base25
});
var base25 = rfc46489({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/@multiformats/multiaddr-to-uri/node_modules/multiformats/dist/src/bases/base256emoji.js
var base256emoji_exports4 = {};
__export(base256emoji_exports4, {
  base256emoji: () => base256emoji4
});
var alphabet5 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars4 = alphabet5.reduce((p, c, i) => {
  p[i] = c;
  return p;
}, []);
var alphabetCharsToBytes4 = alphabet5.reduce((p, c, i) => {
  const codePoint = c.codePointAt(0);
  if (codePoint == null) {
    throw new Error(`Invalid character: ${c}`);
  }
  p[codePoint] = i;
  return p;
}, []);
function encode33(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars4[c];
    return p;
  }, "");
}
function decode44(str) {
  const byts = [];
  for (const char of str) {
    const codePoint = char.codePointAt(0);
    if (codePoint == null) {
      throw new Error(`Invalid character: ${char}`);
    }
    const byt = alphabetCharsToBytes4[codePoint];
    if (byt == null) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji4 = from12({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode33,
  decode: decode44
});

// node_modules/@multiformats/multiaddr-to-uri/node_modules/multiformats/dist/src/bases/base32.js
var base32_exports4 = {};
__export(base32_exports4, {
  base32: () => base329,
  base32hex: () => base32hex9,
  base32hexpad: () => base32hexpad9,
  base32hexpadupper: () => base32hexpadupper9,
  base32hexupper: () => base32hexupper9,
  base32pad: () => base32pad9,
  base32padupper: () => base32padupper9,
  base32upper: () => base32upper9,
  base32z: () => base32z9
});
var base329 = rfc46489({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper9 = rfc46489({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad9 = rfc46489({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper9 = rfc46489({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex9 = rfc46489({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper9 = rfc46489({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad9 = rfc46489({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper9 = rfc46489({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z9 = rfc46489({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@multiformats/multiaddr-to-uri/node_modules/multiformats/dist/src/bases/base36.js
var base36_exports4 = {};
__export(base36_exports4, {
  base36: () => base367,
  base36upper: () => base36upper7
});
var base367 = baseX9({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper7 = baseX9({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/@multiformats/multiaddr-to-uri/node_modules/multiformats/dist/src/bases/base58.js
var base58_exports4 = {};
__export(base58_exports4, {
  base58btc: () => base58btc9,
  base58flickr: () => base58flickr9
});
var base58btc9 = baseX9({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr9 = baseX9({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@multiformats/multiaddr-to-uri/node_modules/multiformats/dist/src/bases/base64.js
var base64_exports4 = {};
__export(base64_exports4, {
  base64: () => base647,
  base64pad: () => base64pad7,
  base64url: () => base64url7,
  base64urlpad: () => base64urlpad7
});
var base647 = rfc46489({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad7 = rfc46489({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url7 = rfc46489({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad7 = rfc46489({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/@multiformats/multiaddr-to-uri/node_modules/multiformats/dist/src/bases/base8.js
var base8_exports4 = {};
__export(base8_exports4, {
  base8: () => base84
});
var base84 = rfc46489({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/@multiformats/multiaddr-to-uri/node_modules/multiformats/dist/src/bases/identity.js
var identity_exports7 = {};
__export(identity_exports7, {
  identity: () => identity7
});
var identity7 = from12({
  prefix: "\0",
  name: "identity",
  encode: (buf2) => toString7(buf2),
  decode: (str) => fromString7(str)
});

// node_modules/@multiformats/multiaddr-to-uri/node_modules/multiformats/dist/src/codecs/json.js
var textEncoder7 = new TextEncoder();
var textDecoder6 = new TextDecoder();

// node_modules/@multiformats/multiaddr-to-uri/node_modules/multiformats/dist/src/hashes/identity.js
var identity_exports8 = {};
__export(identity_exports8, {
  identity: () => identity8
});

// node_modules/@multiformats/multiaddr-to-uri/node_modules/multiformats/dist/src/vendor/varint.js
var encode_18 = encode34;
var MSB8 = 128;
var REST8 = 127;
var MSBALL8 = ~REST8;
var INT8 = Math.pow(2, 31);
function encode34(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT8) {
    out[offset++] = num & 255 | MSB8;
    num /= 128;
  }
  while (num & MSBALL8) {
    out[offset++] = num & 255 | MSB8;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode34.bytes = offset - oldOffset + 1;
  return out;
}
var decode45 = read8;
var MSB$18 = 128;
var REST$18 = 127;
function read8(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
  do {
    if (counter >= l) {
      read8.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf2[counter++];
    res += shift < 28 ? (b & REST$18) << shift : (b & REST$18) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$18);
  read8.bytes = counter - offset;
  return res;
}
var N18 = Math.pow(2, 7);
var N28 = Math.pow(2, 14);
var N38 = Math.pow(2, 21);
var N48 = Math.pow(2, 28);
var N58 = Math.pow(2, 35);
var N68 = Math.pow(2, 42);
var N78 = Math.pow(2, 49);
var N88 = Math.pow(2, 56);
var N98 = Math.pow(2, 63);
var length8 = function(value) {
  return value < N18 ? 1 : value < N28 ? 2 : value < N38 ? 3 : value < N48 ? 4 : value < N58 ? 5 : value < N68 ? 6 : value < N78 ? 7 : value < N88 ? 8 : value < N98 ? 9 : 10;
};
var varint11 = {
  encode: encode_18,
  decode: decode45,
  encodingLength: length8
};
var _brrp_varint8 = varint11;
var varint_default8 = _brrp_varint8;

// node_modules/@multiformats/multiaddr-to-uri/node_modules/multiformats/dist/src/varint.js
function decode46(data, offset = 0) {
  const code12 = varint_default8.decode(data, offset);
  return [code12, varint_default8.decode.bytes];
}
function encodeTo8(int, target, offset = 0) {
  varint_default8.encode(int, target, offset);
  return target;
}
function encodingLength8(int) {
  return varint_default8.encodingLength(int);
}

// node_modules/@multiformats/multiaddr-to-uri/node_modules/multiformats/dist/src/hashes/digest.js
function create8(code12, digest6) {
  const size = digest6.byteLength;
  const sizeOffset = encodingLength8(code12);
  const digestOffset = sizeOffset + encodingLength8(size);
  const bytes = new Uint8Array(digestOffset + size);
  encodeTo8(code12, bytes, 0);
  encodeTo8(size, bytes, sizeOffset);
  bytes.set(digest6, digestOffset);
  return new Digest8(code12, size, digest6, bytes);
}
function decode47(multihash) {
  const bytes = coerce9(multihash);
  const [code12, sizeOffset] = decode46(bytes);
  const [size, digestOffset] = decode46(bytes.subarray(sizeOffset));
  const digest6 = bytes.subarray(sizeOffset + digestOffset);
  if (digest6.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest8(code12, size, digest6, bytes);
}
function equals17(a, b) {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals16(a.bytes, data.bytes);
  }
}
var Digest8 = class {
  code;
  size;
  digest;
  bytes;
  /**
   * Creates a multihash digest.
   */
  constructor(code12, size, digest6, bytes) {
    this.code = code12;
    this.size = size;
    this.digest = digest6;
    this.bytes = bytes;
  }
};

// node_modules/@multiformats/multiaddr-to-uri/node_modules/multiformats/dist/src/hashes/identity.js
var code10 = 0;
var name10 = "identity";
var encode35 = coerce9;
function digest4(input, options) {
  if (options?.truncate != null && options.truncate !== input.byteLength) {
    if (options.truncate < 0 || options.truncate > input.byteLength) {
      throw new Error(`Invalid truncate option, must be less than or equal to ${input.byteLength}`);
    }
    input = input.subarray(0, options.truncate);
  }
  return create8(code10, encode35(input));
}
var identity8 = { code: code10, name: name10, encode: encode35, digest: digest4 };

// node_modules/@multiformats/multiaddr-to-uri/node_modules/multiformats/dist/src/hashes/sha2-browser.js
var sha2_browser_exports4 = {};
__export(sha2_browser_exports4, {
  sha256: () => sha2566,
  sha512: () => sha5125
});

// node_modules/@multiformats/multiaddr-to-uri/node_modules/multiformats/dist/src/hashes/hasher.js
var DEFAULT_MIN_DIGEST_LENGTH = 20;
function from13({ name: name12, code: code12, encode: encode42, minDigestLength, maxDigestLength }) {
  return new Hasher4(name12, code12, encode42, minDigestLength, maxDigestLength);
}
var Hasher4 = class {
  name;
  code;
  encode;
  minDigestLength;
  maxDigestLength;
  constructor(name12, code12, encode42, minDigestLength, maxDigestLength) {
    this.name = name12;
    this.code = code12;
    this.encode = encode42;
    this.minDigestLength = minDigestLength ?? DEFAULT_MIN_DIGEST_LENGTH;
    this.maxDigestLength = maxDigestLength;
  }
  digest(input, options) {
    if (options?.truncate != null) {
      if (options.truncate < this.minDigestLength) {
        throw new Error(`Invalid truncate option, must be greater than or equal to ${this.minDigestLength}`);
      }
      if (this.maxDigestLength != null && options.truncate > this.maxDigestLength) {
        throw new Error(`Invalid truncate option, must be less than or equal to ${this.maxDigestLength}`);
      }
    }
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      if (result instanceof Uint8Array) {
        return createDigest(result, this.code, options?.truncate);
      }
      return result.then((digest6) => createDigest(digest6, this.code, options?.truncate));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
function createDigest(digest6, code12, truncate) {
  if (truncate != null && truncate !== digest6.byteLength) {
    if (truncate > digest6.byteLength) {
      throw new Error(`Invalid truncate option, must be less than or equal to ${digest6.byteLength}`);
    }
    digest6 = digest6.subarray(0, truncate);
  }
  return create8(code12, digest6);
}

// node_modules/@multiformats/multiaddr-to-uri/node_modules/multiformats/dist/src/hashes/sha2-browser.js
function sha4(name12) {
  return async (data) => new Uint8Array(await crypto.subtle.digest(name12, data));
}
var sha2566 = from13({
  name: "sha2-256",
  code: 18,
  encode: sha4("SHA-256")
});
var sha5125 = from13({
  name: "sha2-512",
  code: 19,
  encode: sha4("SHA-512")
});

// node_modules/@multiformats/multiaddr-to-uri/node_modules/multiformats/dist/src/cid.js
function format9(link, base14) {
  const { bytes, version } = link;
  switch (version) {
    case 0:
      return toStringV08(bytes, baseCache8(link), base14 ?? base58btc9.encoder);
    default:
      return toStringV18(bytes, baseCache8(link), base14 ?? base329.encoder);
  }
}
var cache8 = /* @__PURE__ */ new WeakMap();
function baseCache8(cid) {
  const baseCache11 = cache8.get(cid);
  if (baseCache11 == null) {
    const baseCache12 = /* @__PURE__ */ new Map();
    cache8.set(cid, baseCache12);
    return baseCache12;
  }
  return baseCache11;
}
var CID8 = class _CID {
  code;
  version;
  multihash;
  bytes;
  "/";
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param multihash - (Multi)hash of the of the content.
   */
  constructor(version, code12, multihash, bytes) {
    this.code = code12;
    this.version = version;
    this.multihash = multihash;
    this.bytes = bytes;
    this["/"] = bytes;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code12, multihash } = this;
        if (code12 !== DAG_PB_CODE8) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE8) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return _CID.createV0(multihash);
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code12, digest: digest6 } = this.multihash;
        const multihash = create8(code12, digest6);
        return _CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return _CID.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals17(self2.multihash, unknown.multihash);
  }
  toString(base14) {
    return format9(this, base14);
  }
  toJSON() {
    return { "/": format9(this) };
  }
  link() {
    return this;
  }
  [Symbol.toStringTag] = "CID";
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value = input;
    if (value instanceof _CID) {
      return value;
    } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
      const { version, code: code12, multihash, bytes } = value;
      return new _CID(version, code12, multihash, bytes ?? encodeCID8(version, code12, multihash.bytes));
    } else if (value[cidSymbol8] === true) {
      const { version, multihash, code: code12 } = value;
      const digest6 = decode47(multihash);
      return _CID.create(version, code12, digest6);
    } else {
      return null;
    }
  }
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param digest - (Multi)hash of the of the content.
   */
  static create(version, code12, digest6) {
    if (typeof code12 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest6.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version) {
      case 0: {
        if (code12 !== DAG_PB_CODE8) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE8}) block encoding`);
        } else {
          return new _CID(version, code12, digest6, digest6.bytes);
        }
      }
      case 1: {
        const bytes = encodeCID8(version, code12, digest6.bytes);
        return new _CID(version, code12, digest6, bytes);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   */
  static createV0(digest6) {
    return _CID.create(0, DAG_PB_CODE8, digest6);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @param code - Content encoding format code.
   * @param digest - Multihash of the content.
   */
  static createV1(code12, digest6) {
    return _CID.create(1, code12, digest6);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   */
  static decode(bytes) {
    const [cid, remainder] = _CID.decodeFirst(bytes);
    if (remainder.length !== 0) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   */
  static decodeFirst(bytes) {
    const specs = _CID.inspectBytes(bytes);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce9(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest6 = new Digest8(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? _CID.createV0(digest6) : _CID.createV1(specs.codec, digest6);
    return [cid, bytes.subarray(specs.size)];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i, length11] = decode46(initialBytes.subarray(offset));
      offset += length11;
      return i;
    };
    let version = next();
    let codec = DAG_PB_CODE8;
    if (version === 18) {
      version = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version !== 0 && version !== 1) {
      throw new RangeError(`Invalid CID version ${version}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   */
  static parse(source, base14) {
    const [prefix, bytes] = parseCIDtoBytes8(source, base14);
    const cid = _CID.decode(bytes);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache8(cid).set(prefix, source);
    return cid;
  }
};
function parseCIDtoBytes8(source, base14) {
  switch (source[0]) {
    // CIDv0 is parsed differently
    case "Q": {
      const decoder = base14 ?? base58btc9;
      return [
        base58btc9.prefix,
        decoder.decode(`${base58btc9.prefix}${source}`)
      ];
    }
    case base58btc9.prefix: {
      const decoder = base14 ?? base58btc9;
      return [base58btc9.prefix, decoder.decode(source)];
    }
    case base329.prefix: {
      const decoder = base14 ?? base329;
      return [base329.prefix, decoder.decode(source)];
    }
    case base367.prefix: {
      const decoder = base14 ?? base367;
      return [base367.prefix, decoder.decode(source)];
    }
    default: {
      if (base14 == null) {
        throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");
      }
      return [source[0], base14.decode(source)];
    }
  }
}
function toStringV08(bytes, cache11, base14) {
  const { prefix } = base14;
  if (prefix !== base58btc9.prefix) {
    throw Error(`Cannot string encode V0 in ${base14.name} encoding`);
  }
  const cid = cache11.get(prefix);
  if (cid == null) {
    const cid2 = base14.encode(bytes).slice(1);
    cache11.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
function toStringV18(bytes, cache11, base14) {
  const { prefix } = base14;
  const cid = cache11.get(prefix);
  if (cid == null) {
    const cid2 = base14.encode(bytes);
    cache11.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
var DAG_PB_CODE8 = 112;
var SHA_256_CODE8 = 18;
function encodeCID8(version, code12, multihash) {
  const codeOffset = encodingLength8(version);
  const hashOffset = codeOffset + encodingLength8(code12);
  const bytes = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo8(version, bytes, 0);
  encodeTo8(code12, bytes, codeOffset);
  bytes.set(multihash, hashOffset);
  return bytes;
}
var cidSymbol8 = Symbol.for("@ipld/js-cid/CID");

// node_modules/@multiformats/multiaddr-to-uri/node_modules/multiformats/dist/src/basics.js
var bases4 = { ...identity_exports7, ...base2_exports4, ...base8_exports4, ...base10_exports4, ...base16_exports4, ...base32_exports4, ...base36_exports4, ...base58_exports4, ...base64_exports4, ...base256emoji_exports4 };
var hashes4 = { ...sha2_browser_exports4, ...identity_exports8 };

// node_modules/@multiformats/multiaddr-to-uri/node_modules/uint8arrays/dist/src/alloc.js
function allocUnsafe2(size = 0) {
  return new Uint8Array(size);
}

// node_modules/@multiformats/multiaddr-to-uri/node_modules/uint8arrays/dist/src/util/bases.js
function createCodec2(name12, prefix, encode42, decode58) {
  return {
    name: name12,
    prefix,
    encoder: {
      name: name12,
      prefix,
      encode: encode42
    },
    decoder: {
      decode: decode58
    }
  };
}
var string2 = createCodec2("utf8", "u", (buf2) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf2);
}, (str) => {
  const encoder = new TextEncoder();
  return encoder.encode(str.substring(1));
});
var ascii2 = createCodec2("ascii", "a", (buf2) => {
  let string3 = "a";
  for (let i = 0; i < buf2.length; i++) {
    string3 += String.fromCharCode(buf2[i]);
  }
  return string3;
}, (str) => {
  str = str.substring(1);
  const buf2 = allocUnsafe2(str.length);
  for (let i = 0; i < str.length; i++) {
    buf2[i] = str.charCodeAt(i);
  }
  return buf2;
});
var BASES2 = {
  utf8: string2,
  "utf-8": string2,
  hex: bases4.base16,
  latin1: ascii2,
  ascii: ascii2,
  binary: ascii2,
  ...bases4
};
var bases_default2 = BASES2;

// node_modules/@multiformats/multiaddr-to-uri/node_modules/uint8arrays/dist/src/to-string.js
function toString8(array, encoding = "utf8") {
  const base14 = bases_default2[encoding];
  if (base14 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base14.encoder.encode(array).substring(1);
}

// node_modules/@multiformats/multiaddr-to-uri/node_modules/@multiformats/multiaddr/dist/src/errors.js
var InvalidMultiaddrError = class extends Error {
  static name = "InvalidMultiaddrError";
  name = "InvalidMultiaddrError";
};
var ValidationError = class extends Error {
  static name = "ValidationError";
  name = "ValidationError";
};
var InvalidParametersError = class extends Error {
  static name = "InvalidParametersError";
  name = "InvalidParametersError";
};
var UnknownProtocolError = class extends Error {
  static name = "UnknownProtocolError";
  name = "UnknownProtocolError";
};

// node_modules/@multiformats/multiaddr-to-uri/node_modules/uint8arrays/dist/src/equals.js
function equals18(a, b) {
  if (a === b) {
    return true;
  }
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  for (let i = 0; i < a.byteLength; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}

// node_modules/@multiformats/multiaddr-to-uri/node_modules/uint8arrays/dist/src/from-string.js
function fromString8(string3, encoding = "utf8") {
  const base14 = bases_default2[encoding];
  if (base14 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base14.decoder.decode(`${base14.prefix}${string3}`);
}

// node_modules/uint8-varint/dist/src/index.js
var N19 = Math.pow(2, 7);
var N29 = Math.pow(2, 14);
var N39 = Math.pow(2, 21);
var N49 = Math.pow(2, 28);
var N59 = Math.pow(2, 35);
var N69 = Math.pow(2, 42);
var N79 = Math.pow(2, 49);
var MSB9 = 128;
var REST9 = 127;
function encodingLength9(value) {
  if (value < N19) {
    return 1;
  }
  if (value < N29) {
    return 2;
  }
  if (value < N39) {
    return 3;
  }
  if (value < N49) {
    return 4;
  }
  if (value < N59) {
    return 5;
  }
  if (value < N69) {
    return 6;
  }
  if (value < N79) {
    return 7;
  }
  if (Number.MAX_SAFE_INTEGER != null && value > Number.MAX_SAFE_INTEGER) {
    throw new RangeError("Could not encode varint");
  }
  return 8;
}
function encodeUint8Array(value, buf2, offset = 0) {
  switch (encodingLength9(value)) {
    case 8: {
      buf2[offset++] = value & 255 | MSB9;
      value /= 128;
    }
    case 7: {
      buf2[offset++] = value & 255 | MSB9;
      value /= 128;
    }
    case 6: {
      buf2[offset++] = value & 255 | MSB9;
      value /= 128;
    }
    case 5: {
      buf2[offset++] = value & 255 | MSB9;
      value /= 128;
    }
    case 4: {
      buf2[offset++] = value & 255 | MSB9;
      value >>>= 7;
    }
    case 3: {
      buf2[offset++] = value & 255 | MSB9;
      value >>>= 7;
    }
    case 2: {
      buf2[offset++] = value & 255 | MSB9;
      value >>>= 7;
    }
    case 1: {
      buf2[offset++] = value & 255;
      value >>>= 7;
      break;
    }
    default:
      throw new Error("unreachable");
  }
  return buf2;
}
function decodeUint8Array(buf2, offset) {
  let b = buf2[offset];
  let res = 0;
  res += b & REST9;
  if (b < MSB9) {
    return res;
  }
  b = buf2[offset + 1];
  res += (b & REST9) << 7;
  if (b < MSB9) {
    return res;
  }
  b = buf2[offset + 2];
  res += (b & REST9) << 14;
  if (b < MSB9) {
    return res;
  }
  b = buf2[offset + 3];
  res += (b & REST9) << 21;
  if (b < MSB9) {
    return res;
  }
  b = buf2[offset + 4];
  res += (b & REST9) * N49;
  if (b < MSB9) {
    return res;
  }
  b = buf2[offset + 5];
  res += (b & REST9) * N59;
  if (b < MSB9) {
    return res;
  }
  b = buf2[offset + 6];
  res += (b & REST9) * N69;
  if (b < MSB9) {
    return res;
  }
  b = buf2[offset + 7];
  res += (b & REST9) * N79;
  if (b < MSB9) {
    return res;
  }
  throw new RangeError("Could not decode varint");
}
function decodeUint8ArrayList(buf2, offset) {
  let b = buf2.get(offset);
  let res = 0;
  res += b & REST9;
  if (b < MSB9) {
    return res;
  }
  b = buf2.get(offset + 1);
  res += (b & REST9) << 7;
  if (b < MSB9) {
    return res;
  }
  b = buf2.get(offset + 2);
  res += (b & REST9) << 14;
  if (b < MSB9) {
    return res;
  }
  b = buf2.get(offset + 3);
  res += (b & REST9) << 21;
  if (b < MSB9) {
    return res;
  }
  b = buf2.get(offset + 4);
  res += (b & REST9) * N49;
  if (b < MSB9) {
    return res;
  }
  b = buf2.get(offset + 5);
  res += (b & REST9) * N59;
  if (b < MSB9) {
    return res;
  }
  b = buf2.get(offset + 6);
  res += (b & REST9) * N69;
  if (b < MSB9) {
    return res;
  }
  b = buf2.get(offset + 7);
  res += (b & REST9) * N79;
  if (b < MSB9) {
    return res;
  }
  throw new RangeError("Could not decode varint");
}
function decode48(buf2, offset = 0) {
  if (buf2 instanceof Uint8Array) {
    return decodeUint8Array(buf2, offset);
  } else {
    return decodeUint8ArrayList(buf2, offset);
  }
}

// node_modules/@multiformats/multiaddr-to-uri/node_modules/uint8arrays/dist/src/util/as-uint8array.js
function asUint8Array2(buf2) {
  return buf2;
}

// node_modules/@multiformats/multiaddr-to-uri/node_modules/uint8arrays/dist/src/concat.js
function concat3(arrays, length11) {
  if (length11 == null) {
    length11 = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output = allocUnsafe2(length11);
  let offset = 0;
  for (const arr of arrays) {
    output.set(arr, offset);
    offset += arr.length;
  }
  return asUint8Array2(output);
}

// node_modules/@multiformats/multiaddr-to-uri/node_modules/@multiformats/multiaddr/dist/src/constants.js
var CODE_IP4 = 4;
var CODE_TCP = 6;
var CODE_UDP = 273;
var CODE_DCCP = 33;
var CODE_IP6 = 41;
var CODE_IP6ZONE = 42;
var CODE_IPCIDR = 43;
var CODE_DNS = 53;
var CODE_DNS4 = 54;
var CODE_DNS6 = 55;
var CODE_DNSADDR = 56;
var CODE_SCTP = 132;
var CODE_UDT = 301;
var CODE_UTP = 302;
var CODE_UNIX = 400;
var CODE_P2P = 421;
var CODE_ONION = 444;
var CODE_ONION3 = 445;
var CODE_GARLIC64 = 446;
var CODE_GARLIC32 = 447;
var CODE_TLS = 448;
var CODE_SNI = 449;
var CODE_NOISE = 454;
var CODE_QUIC = 460;
var CODE_QUIC_V1 = 461;
var CODE_WEBTRANSPORT = 465;
var CODE_CERTHASH = 466;
var CODE_HTTP = 480;
var CODE_HTTP_PATH = 481;
var CODE_HTTPS = 443;
var CODE_WS = 477;
var CODE_WSS = 478;
var CODE_P2P_WEBSOCKET_STAR = 479;
var CODE_P2P_STARDUST = 277;
var CODE_P2P_WEBRTC_STAR = 275;
var CODE_P2P_WEBRTC_DIRECT = 276;
var CODE_WEBRTC_DIRECT = 280;
var CODE_WEBRTC = 281;
var CODE_P2P_CIRCUIT = 290;
var CODE_MEMORY = 777;

// node_modules/@multiformats/multiaddr-to-uri/node_modules/@multiformats/multiaddr/dist/src/utils.js
function bytesToString2(base14) {
  return (buf2) => {
    return toString8(buf2, base14);
  };
}
function stringToBytes2(base14) {
  return (buf2) => {
    return fromString8(buf2, base14);
  };
}
function bytes2port2(buf2) {
  const view = new DataView(buf2.buffer);
  return view.getUint16(buf2.byteOffset).toString();
}
function port2bytes2(port) {
  const buf2 = new ArrayBuffer(2);
  const view = new DataView(buf2);
  view.setUint16(0, typeof port === "string" ? parseInt(port) : port);
  return new Uint8Array(buf2);
}
function onion2bytes2(str) {
  const addr = str.split(":");
  if (addr.length !== 2) {
    throw new Error(`failed to parse onion addr: ["'${addr.join('", "')}'"]' does not contain a port number`);
  }
  if (addr[0].length !== 16) {
    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion address.`);
  }
  const buf2 = fromString8(addr[0], "base32");
  const port = parseInt(addr[1], 10);
  if (port < 1 || port > 65536) {
    throw new Error("Port number is not in range(1, 65536)");
  }
  const portBuf = port2bytes2(port);
  return concat3([buf2, portBuf], buf2.length + portBuf.length);
}
function onion32bytes2(str) {
  const addr = str.split(":");
  if (addr.length !== 2) {
    throw new Error(`failed to parse onion addr: ["'${addr.join('", "')}'"]' does not contain a port number`);
  }
  if (addr[0].length !== 56) {
    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion3 address.`);
  }
  const buf2 = base329.decode(`b${addr[0]}`);
  const port = parseInt(addr[1], 10);
  if (port < 1 || port > 65536) {
    throw new Error("Port number is not in range(1, 65536)");
  }
  const portBuf = port2bytes2(port);
  return concat3([buf2, portBuf], buf2.length + portBuf.length);
}
function bytes2onion2(buf2) {
  const addrBytes = buf2.subarray(0, buf2.length - 2);
  const portBytes = buf2.subarray(buf2.length - 2);
  const addr = toString8(addrBytes, "base32");
  const port = bytes2port2(portBytes);
  return `${addr}:${port}`;
}
var ip4ToBytes = function(ip) {
  ip = ip.toString().trim();
  const bytes = new Uint8Array(4);
  ip.split(/\./g).forEach((byte, index) => {
    const value = parseInt(byte, 10);
    if (isNaN(value) || value < 0 || value > 255) {
      throw new InvalidMultiaddrError("Invalid byte value in IP address");
    }
    bytes[index] = value;
  });
  return bytes;
};
var ip6ToBytes = function(ip) {
  let offset = 0;
  ip = ip.toString().trim();
  const sections = ip.split(":", 8);
  let i;
  for (i = 0; i < sections.length; i++) {
    const isv4 = isIPv4(sections[i]);
    let v4Buffer;
    if (isv4) {
      v4Buffer = ip4ToBytes(sections[i]);
      sections[i] = toString8(v4Buffer.subarray(0, 2), "base16");
    }
    if (v4Buffer != null && ++i < 8) {
      sections.splice(i, 0, toString8(v4Buffer.subarray(2, 4), "base16"));
    }
  }
  if (sections[0] === "") {
    while (sections.length < 8) {
      sections.unshift("0");
    }
  } else if (sections[sections.length - 1] === "") {
    while (sections.length < 8) {
      sections.push("0");
    }
  } else if (sections.length < 8) {
    for (i = 0; i < sections.length && sections[i] !== ""; i++) {
    }
    const argv = [i, 1];
    for (i = 9 - sections.length; i > 0; i--) {
      argv.push("0");
    }
    sections.splice.apply(sections, argv);
  }
  const bytes = new Uint8Array(offset + 16);
  for (i = 0; i < sections.length; i++) {
    if (sections[i] === "") {
      sections[i] = "0";
    }
    const word = parseInt(sections[i], 16);
    if (isNaN(word) || word < 0 || word > 65535) {
      throw new InvalidMultiaddrError("Invalid byte value in IP address");
    }
    bytes[offset++] = word >> 8 & 255;
    bytes[offset++] = word & 255;
  }
  return bytes;
};
var ip4ToString = function(buf2) {
  if (buf2.byteLength !== 4) {
    throw new InvalidMultiaddrError("IPv4 address was incorrect length");
  }
  const result = [];
  for (let i = 0; i < buf2.byteLength; i++) {
    result.push(buf2[i]);
  }
  return result.join(".");
};
var ip6ToString = function(buf2) {
  if (buf2.byteLength !== 16) {
    throw new InvalidMultiaddrError("IPv6 address was incorrect length");
  }
  const result = [];
  for (let i = 0; i < buf2.byteLength; i += 2) {
    const byte1 = buf2[i];
    const byte2 = buf2[i + 1];
    const tuple = `${byte1.toString(16).padStart(2, "0")}${byte2.toString(16).padStart(2, "0")}`;
    result.push(tuple);
  }
  const ip = result.join(":");
  try {
    const url = new URL(`http://[${ip}]`);
    return url.hostname.substring(1, url.hostname.length - 1);
  } catch {
    throw new InvalidMultiaddrError(`Invalid IPv6 address "${ip}"`);
  }
};
function ip6StringToValue(str) {
  try {
    const url = new URL(`http://[${str}]`);
    return url.hostname.substring(1, url.hostname.length - 1);
  } catch {
    throw new InvalidMultiaddrError(`Invalid IPv6 address "${str}"`);
  }
}
var decoders2 = Object.values(bases4).map((c) => c.decoder);
var anybaseDecoder2 = (function() {
  let acc = decoders2[0].or(decoders2[1]);
  decoders2.slice(2).forEach((d) => acc = acc.or(d));
  return acc;
})();
function mb2bytes2(mbstr) {
  return anybaseDecoder2.decode(mbstr);
}
function bytes2mb2(base14) {
  return (buf2) => {
    return base14.encoder.encode(buf2);
  };
}

// node_modules/@multiformats/multiaddr-to-uri/node_modules/@multiformats/multiaddr/dist/src/validation.js
function integer(value) {
  const int = parseInt(value);
  if (int.toString() !== value) {
    throw new ValidationError("Value must be an integer");
  }
}
function positive(value) {
  if (value < 0) {
    throw new ValidationError("Value must be a positive integer, or zero");
  }
}
function maxValue(max) {
  return (value) => {
    if (value > max) {
      throw new ValidationError(`Value must be smaller than or equal to ${max}`);
    }
  };
}
function validate2(...funcs) {
  return (value) => {
    for (const fn of funcs) {
      fn(value);
    }
  };
}
var validatePort = validate2(integer, positive, maxValue(65535));

// node_modules/@multiformats/multiaddr-to-uri/node_modules/@multiformats/multiaddr/dist/src/registry.js
var V2 = -1;
var Registry = class {
  protocolsByCode = /* @__PURE__ */ new Map();
  protocolsByName = /* @__PURE__ */ new Map();
  getProtocol(key) {
    let codec;
    if (typeof key === "string") {
      codec = this.protocolsByName.get(key);
    } else {
      codec = this.protocolsByCode.get(key);
    }
    if (codec == null) {
      throw new UnknownProtocolError(`Protocol ${key} was unknown`);
    }
    return codec;
  }
  addProtocol(codec) {
    this.protocolsByCode.set(codec.code, codec);
    this.protocolsByName.set(codec.name, codec);
    codec.aliases?.forEach((alias) => {
      this.protocolsByName.set(alias, codec);
    });
  }
  removeProtocol(code12) {
    const codec = this.protocolsByCode.get(code12);
    if (codec == null) {
      return;
    }
    this.protocolsByCode.delete(codec.code);
    this.protocolsByName.delete(codec.name);
    codec.aliases?.forEach((alias) => {
      this.protocolsByName.delete(alias);
    });
  }
};
var registry = new Registry();
var codecs2 = [{
  code: CODE_IP4,
  name: "ip4",
  size: 32,
  valueToBytes: ip4ToBytes,
  bytesToValue: ip4ToString,
  validate: (value) => {
    if (!isIPv4(value)) {
      throw new ValidationError(`Invalid IPv4 address "${value}"`);
    }
  }
}, {
  code: CODE_TCP,
  name: "tcp",
  size: 16,
  valueToBytes: port2bytes2,
  bytesToValue: bytes2port2,
  validate: validatePort
}, {
  code: CODE_UDP,
  name: "udp",
  size: 16,
  valueToBytes: port2bytes2,
  bytesToValue: bytes2port2,
  validate: validatePort
}, {
  code: CODE_DCCP,
  name: "dccp",
  size: 16,
  valueToBytes: port2bytes2,
  bytesToValue: bytes2port2,
  validate: validatePort
}, {
  code: CODE_IP6,
  name: "ip6",
  size: 128,
  valueToBytes: ip6ToBytes,
  bytesToValue: ip6ToString,
  stringToValue: ip6StringToValue,
  validate: (value) => {
    if (!isIPv6(value)) {
      throw new ValidationError(`Invalid IPv6 address "${value}"`);
    }
  }
}, {
  code: CODE_IP6ZONE,
  name: "ip6zone",
  size: V2
}, {
  code: CODE_IPCIDR,
  name: "ipcidr",
  size: 8,
  bytesToValue: bytesToString2("base10"),
  valueToBytes: stringToBytes2("base10")
}, {
  code: CODE_DNS,
  name: "dns",
  size: V2,
  resolvable: true
}, {
  code: CODE_DNS4,
  name: "dns4",
  size: V2,
  resolvable: true
}, {
  code: CODE_DNS6,
  name: "dns6",
  size: V2,
  resolvable: true
}, {
  code: CODE_DNSADDR,
  name: "dnsaddr",
  size: V2,
  resolvable: true
}, {
  code: CODE_SCTP,
  name: "sctp",
  size: 16,
  valueToBytes: port2bytes2,
  bytesToValue: bytes2port2,
  validate: validatePort
}, {
  code: CODE_UDT,
  name: "udt"
}, {
  code: CODE_UTP,
  name: "utp"
}, {
  code: CODE_UNIX,
  name: "unix",
  size: V2,
  path: true,
  stringToValue: (str) => decodeURIComponent(str),
  valueToString: (val) => encodeURIComponent(val)
}, {
  code: CODE_P2P,
  name: "p2p",
  aliases: ["ipfs"],
  size: V2,
  bytesToValue: bytesToString2("base58btc"),
  valueToBytes: (val) => {
    if (val.startsWith("Q") || val.startsWith("1")) {
      return stringToBytes2("base58btc")(val);
    }
    return CID8.parse(val).multihash.bytes;
  }
}, {
  code: CODE_ONION,
  name: "onion",
  size: 96,
  bytesToValue: bytes2onion2,
  valueToBytes: onion2bytes2
}, {
  code: CODE_ONION3,
  name: "onion3",
  size: 296,
  bytesToValue: bytes2onion2,
  valueToBytes: onion32bytes2
}, {
  code: CODE_GARLIC64,
  name: "garlic64",
  size: V2
}, {
  code: CODE_GARLIC32,
  name: "garlic32",
  size: V2
}, {
  code: CODE_TLS,
  name: "tls"
}, {
  code: CODE_SNI,
  name: "sni",
  size: V2
}, {
  code: CODE_NOISE,
  name: "noise"
}, {
  code: CODE_QUIC,
  name: "quic"
}, {
  code: CODE_QUIC_V1,
  name: "quic-v1"
}, {
  code: CODE_WEBTRANSPORT,
  name: "webtransport"
}, {
  code: CODE_CERTHASH,
  name: "certhash",
  size: V2,
  bytesToValue: bytes2mb2(base64url7),
  valueToBytes: mb2bytes2
}, {
  code: CODE_HTTP,
  name: "http"
}, {
  code: CODE_HTTP_PATH,
  name: "http-path",
  size: V2,
  stringToValue: (str) => `/${decodeURIComponent(str)}`,
  valueToString: (val) => encodeURIComponent(val.substring(1))
}, {
  code: CODE_HTTPS,
  name: "https"
}, {
  code: CODE_WS,
  name: "ws"
}, {
  code: CODE_WSS,
  name: "wss"
}, {
  code: CODE_P2P_WEBSOCKET_STAR,
  name: "p2p-websocket-star"
}, {
  code: CODE_P2P_STARDUST,
  name: "p2p-stardust"
}, {
  code: CODE_P2P_WEBRTC_STAR,
  name: "p2p-webrtc-star"
}, {
  code: CODE_P2P_WEBRTC_DIRECT,
  name: "p2p-webrtc-direct"
}, {
  code: CODE_WEBRTC_DIRECT,
  name: "webrtc-direct"
}, {
  code: CODE_WEBRTC,
  name: "webrtc"
}, {
  code: CODE_P2P_CIRCUIT,
  name: "p2p-circuit"
}, {
  code: CODE_MEMORY,
  name: "memory",
  size: V2
}];
codecs2.forEach((codec) => {
  registry.addProtocol(codec);
});

// node_modules/@multiformats/multiaddr-to-uri/node_modules/@multiformats/multiaddr/dist/src/components.js
function bytesToComponents(bytes) {
  const components = [];
  let i = 0;
  while (i < bytes.length) {
    const code12 = decode48(bytes, i);
    const codec = registry.getProtocol(code12);
    const codeLength = encodingLength9(code12);
    const size = sizeForAddr2(codec, bytes, i + codeLength);
    let sizeLength = 0;
    if (size > 0 && codec.size === V2) {
      sizeLength = encodingLength9(size);
    }
    const componentLength = codeLength + sizeLength + size;
    const component = {
      code: code12,
      name: codec.name,
      bytes: bytes.subarray(i, i + componentLength)
    };
    if (size > 0) {
      const valueOffset = i + codeLength + sizeLength;
      const valueBytes = bytes.subarray(valueOffset, valueOffset + size);
      component.value = codec.bytesToValue?.(valueBytes) ?? toString8(valueBytes);
    }
    components.push(component);
    i += componentLength;
  }
  return components;
}
function componentsToBytes(components) {
  let length11 = 0;
  const bytes = [];
  for (const component of components) {
    if (component.bytes == null) {
      const codec = registry.getProtocol(component.code);
      const codecLength = encodingLength9(component.code);
      let valueBytes;
      let valueLength = 0;
      let valueLengthLength = 0;
      if (component.value != null) {
        valueBytes = codec.valueToBytes?.(component.value) ?? fromString8(component.value);
        valueLength = valueBytes.byteLength;
        if (codec.size === V2) {
          valueLengthLength = encodingLength9(valueLength);
        }
      }
      const bytes2 = new Uint8Array(codecLength + valueLengthLength + valueLength);
      let offset = 0;
      encodeUint8Array(component.code, bytes2, offset);
      offset += codecLength;
      if (valueBytes != null) {
        if (codec.size === V2) {
          encodeUint8Array(valueLength, bytes2, offset);
          offset += valueLengthLength;
        }
        bytes2.set(valueBytes, offset);
      }
      component.bytes = bytes2;
    }
    bytes.push(component.bytes);
    length11 += component.bytes.byteLength;
  }
  return concat3(bytes, length11);
}
function stringToComponents(string3) {
  if (string3.charAt(0) !== "/") {
    throw new InvalidMultiaddrError('String multiaddr must start with "/"');
  }
  const components = [];
  let collecting = "protocol";
  let value = "";
  let protocol = "";
  for (let i = 1; i < string3.length; i++) {
    const char = string3.charAt(i);
    if (char !== "/") {
      if (collecting === "protocol") {
        protocol += string3.charAt(i);
      } else {
        value += string3.charAt(i);
      }
    }
    const ended = i === string3.length - 1;
    if (char === "/" || ended) {
      const codec = registry.getProtocol(protocol);
      if (collecting === "protocol") {
        if (codec.size == null || codec.size === 0) {
          components.push({
            code: codec.code,
            name: codec.name
          });
          value = "";
          protocol = "";
          collecting = "protocol";
          continue;
        } else if (ended) {
          throw new InvalidMultiaddrError(`Component ${protocol} was missing value`);
        }
        collecting = "value";
      } else if (collecting === "value") {
        const component = {
          code: codec.code,
          name: codec.name
        };
        if (codec.size != null && codec.size !== 0) {
          if (value === "") {
            throw new InvalidMultiaddrError(`Component ${protocol} was missing value`);
          }
          component.value = codec.stringToValue?.(value) ?? value;
        }
        components.push(component);
        value = "";
        protocol = "";
        collecting = "protocol";
      }
    }
  }
  if (protocol !== "" && value !== "") {
    throw new InvalidMultiaddrError("Incomplete multiaddr");
  }
  return components;
}
function componentsToString(components) {
  return `/${components.flatMap((component) => {
    if (component.value == null) {
      return component.name;
    }
    const codec = registry.getProtocol(component.code);
    if (codec == null) {
      throw new InvalidMultiaddrError(`Unknown protocol code ${component.code}`);
    }
    return [
      component.name,
      codec.valueToString?.(component.value) ?? component.value
    ];
  }).join("/")}`;
}
function sizeForAddr2(codec, bytes, offset) {
  if (codec.size == null || codec.size === 0) {
    return 0;
  }
  if (codec.size > 0) {
    return codec.size / 8;
  }
  return decode48(bytes, offset);
}

// node_modules/@multiformats/multiaddr-to-uri/node_modules/@multiformats/multiaddr/dist/src/multiaddr.js
var inspect2 = Symbol.for("nodejs.util.inspect.custom");
var symbol2 = Symbol.for("@multiformats/multiaddr");
var DNS_CODES2 = [
  CODE_DNS,
  CODE_DNS4,
  CODE_DNS6,
  CODE_DNSADDR
];
var NoAvailableResolverError = class extends Error {
  constructor(message = "No available resolver") {
    super(message);
    this.name = "NoAvailableResolverError";
  }
};
function toComponents(addr) {
  if (addr == null) {
    addr = "/";
  }
  if (isMultiaddr2(addr)) {
    return addr.getComponents();
  }
  if (addr instanceof Uint8Array) {
    return bytesToComponents(addr);
  }
  if (typeof addr === "string") {
    addr = addr.replace(/\/(\/)+/, "/").replace(/(\/)+$/, "");
    if (addr === "") {
      addr = "/";
    }
    return stringToComponents(addr);
  }
  if (Array.isArray(addr)) {
    return addr;
  }
  throw new InvalidMultiaddrError("Must be a string, Uint8Array, Component[], or another Multiaddr");
}
var Multiaddr = class _Multiaddr {
  [symbol2] = true;
  #components;
  // cache string representation
  #string;
  // cache byte representation
  #bytes;
  constructor(addr = "/", options = {}) {
    this.#components = toComponents(addr);
    if (options.validate !== false) {
      validate3(this);
    }
  }
  get bytes() {
    if (this.#bytes == null) {
      this.#bytes = componentsToBytes(this.#components);
    }
    return this.#bytes;
  }
  toString() {
    if (this.#string == null) {
      this.#string = componentsToString(this.#components);
    }
    return this.#string;
  }
  toJSON() {
    return this.toString();
  }
  toOptions() {
    let family;
    let transport;
    let host;
    let port;
    let zone = "";
    for (const { code: code12, name: name12, value } of this.#components) {
      if (code12 === CODE_IP6ZONE) {
        zone = `%${value ?? ""}`;
      }
      if (DNS_CODES2.includes(code12)) {
        transport = "tcp";
        port = 443;
        host = `${value ?? ""}${zone}`;
        family = code12 === CODE_DNS6 ? 6 : 4;
      }
      if (code12 === CODE_TCP || code12 === CODE_UDP) {
        transport = name12 === "tcp" ? "tcp" : "udp";
        port = parseInt(value ?? "");
      }
      if (code12 === CODE_IP4 || code12 === CODE_IP6) {
        transport = "tcp";
        host = `${value ?? ""}${zone}`;
        family = code12 === CODE_IP6 ? 6 : 4;
      }
    }
    if (family == null || transport == null || host == null || port == null) {
      throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}".');
    }
    const opts = {
      family,
      host,
      transport,
      port
    };
    return opts;
  }
  getComponents() {
    return [
      ...this.#components
    ];
  }
  protos() {
    return this.#components.map(({ code: code12, value }) => {
      const codec = registry.getProtocol(code12);
      return {
        code: code12,
        size: codec.size ?? 0,
        name: codec.name,
        resolvable: Boolean(codec.resolvable),
        path: Boolean(codec.path)
      };
    });
  }
  protoCodes() {
    return this.#components.map(({ code: code12 }) => code12);
  }
  protoNames() {
    return this.#components.map(({ name: name12 }) => name12);
  }
  tuples() {
    return this.#components.map(({ code: code12, value }) => {
      if (value == null) {
        return [code12];
      }
      const codec = registry.getProtocol(code12);
      const output = [code12];
      if (value != null) {
        output.push(codec.valueToBytes?.(value) ?? fromString8(value));
      }
      return output;
    });
  }
  stringTuples() {
    return this.#components.map(({ code: code12, value }) => {
      if (value == null) {
        return [code12];
      }
      return [code12, value];
    });
  }
  encapsulate(addr) {
    const ma = new _Multiaddr(addr);
    return new _Multiaddr([
      ...this.#components,
      ...ma.getComponents()
    ], {
      validate: false
    });
  }
  decapsulate(addr) {
    const addrString = addr.toString();
    const s = this.toString();
    const i = s.lastIndexOf(addrString);
    if (i < 0) {
      throw new InvalidParametersError(`Address ${this.toString()} does not contain subaddress: ${addr.toString()}`);
    }
    return new _Multiaddr(s.slice(0, i), {
      validate: false
    });
  }
  decapsulateCode(code12) {
    let index;
    for (let i = this.#components.length - 1; i > -1; i--) {
      if (this.#components[i].code === code12) {
        index = i;
        break;
      }
    }
    return new _Multiaddr(this.#components.slice(0, index), {
      validate: false
    });
  }
  getPeerId() {
    try {
      let tuples = [];
      this.#components.forEach(({ code: code12, value }) => {
        if (code12 === CODE_P2P) {
          tuples.push([code12, value]);
        }
        if (code12 === CODE_P2P_CIRCUIT) {
          tuples = [];
        }
      });
      const tuple = tuples.pop();
      if (tuple?.[1] != null) {
        const peerIdStr = tuple[1];
        if (peerIdStr[0] === "Q" || peerIdStr[0] === "1") {
          return toString8(base58btc9.decode(`z${peerIdStr}`), "base58btc");
        }
        return toString8(CID8.parse(peerIdStr).multihash.bytes, "base58btc");
      }
      return null;
    } catch (e) {
      return null;
    }
  }
  getPath() {
    for (const component of this.#components) {
      const codec = registry.getProtocol(component.code);
      if (!codec.path) {
        continue;
      }
      return component.value ?? null;
    }
    return null;
  }
  equals(addr) {
    return equals18(this.bytes, addr.bytes);
  }
  async resolve(options) {
    const resolvableProto = this.protos().find((p) => p.resolvable);
    if (resolvableProto == null) {
      return [this];
    }
    const resolver = resolvers2.get(resolvableProto.name);
    if (resolver == null) {
      throw new NoAvailableResolverError(`no available resolver for ${resolvableProto.name}`);
    }
    const result = await resolver(this, options);
    return result.map((str) => multiaddr2(str));
  }
  nodeAddress() {
    const options = this.toOptions();
    if (options.transport !== "tcp" && options.transport !== "udp") {
      throw new Error(`multiaddr must have a valid format - no protocol with name: "${options.transport}". Must have a valid transport protocol: "{tcp, udp}"`);
    }
    return {
      family: options.family,
      address: options.host,
      port: options.port
    };
  }
  isThinWaistAddress() {
    if (this.#components.length !== 2) {
      return false;
    }
    if (this.#components[0].code !== CODE_IP4 && this.#components[0].code !== CODE_IP6) {
      return false;
    }
    if (this.#components[1].code !== CODE_TCP && this.#components[1].code !== CODE_UDP) {
      return false;
    }
    return true;
  }
  /**
   * Returns Multiaddr as a human-readable string
   * https://nodejs.org/api/util.html#utilinspectcustom
   *
   * @example
   * ```js
   * import { multiaddr } from '@multiformats/multiaddr'
   *
   * console.info(multiaddr('/ip4/127.0.0.1/tcp/4001'))
   * // 'Multiaddr(/ip4/127.0.0.1/tcp/4001)'
   * ```
   */
  [inspect2]() {
    return `Multiaddr(${this.toString()})`;
  }
};
function validate3(addr) {
  addr.getComponents().forEach((component) => {
    const codec = registry.getProtocol(component.code);
    if (component.value == null) {
      return;
    }
    codec.validate?.(component.value);
  });
}

// node_modules/@chainsafe/netmask/dist/src/ip.js
var maxIPv6Octet = parseInt("0xFFFF", 16);
var ipv4Prefix = new Uint8Array([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  255,
  255
]);

// node_modules/@multiformats/multiaddr-to-uri/node_modules/@multiformats/multiaddr/dist/src/index.js
var resolvers2 = /* @__PURE__ */ new Map();
function isMultiaddr2(value) {
  return Boolean(value?.[symbol2]);
}
function multiaddr2(addr) {
  return new Multiaddr(addr);
}
function protocols(proto) {
  const codec = registry.getProtocol(proto);
  return {
    code: codec.code,
    size: codec.size ?? 0,
    name: codec.name,
    resolvable: Boolean(codec.resolvable),
    path: Boolean(codec.path)
  };
}

// node_modules/@multiformats/multiaddr-to-uri/dist/src/index.js
function extractSNI(ma) {
  let sniProtoCode;
  try {
    sniProtoCode = protocols("sni").code;
  } catch (e) {
    return null;
  }
  for (const [proto, value] of ma) {
    if (proto === sniProtoCode && value !== void 0) {
      return value;
    }
  }
  return null;
}
function hasTLS(ma) {
  return ma.some(([proto, _]) => proto === protocols("tls").code);
}
function interpretNext(headProtoCode, headProtoVal, restMa) {
  const interpreter = interpreters[protocols(headProtoCode).name];
  if (interpreter === void 0) {
    throw new Error(`Can't interpret protocol ${protocols(headProtoCode).name}`);
  }
  const restVal = interpreter(headProtoVal, restMa);
  if (headProtoCode === protocols("ip6").code) {
    return `[${restVal}]`;
  }
  return restVal;
}
var interpreters = {
  ip4: (value, restMa) => value,
  ip6: (value, restMa) => {
    if (restMa.length === 0) {
      return value;
    }
    return `[${value}]`;
  },
  tcp: (value, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    return `tcp://${interpretNext(tailProto[0], tailProto[1] ?? "", restMa)}:${value}`;
  },
  udp: (value, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    return `udp://${interpretNext(tailProto[0], tailProto[1] ?? "", restMa)}:${value}`;
  },
  dnsaddr: (value, restMa) => value,
  dns4: (value, restMa) => value,
  dns6: (value, restMa) => value,
  dns: (value, restMa) => value,
  ipfs: (value, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    return `${interpretNext(tailProto[0], tailProto[1] ?? "", restMa)}/ipfs/${value}`;
  },
  p2p: (value, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    return `${interpretNext(tailProto[0], tailProto[1] ?? "", restMa)}/p2p/${value}`;
  },
  http: (value, restMa) => {
    const maHasTLS = hasTLS(restMa);
    const sni = extractSNI(restMa);
    if (maHasTLS && sni !== null) {
      return `https://${sni}`;
    }
    const protocol = maHasTLS ? "https://" : "http://";
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    let baseVal = interpretNext(tailProto[0], tailProto[1] ?? "", restMa);
    baseVal = baseVal.replace("tcp://", "");
    return `${protocol}${baseVal}`;
  },
  tls: (value, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    return interpretNext(tailProto[0], tailProto[1] ?? "", restMa);
  },
  sni: (value, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    return interpretNext(tailProto[0], tailProto[1] ?? "", restMa);
  },
  https: (value, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    let baseVal = interpretNext(tailProto[0], tailProto[1] ?? "", restMa);
    baseVal = baseVal.replace("tcp://", "");
    return `https://${baseVal}`;
  },
  ws: (value, restMa) => {
    const maHasTLS = hasTLS(restMa);
    const sni = extractSNI(restMa);
    if (maHasTLS && sni !== null) {
      return `wss://${sni}`;
    }
    const protocol = maHasTLS ? "wss://" : "ws://";
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    let baseVal = interpretNext(tailProto[0], tailProto[1] ?? "", restMa);
    baseVal = baseVal.replace("tcp://", "");
    return `${protocol}${baseVal}`;
  },
  wss: (value, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    let baseVal = interpretNext(tailProto[0], tailProto[1] ?? "", restMa);
    baseVal = baseVal.replace("tcp://", "");
    return `wss://${baseVal}`;
  },
  "p2p-websocket-star": (value, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    return `${interpretNext(tailProto[0], tailProto[1] ?? "", restMa)}/p2p-websocket-star`;
  },
  "p2p-webrtc-star": (value, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    return `${interpretNext(tailProto[0], tailProto[1] ?? "", restMa)}/p2p-webrtc-star`;
  },
  "p2p-webrtc-direct": (value, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    return `${interpretNext(tailProto[0], tailProto[1] ?? "", restMa)}/p2p-webrtc-direct`;
  }
};
function multiaddrToUri(input, opts) {
  const ma = multiaddr2(input);
  const parts = ma.stringTuples();
  const head = parts.pop();
  if (head === void 0) {
    throw new Error("Unexpected end of multiaddr");
  }
  const protocol = protocols(head[0]);
  const interpreter = interpreters[protocol.name];
  if (interpreter == null) {
    throw new Error(`No interpreter found for ${protocol.name}`);
  }
  let uri = interpreter(head[1] ?? "", parts);
  if (opts?.assumeHttp !== false && head[0] === protocols("tcp").code) {
    uri = uri.replace("tcp://", "http://");
    if (head[1] === "443" || head[1] === "80") {
      if (head[1] === "443") {
        uri = uri.replace("http://", "https://");
      }
      uri = uri.substring(0, uri.lastIndexOf(":"));
    }
  }
  return uri;
}

// node_modules/ipfs-core-utils/src/to-url-string.js
function toUrlString(url) {
  try {
    url = multiaddrToUri(multiaddr(url));
  } catch (err) {
  }
  url = url.toString();
  return url;
}

// node_modules/ipfs-core-utils/src/agent.browser.js
var agent_browser_default = () => {
};

// node_modules/ipfs-http-client/src/lib/core.js
var log = logger("ipfs-http-client:lib:error-handler");
var merge = merge_options_default.bind({ ignoreUndefined: true });
var DEFAULT_PROTOCOL = import_env.isBrowser || import_env.isWebWorker ? location.protocol : "http";
var DEFAULT_HOST = import_env.isBrowser || import_env.isWebWorker ? location.hostname : "localhost";
var DEFAULT_PORT = import_env.isBrowser || import_env.isWebWorker ? location.port : "5001";
var normalizeOptions = (options = {}) => {
  let url;
  let opts = {};
  let agent;
  if (typeof options === "string" || isMultiaddr(options)) {
    url = new URL(toUrlString(options));
  } else if (options instanceof URL) {
    url = options;
  } else if (typeof options.url === "string" || isMultiaddr(options.url)) {
    url = new URL(toUrlString(options.url));
    opts = options;
  } else if (options.url instanceof URL) {
    url = options.url;
    opts = options;
  } else {
    opts = options || {};
    const protocol = (opts.protocol || DEFAULT_PROTOCOL).replace(":", "");
    const host = (opts.host || DEFAULT_HOST).split(":")[0];
    const port = opts.port || DEFAULT_PORT;
    url = new URL(`${protocol}://${host}:${port}`);
  }
  if (opts.apiPath) {
    url.pathname = opts.apiPath;
  } else if (url.pathname === "/" || url.pathname === void 0) {
    url.pathname = "api/v0";
  }
  if (import_env.isNode) {
    const Agent = agent_browser_default(url);
    agent = opts.agent || new Agent({
      keepAlive: true,
      // Similar to browsers which limit connections to six per host
      maxSockets: 6
    });
  }
  return {
    ...opts,
    host: url.host,
    protocol: url.protocol.replace(":", ""),
    port: Number(url.port),
    apiPath: url.pathname,
    url,
    agent
  };
};
var errorHandler = async (response) => {
  let msg;
  try {
    if ((response.headers.get("Content-Type") || "").startsWith("application/json")) {
      const data = await response.json();
      log(data);
      msg = data.Message || data.message;
    } else {
      msg = await response.text();
    }
  } catch (err) {
    log("Failed to parse error response", err);
    msg = err.message;
  }
  let error = new import_http.default.HTTPError(response);
  if (msg) {
    if (msg.includes("deadline has elapsed")) {
      error = new import_http.default.TimeoutError();
    }
    if (msg && msg.includes("context deadline exceeded")) {
      error = new import_http.default.TimeoutError();
    }
  }
  if (msg && msg.includes("request timed out")) {
    error = new import_http.default.TimeoutError();
  }
  if (msg) {
    error.message = msg;
  }
  throw error;
};
var KEBAB_REGEX = /[A-Z\u00C0-\u00D6\u00D8-\u00DE]/g;
var kebabCase = (str) => {
  return str.replace(KEBAB_REGEX, function(match) {
    return "-" + match.toLowerCase();
  });
};
var parseTimeout = (value) => {
  return typeof value === "string" ? parse_duration_default(value) : value;
};
var Client = class extends import_http.default {
  /**
   * @param {Options|URL|Multiaddr|string} [options]
   */
  constructor(options = {}) {
    const opts = normalizeOptions(options);
    super({
      timeout: parseTimeout(opts.timeout || 0) || void 0,
      headers: opts.headers,
      base: `${opts.url}`,
      handleError: errorHandler,
      transformSearchParams: (search) => {
        const out = new URLSearchParams();
        for (const [key, value] of search) {
          if (value !== "undefined" && value !== "null" && key !== "signal") {
            out.append(kebabCase(key), value);
          }
          if (key === "timeout" && !isNaN(value)) {
            out.append(kebabCase(key), value);
          }
        }
        return out;
      },
      // @ts-expect-error this can be a https agent or a http agent
      agent: opts.agent
    });
    delete this.get;
    delete this.put;
    delete this.delete;
    delete this.options;
    const fetch2 = this.fetch;
    this.fetch = (resource, options2 = {}) => {
      if (typeof resource === "string" && !resource.startsWith("/")) {
        resource = `${opts.url}/${resource}`;
      }
      return fetch2.call(this, resource, merge(options2, {
        method: "POST"
      }));
    };
  }
};
var HTTPError = import_http.default.HTTPError;

// node_modules/ipfs-http-client/src/lib/configure.js
var configure = (fn) => {
  return (options) => {
    return fn(new Client(options), options);
  };
};

// node_modules/ipfs-http-client/src/lib/mode-to-string.js
function modeToString(mode) {
  if (mode == null) {
    return void 0;
  }
  if (typeof mode === "string") {
    return mode;
  }
  return mode.toString(8).padStart(4, "0");
}

// node_modules/ipfs-http-client/src/lib/parse-mtime.js
var import_err_code2 = __toESM(require_err_code(), 1);
function parseMtime(input) {
  if (input == null) {
    return void 0;
  }
  let mtime;
  if (input.secs != null) {
    mtime = {
      secs: input.secs,
      nsecs: input.nsecs
    };
  }
  if (input.Seconds != null) {
    mtime = {
      secs: input.Seconds,
      nsecs: input.FractionalNanoseconds
    };
  }
  if (Array.isArray(input)) {
    mtime = {
      secs: input[0],
      nsecs: input[1]
    };
  }
  if (input instanceof Date) {
    const ms = input.getTime();
    const secs = Math.floor(ms / 1e3);
    mtime = {
      secs,
      nsecs: (ms - secs * 1e3) * 1e3
    };
  }
  if (!Object.prototype.hasOwnProperty.call(mtime, "secs")) {
    return void 0;
  }
  if (mtime != null && mtime.nsecs != null && (mtime.nsecs < 0 || mtime.nsecs > 999999999)) {
    throw (0, import_err_code2.default)(new Error("mtime-nsecs must be within the range [0,999999999]"), "ERR_INVALID_MTIME_NSECS");
  }
  return mtime;
}

// node_modules/ipfs-http-client/src/lib/to-url-search-params.js
function toUrlSearchParams({ arg, searchParams, hashAlg, mtime, mode, ...options } = {}) {
  if (searchParams) {
    options = {
      ...options,
      ...searchParams
    };
  }
  if (hashAlg) {
    options.hash = hashAlg;
  }
  if (mtime != null) {
    mtime = parseMtime(mtime);
    options.mtime = mtime.secs;
    options.mtimeNsecs = mtime.nsecs;
  }
  if (mode != null) {
    options.mode = modeToString(mode);
  }
  if (options.timeout && !isNaN(options.timeout)) {
    options.timeout = `${options.timeout}ms`;
  }
  if (arg === void 0 || arg === null) {
    arg = [];
  } else if (!Array.isArray(arg)) {
    arg = [arg];
  }
  const urlSearchParams = new URLSearchParams(options);
  arg.forEach((arg2) => urlSearchParams.append("arg", arg2));
  return urlSearchParams;
}

// node_modules/ipfs-http-client/src/bitswap/wantlist.js
var createWantlist = configure((api) => {
  async function wantlist(options = {}) {
    const res = await (await api.post("bitswap/wantlist", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    })).json();
    return (res.Keys || []).map((k) => CID5.parse(k["/"]));
  }
  return wantlist;
});

// node_modules/ipfs-http-client/src/bitswap/wantlist-for-peer.js
var createWantlistForPeer = configure((api) => {
  async function wantlistForPeer(peerId, options = {}) {
    const res = await (await api.post("bitswap/wantlist", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        ...options,
        peer: peerId.toString()
      }),
      headers: options.headers
    })).json();
    return (res.Keys || []).map((k) => CID5.parse(k["/"]));
  }
  return wantlistForPeer;
});

// node_modules/@libp2p/interface-peer-id/dist/src/index.js
var symbol3 = Symbol.for("@libp2p/peer-id");

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base58.js
var base58_exports5 = {};
__export(base58_exports5, {
  base58btc: () => base58btc10,
  base58flickr: () => base58flickr10
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/vendor/base-x.js
function base12(ALPHABET, name12) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode42(source) {
    if (source instanceof Uint8Array) ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length11 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length11) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length11 = i2;
      pbegin++;
    }
    var it2 = size - length11;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length11 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length11) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length11 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length11;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode58(string3) {
    var buffer2 = decodeUnsafe(string3);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name12} character`);
  }
  return {
    encode: encode42,
    decodeUnsafe,
    decode: decode58
  };
}
var src10 = base12;
var _brrp__multiformats_scope_baseX10 = src10;
var base_x_default10 = _brrp__multiformats_scope_baseX10;

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/bytes.js
var empty10 = new Uint8Array(0);
var equals19 = (aa, bb) => {
  if (aa === bb) return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
};
var coerce10 = (o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array") return o;
  if (o instanceof ArrayBuffer) return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};
var fromString9 = (str) => new TextEncoder().encode(str);
var toString9 = (b) => new TextDecoder().decode(b);

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base.js
var Encoder10 = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   */
  constructor(name12, prefix, baseEncode) {
    this.name = name12;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {API.Multibase<Prefix>}
   */
  encode(bytes) {
    if (bytes instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder10 = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name12, prefix, baseDecode) {
    this.name = name12;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = /** @type {number} */
    prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  /**
   * @param {string} text
   */
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or10(this, decoder);
  }
};
var ComposedDecoder10 = class {
  /**
   * @param {Decoders<Prefix>} decoders
   */
  constructor(decoders3) {
    this.decoders = decoders3;
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or10(this, decoder);
  }
  /**
   * @param {string} input
   * @returns {Uint8Array}
   */
  decode(input) {
    const prefix = (
      /** @type {Prefix} */
      input[0]
    );
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or10 = (left, right) => new ComposedDecoder10(
  /** @type {Decoders<L|R>} */
  {
    ...left.decoders || { [
      /** @type API.UnibaseDecoder<L> */
      left.prefix
    ]: left },
    ...right.decoders || { [
      /** @type API.UnibaseDecoder<R> */
      right.prefix
    ]: right }
  }
);
var Codec10 = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name12, prefix, baseEncode, baseDecode) {
    this.name = name12;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder10(name12, prefix, baseEncode);
    this.decoder = new Decoder10(name12, prefix, baseDecode);
  }
  /**
   * @param {Uint8Array} input
   */
  encode(input) {
    return this.encoder.encode(input);
  }
  /**
   * @param {string} input
   */
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from14 = ({ name: name12, prefix, encode: encode42, decode: decode58 }) => new Codec10(name12, prefix, encode42, decode58);
var baseX10 = ({ prefix, name: name12, alphabet: alphabet7 }) => {
  const { encode: encode42, decode: decode58 } = base_x_default10(alphabet7, name12);
  return from14({
    prefix,
    name: name12,
    encode: encode42,
    /**
     * @param {string} text
     */
    decode: (text) => coerce10(decode58(text))
  });
};
var decode49 = (string3, alphabet7, bitsPerChar, name12) => {
  const codes2 = {};
  for (let i = 0; i < alphabet7.length; ++i) {
    codes2[alphabet7[i]] = i;
  }
  let end = string3.length;
  while (string3[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes2[string3[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name12} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer2 >> bits;
    }
  }
  if (bits >= bitsPerChar || 255 & buffer2 << 8 - bits) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
var encode36 = (data, alphabet7, bitsPerChar) => {
  const pad = alphabet7[alphabet7.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer2 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer2 = buffer2 << 8 | data[i];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet7[mask & buffer2 >> bits];
    }
  }
  if (bits) {
    out += alphabet7[mask & buffer2 << bitsPerChar - bits];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
var rfc464810 = ({ name: name12, prefix, bitsPerChar, alphabet: alphabet7 }) => {
  return from14({
    prefix,
    name: name12,
    encode(input) {
      return encode36(input, alphabet7, bitsPerChar);
    },
    decode(input) {
      return decode49(input, alphabet7, bitsPerChar, name12);
    }
  });
};

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base58.js
var base58btc10 = baseX10({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr10 = baseX10({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/identity.js
var identity_exports9 = {};
__export(identity_exports9, {
  identity: () => identity9
});
var identity9 = from14({
  prefix: "\0",
  name: "identity",
  encode: (buf2) => toString9(buf2),
  decode: (str) => fromString9(str)
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base2.js
var base2_exports5 = {};
__export(base2_exports5, {
  base2: () => base26
});
var base26 = rfc464810({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base8.js
var base8_exports5 = {};
__export(base8_exports5, {
  base8: () => base85
});
var base85 = rfc464810({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base10.js
var base10_exports5 = {};
__export(base10_exports5, {
  base10: () => base105
});
var base105 = baseX10({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base16.js
var base16_exports5 = {};
__export(base16_exports5, {
  base16: () => base165,
  base16upper: () => base16upper5
});
var base165 = rfc464810({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper5 = rfc464810({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base32.js
var base32_exports5 = {};
__export(base32_exports5, {
  base32: () => base3210,
  base32hex: () => base32hex10,
  base32hexpad: () => base32hexpad10,
  base32hexpadupper: () => base32hexpadupper10,
  base32hexupper: () => base32hexupper10,
  base32pad: () => base32pad10,
  base32padupper: () => base32padupper10,
  base32upper: () => base32upper10,
  base32z: () => base32z10
});
var base3210 = rfc464810({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper10 = rfc464810({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad10 = rfc464810({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper10 = rfc464810({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex10 = rfc464810({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper10 = rfc464810({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad10 = rfc464810({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper10 = rfc464810({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z10 = rfc464810({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base36.js
var base36_exports5 = {};
__export(base36_exports5, {
  base36: () => base368,
  base36upper: () => base36upper8
});
var base368 = baseX10({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper8 = baseX10({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base64.js
var base64_exports5 = {};
__export(base64_exports5, {
  base64: () => base648,
  base64pad: () => base64pad8,
  base64url: () => base64url8,
  base64urlpad: () => base64urlpad8
});
var base648 = rfc464810({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad8 = rfc464810({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url8 = rfc464810({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad8 = rfc464810({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base256emoji.js
var base256emoji_exports5 = {};
__export(base256emoji_exports5, {
  base256emoji: () => base256emoji5
});
var alphabet6 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars5 = (
  /** @type {string[]} */
  alphabet6.reduce(
    (p, c, i) => {
      p[i] = c;
      return p;
    },
    /** @type {string[]} */
    []
  )
);
var alphabetCharsToBytes5 = (
  /** @type {number[]} */
  alphabet6.reduce(
    (p, c, i) => {
      p[
        /** @type {number} */
        c.codePointAt(0)
      ] = i;
      return p;
    },
    /** @type {number[]} */
    []
  )
);
function encode37(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars5[c];
    return p;
  }, "");
}
function decode50(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes5[
      /** @type {number} */
      char.codePointAt(0)
    ];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji5 = from14({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode37,
  decode: decode50
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/hashes/sha2-browser.js
var sha2_browser_exports5 = {};
__export(sha2_browser_exports5, {
  sha256: () => sha2567,
  sha512: () => sha5126
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/vendor/varint.js
var encode_19 = encode38;
var MSB10 = 128;
var REST10 = 127;
var MSBALL9 = ~REST10;
var INT9 = Math.pow(2, 31);
function encode38(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT9) {
    out[offset++] = num & 255 | MSB10;
    num /= 128;
  }
  while (num & MSBALL9) {
    out[offset++] = num & 255 | MSB10;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode38.bytes = offset - oldOffset + 1;
  return out;
}
var decode51 = read9;
var MSB$19 = 128;
var REST$19 = 127;
function read9(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
  do {
    if (counter >= l) {
      read9.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf2[counter++];
    res += shift < 28 ? (b & REST$19) << shift : (b & REST$19) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$19);
  read9.bytes = counter - offset;
  return res;
}
var N110 = Math.pow(2, 7);
var N210 = Math.pow(2, 14);
var N310 = Math.pow(2, 21);
var N410 = Math.pow(2, 28);
var N510 = Math.pow(2, 35);
var N610 = Math.pow(2, 42);
var N710 = Math.pow(2, 49);
var N89 = Math.pow(2, 56);
var N99 = Math.pow(2, 63);
var length9 = function(value) {
  return value < N110 ? 1 : value < N210 ? 2 : value < N310 ? 3 : value < N410 ? 4 : value < N510 ? 5 : value < N610 ? 6 : value < N710 ? 7 : value < N89 ? 8 : value < N99 ? 9 : 10;
};
var varint12 = {
  encode: encode_19,
  decode: decode51,
  encodingLength: length9
};
var _brrp_varint9 = varint12;
var varint_default9 = _brrp_varint9;

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/varint.js
var decode52 = (data, offset = 0) => {
  const code12 = varint_default9.decode(data, offset);
  return [code12, varint_default9.decode.bytes];
};
var encodeTo9 = (int, target, offset = 0) => {
  varint_default9.encode(int, target, offset);
  return target;
};
var encodingLength10 = (int) => {
  return varint_default9.encodingLength(int);
};

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/hashes/digest.js
var create9 = (code12, digest6) => {
  const size = digest6.byteLength;
  const sizeOffset = encodingLength10(code12);
  const digestOffset = sizeOffset + encodingLength10(size);
  const bytes = new Uint8Array(digestOffset + size);
  encodeTo9(code12, bytes, 0);
  encodeTo9(size, bytes, sizeOffset);
  bytes.set(digest6, digestOffset);
  return new Digest9(code12, size, digest6, bytes);
};
var decode53 = (multihash) => {
  const bytes = coerce10(multihash);
  const [code12, sizeOffset] = decode52(bytes);
  const [size, digestOffset] = decode52(bytes.subarray(sizeOffset));
  const digest6 = bytes.subarray(sizeOffset + digestOffset);
  if (digest6.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest9(code12, size, digest6, bytes);
};
var equals20 = (a, b) => {
  if (a === b) {
    return true;
  } else {
    const data = (
      /** @type {{code?:unknown, size?:unknown, bytes?:unknown}} */
      b
    );
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals19(a.bytes, data.bytes);
  }
};
var Digest9 = class {
  /**
   * Creates a multihash digest.
   *
   * @param {Code} code
   * @param {Size} size
   * @param {Uint8Array} digest
   * @param {Uint8Array} bytes
   */
  constructor(code12, size, digest6, bytes) {
    this.code = code12;
    this.size = size;
    this.digest = digest6;
    this.bytes = bytes;
  }
};

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/hashes/hasher.js
var from15 = ({ name: name12, code: code12, encode: encode42 }) => new Hasher5(name12, code12, encode42);
var Hasher5 = class {
  /**
   *
   * @param {Name} name
   * @param {Code} code
   * @param {(input: Uint8Array) => Await<Uint8Array>} encode
   */
  constructor(name12, code12, encode42) {
    this.name = name12;
    this.code = code12;
    this.encode = encode42;
  }
  /**
   * @param {Uint8Array} input
   * @returns {Await<Digest.Digest<Code, number>>}
   */
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create9(this.code, result) : result.then((digest6) => create9(this.code, digest6));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/hashes/sha2-browser.js
var sha5 = (name12) => (
  /**
   * @param {Uint8Array} data
   */
  async (data) => new Uint8Array(await crypto.subtle.digest(name12, data))
);
var sha2567 = from15({
  name: "sha2-256",
  code: 18,
  encode: sha5("SHA-256")
});
var sha5126 = from15({
  name: "sha2-512",
  code: 19,
  encode: sha5("SHA-512")
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/hashes/identity.js
var identity_exports10 = {};
__export(identity_exports10, {
  identity: () => identity10
});
var code11 = 0;
var name11 = "identity";
var encode39 = coerce10;
var digest5 = (input) => create9(code11, encode39(input));
var identity10 = { code: code11, name: name11, encode: encode39, digest: digest5 };

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/codecs/json.js
var textEncoder8 = new TextEncoder();
var textDecoder7 = new TextDecoder();

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/cid.js
var format10 = (link, base14) => {
  const { bytes, version } = link;
  switch (version) {
    case 0:
      return toStringV09(
        bytes,
        baseCache9(link),
        /** @type {API.MultibaseEncoder<"z">} */
        base14 || base58btc10.encoder
      );
    default:
      return toStringV19(
        bytes,
        baseCache9(link),
        /** @type {API.MultibaseEncoder<Prefix>} */
        base14 || base3210.encoder
      );
  }
};
var cache9 = /* @__PURE__ */ new WeakMap();
var baseCache9 = (cid) => {
  const baseCache11 = cache9.get(cid);
  if (baseCache11 == null) {
    const baseCache12 = /* @__PURE__ */ new Map();
    cache9.set(cid, baseCache12);
    return baseCache12;
  }
  return baseCache11;
};
var CID9 = class _CID {
  /**
   * @param {Version} version - Version of the CID
   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.
   * @param {Uint8Array} bytes
   *
   */
  constructor(version, code12, multihash, bytes) {
    this.code = code12;
    this.version = version;
    this.multihash = multihash;
    this.bytes = bytes;
    this["/"] = bytes;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  /**
   * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}
   */
  toV0() {
    switch (this.version) {
      case 0: {
        return (
          /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
          this
        );
      }
      case 1: {
        const { code: code12, multihash } = this;
        if (code12 !== DAG_PB_CODE9) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE9) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return (
          /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
          _CID.createV0(
            /** @type {API.MultihashDigest<API.SHA_256>} */
            multihash
          )
        );
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 0. This is a bug please report`
        );
      }
    }
  }
  /**
   * @returns {CID<Data, Format, Alg, 1>}
   */
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code12, digest: digest6 } = this.multihash;
        const multihash = create9(code12, digest6);
        return (
          /** @type {CID<Data, Format, Alg, 1>} */
          _CID.createV1(this.code, multihash)
        );
      }
      case 1: {
        return (
          /** @type {CID<Data, Format, Alg, 1>} */
          this
        );
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 1. This is a bug please report`
        );
      }
    }
  }
  /**
   * @param {unknown} other
   * @returns {other is CID<Data, Format, Alg, Version>}
   */
  equals(other) {
    return _CID.equals(this, other);
  }
  /**
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @param {API.Link<Data, Format, Alg, Version>} self
   * @param {unknown} other
   * @returns {other is CID}
   */
  static equals(self2, other) {
    const unknown = (
      /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */
      other
    );
    return unknown && self2.code === unknown.code && self2.version === unknown.version && equals20(self2.multihash, unknown.multihash);
  }
  /**
   * @param {API.MultibaseEncoder<string>} [base]
   * @returns {string}
   */
  toString(base14) {
    return format10(this, base14);
  }
  toJSON() {
    return { "/": format10(this) };
  }
  link() {
    return this;
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   *
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @template {unknown} U
   * @param {API.Link<Data, Format, Alg, Version>|U} input
   * @returns {CID<Data, Format, Alg, Version>|null}
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value = (
      /** @type {any} */
      input
    );
    if (value instanceof _CID) {
      return value;
    } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
      const { version, code: code12, multihash, bytes } = value;
      return new _CID(
        version,
        code12,
        /** @type {API.MultihashDigest<Alg>} */
        multihash,
        bytes || encodeCID9(version, code12, multihash.bytes)
      );
    } else if (value[cidSymbol9] === true) {
      const { version, multihash, code: code12 } = value;
      const digest6 = (
        /** @type {API.MultihashDigest<Alg>} */
        decode53(multihash)
      );
      return _CID.create(version, code12, digest6);
    } else {
      return null;
    }
  }
  /**
   *
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @param {Version} version - Version of the CID
   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.
   * @returns {CID<Data, Format, Alg, Version>}
   */
  static create(version, code12, digest6) {
    if (typeof code12 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest6.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version) {
      case 0: {
        if (code12 !== DAG_PB_CODE9) {
          throw new Error(
            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE9}) block encoding`
          );
        } else {
          return new _CID(version, code12, digest6, digest6.bytes);
        }
      }
      case 1: {
        const bytes = encodeCID9(version, code12, digest6.bytes);
        return new _CID(version, code12, digest6, bytes);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   *
   * @template {unknown} [T=unknown]
   * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.
   * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}
   */
  static createV0(digest6) {
    return _CID.create(0, DAG_PB_CODE9, digest6);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @param {Code} code - Content encoding format code.
   * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.
   * @returns {CID<Data, Code, Alg, 1>}
   */
  static createV1(code12, digest6) {
    return _CID.create(1, code12, digest6);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   *
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @template {API.Version} Ver
   * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes
   * @returns {CID<Data, Code, Alg, Ver>}
   */
  static decode(bytes) {
    const [cid, remainder] = _CID.decodeFirst(bytes);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   *
   * @template {unknown} T
   * @template {number} C
   * @template {number} A
   * @template {API.Version} V
   * @param {API.ByteView<API.Link<T, C, A, V>>} bytes
   * @returns {[CID<T, C, A, V>, Uint8Array]}
   */
  static decodeFirst(bytes) {
    const specs = _CID.inspectBytes(bytes);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce10(
      bytes.subarray(prefixSize, prefixSize + specs.multihashSize)
    );
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(
      specs.multihashSize - specs.digestSize
    );
    const digest6 = new Digest9(
      specs.multihashCode,
      specs.digestSize,
      digestBytes,
      multihashBytes
    );
    const cid = specs.version === 0 ? _CID.createV0(
      /** @type {API.MultihashDigest<API.SHA_256>} */
      digest6
    ) : _CID.createV1(specs.codec, digest6);
    return [
      /** @type {CID<T, C, A, V>} */
      cid,
      bytes.subarray(specs.size)
    ];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   *
   * @template {unknown} T
   * @template {number} C
   * @template {number} A
   * @template {API.Version} V
   * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes
   * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i, length11] = decode52(initialBytes.subarray(offset));
      offset += length11;
      return i;
    };
    let version = (
      /** @type {V} */
      next()
    );
    let codec = (
      /** @type {C} */
      DAG_PB_CODE9
    );
    if (
      /** @type {number} */
      version === 18
    ) {
      version = /** @type {V} */
      0;
      offset = 0;
    } else {
      codec = /** @type {C} */
      next();
    }
    if (version !== 0 && version !== 1) {
      throw new RangeError(`Invalid CID version ${version}`);
    }
    const prefixSize = offset;
    const multihashCode = (
      /** @type {A} */
      next()
    );
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   *
   * @template {string} Prefix
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @template {API.Version} Ver
   * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source
   * @param {API.MultibaseDecoder<Prefix>} [base]
   * @returns {CID<Data, Code, Alg, Ver>}
   */
  static parse(source, base14) {
    const [prefix, bytes] = parseCIDtoBytes9(source, base14);
    const cid = _CID.decode(bytes);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache9(cid).set(prefix, source);
    return cid;
  }
};
var parseCIDtoBytes9 = (source, base14) => {
  switch (source[0]) {
    // CIDv0 is parsed differently
    case "Q": {
      const decoder = base14 || base58btc10;
      return [
        /** @type {Prefix} */
        base58btc10.prefix,
        decoder.decode(`${base58btc10.prefix}${source}`)
      ];
    }
    case base58btc10.prefix: {
      const decoder = base14 || base58btc10;
      return [
        /** @type {Prefix} */
        base58btc10.prefix,
        decoder.decode(source)
      ];
    }
    case base3210.prefix: {
      const decoder = base14 || base3210;
      return [
        /** @type {Prefix} */
        base3210.prefix,
        decoder.decode(source)
      ];
    }
    default: {
      if (base14 == null) {
        throw Error(
          "To parse non base32 or base58btc encoded CID multibase decoder must be provided"
        );
      }
      return [
        /** @type {Prefix} */
        source[0],
        base14.decode(source)
      ];
    }
  }
};
var toStringV09 = (bytes, cache11, base14) => {
  const { prefix } = base14;
  if (prefix !== base58btc10.prefix) {
    throw Error(`Cannot string encode V0 in ${base14.name} encoding`);
  }
  const cid = cache11.get(prefix);
  if (cid == null) {
    const cid2 = base14.encode(bytes).slice(1);
    cache11.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var toStringV19 = (bytes, cache11, base14) => {
  const { prefix } = base14;
  const cid = cache11.get(prefix);
  if (cid == null) {
    const cid2 = base14.encode(bytes);
    cache11.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var DAG_PB_CODE9 = 112;
var SHA_256_CODE9 = 18;
var encodeCID9 = (version, code12, multihash) => {
  const codeOffset = encodingLength10(version);
  const hashOffset = codeOffset + encodingLength10(code12);
  const bytes = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo9(version, bytes, 0);
  encodeTo9(code12, bytes, codeOffset);
  bytes.set(multihash, hashOffset);
  return bytes;
};
var cidSymbol9 = Symbol.for("@ipld/js-cid/CID");

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/basics.js
var bases5 = { ...identity_exports9, ...base2_exports5, ...base8_exports5, ...base10_exports5, ...base16_exports5, ...base32_exports5, ...base36_exports5, ...base58_exports5, ...base64_exports5, ...base256emoji_exports5 };
var hashes5 = { ...sha2_browser_exports5, ...identity_exports10 };

// node_modules/@libp2p/peer-id/dist/src/index.js
var inspect3 = Symbol.for("nodejs.util.inspect.custom");
var baseDecoder = Object.values(bases5).map((codec) => codec.decoder).reduce((acc, curr) => acc.or(curr), bases5.identity.decoder);
var LIBP2P_KEY_CODE = 114;
var MARSHALLED_ED225519_PUBLIC_KEY_LENGTH = 36;
var MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH = 37;
var PeerIdImpl = class {
  type;
  multihash;
  privateKey;
  publicKey;
  string;
  constructor(init) {
    this.type = init.type;
    this.multihash = init.multihash;
    this.privateKey = init.privateKey;
    Object.defineProperty(this, "string", {
      enumerable: false,
      writable: true
    });
  }
  get [Symbol.toStringTag]() {
    return `PeerId(${this.toString()})`;
  }
  [symbol3] = true;
  toString() {
    if (this.string == null) {
      this.string = base58btc10.encode(this.multihash.bytes).slice(1);
    }
    return this.string;
  }
  // return self-describing String representation
  // in default format from RFC 0001: https://github.com/libp2p/specs/pull/209
  toCID() {
    return CID9.createV1(LIBP2P_KEY_CODE, this.multihash);
  }
  toBytes() {
    return this.multihash.bytes;
  }
  /**
   * Returns Multiaddr as a JSON string
   */
  toJSON() {
    return this.toString();
  }
  /**
   * Checks the equality of `this` peer against a given PeerId
   */
  equals(id) {
    if (id instanceof Uint8Array) {
      return equals15(this.multihash.bytes, id);
    } else if (typeof id === "string") {
      return peerIdFromString(id).equals(this);
    } else if (id?.multihash?.bytes != null) {
      return equals15(this.multihash.bytes, id.multihash.bytes);
    } else {
      throw new Error("not valid Id");
    }
  }
  /**
   * Returns PeerId as a human-readable string
   * https://nodejs.org/api/util.html#utilinspectcustom
   *
   * @example
   * ```js
   * import { peerIdFromString } from '@libp2p/peer-id'
   *
   * console.info(peerIdFromString('QmFoo'))
   * // 'PeerId(QmFoo)'
   * ```
   */
  [inspect3]() {
    return `PeerId(${this.toString()})`;
  }
};
var RSAPeerIdImpl = class extends PeerIdImpl {
  type = "RSA";
  publicKey;
  constructor(init) {
    super({ ...init, type: "RSA" });
    this.publicKey = init.publicKey;
  }
};
var Ed25519PeerIdImpl = class extends PeerIdImpl {
  type = "Ed25519";
  publicKey;
  constructor(init) {
    super({ ...init, type: "Ed25519" });
    this.publicKey = init.multihash.digest;
  }
};
var Secp256k1PeerIdImpl = class extends PeerIdImpl {
  type = "secp256k1";
  publicKey;
  constructor(init) {
    super({ ...init, type: "secp256k1" });
    this.publicKey = init.multihash.digest;
  }
};
function peerIdFromString(str, decoder) {
  decoder = decoder ?? baseDecoder;
  if (str.charAt(0) === "1" || str.charAt(0) === "Q") {
    const multihash = decode53(base58btc10.decode(`z${str}`));
    if (str.startsWith("12D")) {
      return new Ed25519PeerIdImpl({ multihash });
    } else if (str.startsWith("16U")) {
      return new Secp256k1PeerIdImpl({ multihash });
    } else {
      return new RSAPeerIdImpl({ multihash });
    }
  }
  return peerIdFromBytes(baseDecoder.decode(str));
}
function peerIdFromBytes(buf2) {
  try {
    const multihash = decode53(buf2);
    if (multihash.code === identity10.code) {
      if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {
        return new Ed25519PeerIdImpl({ multihash });
      } else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {
        return new Secp256k1PeerIdImpl({ multihash });
      }
    }
    if (multihash.code === sha2567.code) {
      return new RSAPeerIdImpl({ multihash });
    }
  } catch {
    return peerIdFromCID(CID9.decode(buf2));
  }
  throw new Error("Supplied PeerID CID is invalid");
}
function peerIdFromCID(cid) {
  if (cid == null || cid.multihash == null || cid.version == null || cid.version === 1 && cid.code !== LIBP2P_KEY_CODE) {
    throw new Error("Supplied PeerID CID is invalid");
  }
  const multihash = cid.multihash;
  if (multihash.code === sha2567.code) {
    return new RSAPeerIdImpl({ multihash: cid.multihash });
  } else if (multihash.code === identity10.code) {
    if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {
      return new Ed25519PeerIdImpl({ multihash: cid.multihash });
    } else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {
      return new Secp256k1PeerIdImpl({ multihash: cid.multihash });
    }
  }
  throw new Error("Supplied PeerID CID is invalid");
}

// node_modules/ipfs-http-client/src/bitswap/stat.js
var createStat = configure((api) => {
  async function stat(options = {}) {
    const res = await api.post("bitswap/stat", {
      searchParams: toUrlSearchParams(options),
      signal: options.signal,
      headers: options.headers
    });
    return toCoreInterface(await res.json());
  }
  return stat;
});
function toCoreInterface(res) {
  return {
    provideBufLen: res.ProvideBufLen,
    wantlist: (res.Wantlist || []).map((k) => CID5.parse(k["/"])),
    peers: (res.Peers || []).map((str) => peerIdFromString(str)),
    blocksReceived: BigInt(res.BlocksReceived),
    dataReceived: BigInt(res.DataReceived),
    blocksSent: BigInt(res.BlocksSent),
    dataSent: BigInt(res.DataSent),
    dupBlksReceived: BigInt(res.DupBlksReceived),
    dupDataReceived: BigInt(res.DupDataReceived)
  };
}

// node_modules/ipfs-http-client/src/bitswap/unwant.js
var createUnwant = configure((api) => {
  async function unwant(cid, options = {}) {
    const res = await api.post("bitswap/unwant", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: cid.toString(),
        ...options
      }),
      headers: options.headers
    });
    return res.json();
  }
  return unwant;
});

// node_modules/ipfs-http-client/src/bitswap/index.js
function createBitswap(config) {
  return {
    wantlist: createWantlist(config),
    wantlistForPeer: createWantlistForPeer(config),
    unwant: createUnwant(config),
    stat: createStat(config)
  };
}

// node_modules/ipfs-http-client/src/block/get.js
var createGet = configure((api) => {
  async function get(cid, options = {}) {
    const res = await api.post("block/get", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: cid.toString(),
        ...options
      }),
      headers: options.headers
    });
    return new Uint8Array(await res.arrayBuffer());
  }
  return get;
});

// node_modules/ipfs-core-utils/src/files/normalise-content.browser.js
var import_err_code3 = __toESM(require_err_code(), 1);

// node_modules/it-peekable/dist/src/index.js
function peekableIterator(iterable) {
  const [iterator, symbol4] = iterable[Symbol.asyncIterator] != null ? [iterable[Symbol.asyncIterator](), Symbol.asyncIterator] : [iterable[Symbol.iterator](), Symbol.iterator];
  const queue = [];
  return {
    peek: () => {
      return iterator.next();
    },
    push: (value) => {
      queue.push(value);
    },
    next: () => {
      if (queue.length > 0) {
        return {
          done: false,
          value: queue.shift()
        };
      }
      return iterator.next();
    },
    [symbol4]() {
      return this;
    }
  };
}

// node_modules/browser-readablestream-to-it/dist/src/index.js
async function* browserReadableStreamToIt(stream, options = {}) {
  const reader = stream.getReader();
  try {
    while (true) {
      const result = await reader.read();
      if (result.done) {
        return;
      }
      yield result.value;
    }
  } finally {
    if (options.preventCancel !== true) {
      await reader.cancel();
    }
    reader.releaseLock();
  }
}

// node_modules/it-all/dist/src/index.js
async function all(source) {
  const arr = [];
  for await (const entry of source) {
    arr.push(entry);
  }
  return arr;
}

// node_modules/ipfs-core-utils/src/files/utils.js
function isBytes5(obj) {
  return ArrayBuffer.isView(obj) || obj instanceof ArrayBuffer;
}
function isBlob(obj) {
  return obj.constructor && (obj.constructor.name === "Blob" || obj.constructor.name === "File") && typeof obj.stream === "function";
}
function isFileObject(obj) {
  return typeof obj === "object" && (obj.path || obj.content);
}
var isReadableStream = (value) => value && typeof value.getReader === "function";

// node_modules/ipfs-core-utils/src/files/normalise-content.browser.js
async function normaliseContent(input) {
  if (isBytes5(input)) {
    return new Blob([input]);
  }
  if (typeof input === "string" || input instanceof String) {
    return new Blob([input.toString()]);
  }
  if (isBlob(input)) {
    return input;
  }
  if (isReadableStream(input)) {
    input = browserReadableStreamToIt(input);
  }
  if (Symbol.iterator in input || Symbol.asyncIterator in input) {
    const peekable = peekableIterator(input);
    const { value, done } = await peekable.peek();
    if (done) {
      return itToBlob(peekable);
    }
    peekable.push(value);
    if (Number.isInteger(value)) {
      return new Blob([Uint8Array.from(await all(peekable))]);
    }
    if (isBytes5(value) || typeof value === "string" || value instanceof String) {
      return itToBlob(peekable);
    }
  }
  throw (0, import_err_code3.default)(new Error(`Unexpected input: ${input}`), "ERR_UNEXPECTED_INPUT");
}
async function itToBlob(stream) {
  const parts = [];
  for await (const chunk of stream) {
    parts.push(chunk);
  }
  return new Blob(parts);
}

// node_modules/ipfs-core-utils/src/files/normalise-candidate-multiple.js
var import_err_code5 = __toESM(require_err_code(), 1);

// node_modules/it-map/dist/src/index.js
async function* map(source, func) {
  for await (const val of source) {
    yield func(val);
  }
}

// node_modules/ipfs-unixfs/src/index.js
var import_err_code4 = __toESM(require_err_code(), 1);

// node_modules/ipfs-unixfs/src/unixfs.js
var import_minimal = __toESM(require_minimal2(), 1);
var $Reader = import_minimal.default.Reader;
var $Writer = import_minimal.default.Writer;
var $util = import_minimal.default.util;
var $root = import_minimal.default.roots["ipfs-unixfs"] || (import_minimal.default.roots["ipfs-unixfs"] = {});
var Data = $root.Data = (() => {
  function Data2(p) {
    this.blocksizes = [];
    if (p) {
      for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
        if (p[ks[i]] != null)
          this[ks[i]] = p[ks[i]];
    }
  }
  Data2.prototype.Type = 0;
  Data2.prototype.Data = $util.newBuffer([]);
  Data2.prototype.filesize = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
  Data2.prototype.blocksizes = $util.emptyArray;
  Data2.prototype.hashType = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
  Data2.prototype.fanout = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
  Data2.prototype.mode = 0;
  Data2.prototype.mtime = null;
  Data2.encode = function encode42(m, w) {
    if (!w)
      w = $Writer.create();
    w.uint32(8).int32(m.Type);
    if (m.Data != null && Object.hasOwnProperty.call(m, "Data"))
      w.uint32(18).bytes(m.Data);
    if (m.filesize != null && Object.hasOwnProperty.call(m, "filesize"))
      w.uint32(24).uint64(m.filesize);
    if (m.blocksizes != null && m.blocksizes.length) {
      for (var i = 0; i < m.blocksizes.length; ++i)
        w.uint32(32).uint64(m.blocksizes[i]);
    }
    if (m.hashType != null && Object.hasOwnProperty.call(m, "hashType"))
      w.uint32(40).uint64(m.hashType);
    if (m.fanout != null && Object.hasOwnProperty.call(m, "fanout"))
      w.uint32(48).uint64(m.fanout);
    if (m.mode != null && Object.hasOwnProperty.call(m, "mode"))
      w.uint32(56).uint32(m.mode);
    if (m.mtime != null && Object.hasOwnProperty.call(m, "mtime"))
      $root.UnixTime.encode(m.mtime, w.uint32(66).fork()).ldelim();
    return w;
  };
  Data2.decode = function decode58(r, l) {
    if (!(r instanceof $Reader))
      r = $Reader.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root.Data();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          m.Type = r.int32();
          break;
        case 2:
          m.Data = r.bytes();
          break;
        case 3:
          m.filesize = r.uint64();
          break;
        case 4:
          if (!(m.blocksizes && m.blocksizes.length))
            m.blocksizes = [];
          if ((t & 7) === 2) {
            var c2 = r.uint32() + r.pos;
            while (r.pos < c2)
              m.blocksizes.push(r.uint64());
          } else
            m.blocksizes.push(r.uint64());
          break;
        case 5:
          m.hashType = r.uint64();
          break;
        case 6:
          m.fanout = r.uint64();
          break;
        case 7:
          m.mode = r.uint32();
          break;
        case 8:
          m.mtime = $root.UnixTime.decode(r, r.uint32());
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    if (!m.hasOwnProperty("Type"))
      throw $util.ProtocolError("missing required 'Type'", { instance: m });
    return m;
  };
  Data2.fromObject = function fromObject(d) {
    if (d instanceof $root.Data)
      return d;
    var m = new $root.Data();
    switch (d.Type) {
      case "Raw":
      case 0:
        m.Type = 0;
        break;
      case "Directory":
      case 1:
        m.Type = 1;
        break;
      case "File":
      case 2:
        m.Type = 2;
        break;
      case "Metadata":
      case 3:
        m.Type = 3;
        break;
      case "Symlink":
      case 4:
        m.Type = 4;
        break;
      case "HAMTShard":
      case 5:
        m.Type = 5;
        break;
    }
    if (d.Data != null) {
      if (typeof d.Data === "string")
        $util.base64.decode(d.Data, m.Data = $util.newBuffer($util.base64.length(d.Data)), 0);
      else if (d.Data.length)
        m.Data = d.Data;
    }
    if (d.filesize != null) {
      if ($util.Long)
        (m.filesize = $util.Long.fromValue(d.filesize)).unsigned = true;
      else if (typeof d.filesize === "string")
        m.filesize = parseInt(d.filesize, 10);
      else if (typeof d.filesize === "number")
        m.filesize = d.filesize;
      else if (typeof d.filesize === "object")
        m.filesize = new $util.LongBits(d.filesize.low >>> 0, d.filesize.high >>> 0).toNumber(true);
    }
    if (d.blocksizes) {
      if (!Array.isArray(d.blocksizes))
        throw TypeError(".Data.blocksizes: array expected");
      m.blocksizes = [];
      for (var i = 0; i < d.blocksizes.length; ++i) {
        if ($util.Long)
          (m.blocksizes[i] = $util.Long.fromValue(d.blocksizes[i])).unsigned = true;
        else if (typeof d.blocksizes[i] === "string")
          m.blocksizes[i] = parseInt(d.blocksizes[i], 10);
        else if (typeof d.blocksizes[i] === "number")
          m.blocksizes[i] = d.blocksizes[i];
        else if (typeof d.blocksizes[i] === "object")
          m.blocksizes[i] = new $util.LongBits(d.blocksizes[i].low >>> 0, d.blocksizes[i].high >>> 0).toNumber(true);
      }
    }
    if (d.hashType != null) {
      if ($util.Long)
        (m.hashType = $util.Long.fromValue(d.hashType)).unsigned = true;
      else if (typeof d.hashType === "string")
        m.hashType = parseInt(d.hashType, 10);
      else if (typeof d.hashType === "number")
        m.hashType = d.hashType;
      else if (typeof d.hashType === "object")
        m.hashType = new $util.LongBits(d.hashType.low >>> 0, d.hashType.high >>> 0).toNumber(true);
    }
    if (d.fanout != null) {
      if ($util.Long)
        (m.fanout = $util.Long.fromValue(d.fanout)).unsigned = true;
      else if (typeof d.fanout === "string")
        m.fanout = parseInt(d.fanout, 10);
      else if (typeof d.fanout === "number")
        m.fanout = d.fanout;
      else if (typeof d.fanout === "object")
        m.fanout = new $util.LongBits(d.fanout.low >>> 0, d.fanout.high >>> 0).toNumber(true);
    }
    if (d.mode != null) {
      m.mode = d.mode >>> 0;
    }
    if (d.mtime != null) {
      if (typeof d.mtime !== "object")
        throw TypeError(".Data.mtime: object expected");
      m.mtime = $root.UnixTime.fromObject(d.mtime);
    }
    return m;
  };
  Data2.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.arrays || o.defaults) {
      d.blocksizes = [];
    }
    if (o.defaults) {
      d.Type = o.enums === String ? "Raw" : 0;
      if (o.bytes === String)
        d.Data = "";
      else {
        d.Data = [];
        if (o.bytes !== Array)
          d.Data = $util.newBuffer(d.Data);
      }
      if ($util.Long) {
        var n = new $util.Long(0, 0, true);
        d.filesize = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
      } else
        d.filesize = o.longs === String ? "0" : 0;
      if ($util.Long) {
        var n = new $util.Long(0, 0, true);
        d.hashType = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
      } else
        d.hashType = o.longs === String ? "0" : 0;
      if ($util.Long) {
        var n = new $util.Long(0, 0, true);
        d.fanout = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
      } else
        d.fanout = o.longs === String ? "0" : 0;
      d.mode = 0;
      d.mtime = null;
    }
    if (m.Type != null && m.hasOwnProperty("Type")) {
      d.Type = o.enums === String ? $root.Data.DataType[m.Type] : m.Type;
    }
    if (m.Data != null && m.hasOwnProperty("Data")) {
      d.Data = o.bytes === String ? $util.base64.encode(m.Data, 0, m.Data.length) : o.bytes === Array ? Array.prototype.slice.call(m.Data) : m.Data;
    }
    if (m.filesize != null && m.hasOwnProperty("filesize")) {
      if (typeof m.filesize === "number")
        d.filesize = o.longs === String ? String(m.filesize) : m.filesize;
      else
        d.filesize = o.longs === String ? $util.Long.prototype.toString.call(m.filesize) : o.longs === Number ? new $util.LongBits(m.filesize.low >>> 0, m.filesize.high >>> 0).toNumber(true) : m.filesize;
    }
    if (m.blocksizes && m.blocksizes.length) {
      d.blocksizes = [];
      for (var j = 0; j < m.blocksizes.length; ++j) {
        if (typeof m.blocksizes[j] === "number")
          d.blocksizes[j] = o.longs === String ? String(m.blocksizes[j]) : m.blocksizes[j];
        else
          d.blocksizes[j] = o.longs === String ? $util.Long.prototype.toString.call(m.blocksizes[j]) : o.longs === Number ? new $util.LongBits(m.blocksizes[j].low >>> 0, m.blocksizes[j].high >>> 0).toNumber(true) : m.blocksizes[j];
      }
    }
    if (m.hashType != null && m.hasOwnProperty("hashType")) {
      if (typeof m.hashType === "number")
        d.hashType = o.longs === String ? String(m.hashType) : m.hashType;
      else
        d.hashType = o.longs === String ? $util.Long.prototype.toString.call(m.hashType) : o.longs === Number ? new $util.LongBits(m.hashType.low >>> 0, m.hashType.high >>> 0).toNumber(true) : m.hashType;
    }
    if (m.fanout != null && m.hasOwnProperty("fanout")) {
      if (typeof m.fanout === "number")
        d.fanout = o.longs === String ? String(m.fanout) : m.fanout;
      else
        d.fanout = o.longs === String ? $util.Long.prototype.toString.call(m.fanout) : o.longs === Number ? new $util.LongBits(m.fanout.low >>> 0, m.fanout.high >>> 0).toNumber(true) : m.fanout;
    }
    if (m.mode != null && m.hasOwnProperty("mode")) {
      d.mode = m.mode;
    }
    if (m.mtime != null && m.hasOwnProperty("mtime")) {
      d.mtime = $root.UnixTime.toObject(m.mtime, o);
    }
    return d;
  };
  Data2.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
  };
  Data2.DataType = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "Raw"] = 0;
    values[valuesById[1] = "Directory"] = 1;
    values[valuesById[2] = "File"] = 2;
    values[valuesById[3] = "Metadata"] = 3;
    values[valuesById[4] = "Symlink"] = 4;
    values[valuesById[5] = "HAMTShard"] = 5;
    return values;
  })();
  return Data2;
})();
var UnixTime = $root.UnixTime = (() => {
  function UnixTime2(p) {
    if (p) {
      for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
        if (p[ks[i]] != null)
          this[ks[i]] = p[ks[i]];
    }
  }
  UnixTime2.prototype.Seconds = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
  UnixTime2.prototype.FractionalNanoseconds = 0;
  UnixTime2.encode = function encode42(m, w) {
    if (!w)
      w = $Writer.create();
    w.uint32(8).int64(m.Seconds);
    if (m.FractionalNanoseconds != null && Object.hasOwnProperty.call(m, "FractionalNanoseconds"))
      w.uint32(21).fixed32(m.FractionalNanoseconds);
    return w;
  };
  UnixTime2.decode = function decode58(r, l) {
    if (!(r instanceof $Reader))
      r = $Reader.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root.UnixTime();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          m.Seconds = r.int64();
          break;
        case 2:
          m.FractionalNanoseconds = r.fixed32();
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    if (!m.hasOwnProperty("Seconds"))
      throw $util.ProtocolError("missing required 'Seconds'", { instance: m });
    return m;
  };
  UnixTime2.fromObject = function fromObject(d) {
    if (d instanceof $root.UnixTime)
      return d;
    var m = new $root.UnixTime();
    if (d.Seconds != null) {
      if ($util.Long)
        (m.Seconds = $util.Long.fromValue(d.Seconds)).unsigned = false;
      else if (typeof d.Seconds === "string")
        m.Seconds = parseInt(d.Seconds, 10);
      else if (typeof d.Seconds === "number")
        m.Seconds = d.Seconds;
      else if (typeof d.Seconds === "object")
        m.Seconds = new $util.LongBits(d.Seconds.low >>> 0, d.Seconds.high >>> 0).toNumber();
    }
    if (d.FractionalNanoseconds != null) {
      m.FractionalNanoseconds = d.FractionalNanoseconds >>> 0;
    }
    return m;
  };
  UnixTime2.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.defaults) {
      if ($util.Long) {
        var n = new $util.Long(0, 0, false);
        d.Seconds = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
      } else
        d.Seconds = o.longs === String ? "0" : 0;
      d.FractionalNanoseconds = 0;
    }
    if (m.Seconds != null && m.hasOwnProperty("Seconds")) {
      if (typeof m.Seconds === "number")
        d.Seconds = o.longs === String ? String(m.Seconds) : m.Seconds;
      else
        d.Seconds = o.longs === String ? $util.Long.prototype.toString.call(m.Seconds) : o.longs === Number ? new $util.LongBits(m.Seconds.low >>> 0, m.Seconds.high >>> 0).toNumber() : m.Seconds;
    }
    if (m.FractionalNanoseconds != null && m.hasOwnProperty("FractionalNanoseconds")) {
      d.FractionalNanoseconds = m.FractionalNanoseconds;
    }
    return d;
  };
  UnixTime2.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
  };
  return UnixTime2;
})();
var Metadata = $root.Metadata = (() => {
  function Metadata2(p) {
    if (p) {
      for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
        if (p[ks[i]] != null)
          this[ks[i]] = p[ks[i]];
    }
  }
  Metadata2.prototype.MimeType = "";
  Metadata2.encode = function encode42(m, w) {
    if (!w)
      w = $Writer.create();
    if (m.MimeType != null && Object.hasOwnProperty.call(m, "MimeType"))
      w.uint32(10).string(m.MimeType);
    return w;
  };
  Metadata2.decode = function decode58(r, l) {
    if (!(r instanceof $Reader))
      r = $Reader.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root.Metadata();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          m.MimeType = r.string();
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  Metadata2.fromObject = function fromObject(d) {
    if (d instanceof $root.Metadata)
      return d;
    var m = new $root.Metadata();
    if (d.MimeType != null) {
      m.MimeType = String(d.MimeType);
    }
    return m;
  };
  Metadata2.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.defaults) {
      d.MimeType = "";
    }
    if (m.MimeType != null && m.hasOwnProperty("MimeType")) {
      d.MimeType = m.MimeType;
    }
    return d;
  };
  Metadata2.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
  };
  return Metadata2;
})();

// node_modules/ipfs-unixfs/src/index.js
var DEFAULT_FILE_MODE = parseInt("0644", 8);
var DEFAULT_DIRECTORY_MODE = parseInt("0755", 8);
function parseMode(mode) {
  if (mode == null) {
    return void 0;
  }
  if (typeof mode === "number") {
    return mode & 4095;
  }
  mode = mode.toString();
  if (mode.substring(0, 1) === "0") {
    return parseInt(mode, 8) & 4095;
  }
  return parseInt(mode, 10) & 4095;
}
function parseMtime2(input) {
  if (input == null) {
    return void 0;
  }
  let mtime;
  if (input.secs != null) {
    mtime = {
      secs: input.secs,
      nsecs: input.nsecs
    };
  }
  if (input.Seconds != null) {
    mtime = {
      secs: input.Seconds,
      nsecs: input.FractionalNanoseconds
    };
  }
  if (Array.isArray(input)) {
    mtime = {
      secs: input[0],
      nsecs: input[1]
    };
  }
  if (input instanceof Date) {
    const ms = input.getTime();
    const secs = Math.floor(ms / 1e3);
    mtime = {
      secs,
      nsecs: (ms - secs * 1e3) * 1e3
    };
  }
  if (!Object.prototype.hasOwnProperty.call(mtime, "secs")) {
    return void 0;
  }
  if (mtime != null && mtime.nsecs != null && (mtime.nsecs < 0 || mtime.nsecs > 999999999)) {
    throw (0, import_err_code4.default)(new Error("mtime-nsecs must be within the range [0,999999999]"), "ERR_INVALID_MTIME_NSECS");
  }
  return mtime;
}

// node_modules/ipfs-core-utils/src/files/normalise-candidate-multiple.js
async function* normaliseCandidateMultiple(input, normaliseContent3) {
  if (typeof input === "string" || input instanceof String || isBytes5(input) || isBlob(input) || input._readableState) {
    throw (0, import_err_code5.default)(new Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"), "ERR_UNEXPECTED_INPUT");
  }
  if (isReadableStream(input)) {
    input = browserReadableStreamToIt(input);
  }
  if (Symbol.iterator in input || Symbol.asyncIterator in input) {
    const peekable = peekableIterator(input);
    const { value, done } = await peekable.peek();
    if (done) {
      yield* [];
      return;
    }
    peekable.push(value);
    if (Number.isInteger(value)) {
      throw (0, import_err_code5.default)(new Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"), "ERR_UNEXPECTED_INPUT");
    }
    if (value._readableState) {
      yield* map(peekable, (value2) => toFileObject({ content: value2 }, normaliseContent3));
      return;
    }
    if (isBytes5(value)) {
      yield toFileObject({ content: peekable }, normaliseContent3);
      return;
    }
    if (isFileObject(value) || value[Symbol.iterator] || value[Symbol.asyncIterator] || isReadableStream(value) || isBlob(value)) {
      yield* map(peekable, (value2) => toFileObject(value2, normaliseContent3));
      return;
    }
  }
  if (isFileObject(input)) {
    throw (0, import_err_code5.default)(new Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"), "ERR_UNEXPECTED_INPUT");
  }
  throw (0, import_err_code5.default)(new Error("Unexpected input: " + typeof input), "ERR_UNEXPECTED_INPUT");
}
async function toFileObject(input, normaliseContent3) {
  const { path, mode, mtime, content } = input;
  const file = {
    path: path || "",
    mode: parseMode(mode),
    mtime: parseMtime2(mtime)
  };
  if (content) {
    file.content = await normaliseContent3(content);
  } else if (!path) {
    file.content = await normaliseContent3(input);
  }
  return file;
}

// node_modules/ipfs-core-utils/src/files/normalise-input-multiple.browser.js
function normaliseInput(input) {
  return normaliseCandidateMultiple(input, normaliseContent, true);
}

// node_modules/ipfs-core-utils/src/mode-to-string.js
function modeToString2(mode) {
  if (mode == null) {
    return void 0;
  }
  if (typeof mode === "string") {
    return mode;
  }
  return mode.toString(8).padStart(4, "0");
}

// node_modules/ipfs-core-utils/src/multipart-request.browser.js
async function multipartRequest(source, abortController, headers = {}) {
  const parts = [];
  const formData = new FormData();
  let index = 0;
  let total = 0;
  for await (const { content, path, mode, mtime } of normaliseInput(source)) {
    let fileSuffix = "";
    const type = content ? "file" : "dir";
    if (index > 0) {
      fileSuffix = `-${index}`;
    }
    let fieldName = type + fileSuffix;
    const qs = [];
    if (mode !== null && mode !== void 0) {
      qs.push(`mode=${modeToString2(mode)}`);
    }
    if (mtime != null) {
      const { secs, nsecs } = mtime;
      qs.push(`mtime=${secs}`);
      if (nsecs != null) {
        qs.push(`mtime-nsecs=${nsecs}`);
      }
    }
    if (qs.length) {
      fieldName = `${fieldName}?${qs.join("&")}`;
    }
    if (content) {
      formData.set(fieldName, content, path != null ? encodeURIComponent(path) : void 0);
      const end = total + content.size;
      parts.push({ name: path, start: total, end });
      total = end;
    } else if (path != null) {
      formData.set(fieldName, new File([""], encodeURIComponent(path), { type: "application/x-directory" }));
    } else {
      throw new Error("path or content or both must be set");
    }
    index++;
  }
  return {
    total,
    parts,
    headers,
    body: formData
  };
}

// node_modules/ipfs-http-client/src/lib/abort-signal.js
var import_any_signal = __toESM(require_any_signal(), 1);
function filter(signals) {
  return signals.filter(Boolean);
}
function abortSignal(...signals) {
  return (0, import_any_signal.anySignal)(filter(signals));
}

// node_modules/ipfs-http-client/src/block/put.js
var createPut = configure((api) => {
  async function put(data, options = {}) {
    const controller = new AbortController();
    const signal = abortSignal(controller.signal, options.signal);
    let res;
    try {
      const response = await api.post("block/put", {
        signal,
        searchParams: toUrlSearchParams(options),
        ...await multipartRequest([data], controller, options.headers)
      });
      res = await response.json();
    } catch (err) {
      if (options.format === "dag-pb") {
        return put(data, { ...options, format: "protobuf" });
      } else if (options.format === "dag-cbor") {
        return put(data, { ...options, format: "cbor" });
      }
      throw err;
    }
    return CID5.parse(res.Key);
  }
  return put;
});

// node_modules/ipfs-http-client/src/block/rm.js
var createRm = configure((api) => {
  async function* rm(cid, options = {}) {
    if (!Array.isArray(cid)) {
      cid = [cid];
    }
    const res = await api.post("block/rm", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: cid.map((cid2) => cid2.toString()),
        "stream-channels": true,
        ...options
      }),
      headers: options.headers
    });
    for await (const removed of res.ndjson()) {
      yield toCoreInterface2(removed);
    }
  }
  return rm;
});
function toCoreInterface2(removed) {
  const out = {
    cid: CID5.parse(removed.Hash)
  };
  if (removed.Error) {
    out.error = new Error(removed.Error);
  }
  return out;
}

// node_modules/ipfs-http-client/src/block/stat.js
var createStat2 = configure((api) => {
  async function stat(cid, options = {}) {
    const res = await api.post("block/stat", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: cid.toString(),
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return { cid: CID5.parse(data.Key), size: data.Size };
  }
  return stat;
});

// node_modules/ipfs-http-client/src/block/index.js
function createBlock(config) {
  return {
    get: createGet(config),
    put: createPut(config),
    rm: createRm(config),
    stat: createStat2(config)
  };
}

// node_modules/ipfs-http-client/src/bootstrap/add.js
var createAdd = configure((api) => {
  async function add2(addr, options = {}) {
    const res = await api.post("bootstrap/add", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: addr,
        ...options
      }),
      headers: options.headers
    });
    const { Peers } = await res.json();
    return { Peers: Peers.map((ma) => multiaddr(ma)) };
  }
  return add2;
});

// node_modules/ipfs-http-client/src/bootstrap/clear.js
var createClear = configure((api) => {
  async function clear(options = {}) {
    const res = await api.post("bootstrap/rm", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        ...options,
        all: true
      }),
      headers: options.headers
    });
    const { Peers } = await res.json();
    return { Peers: Peers.map((ma) => multiaddr(ma)) };
  }
  return clear;
});

// node_modules/ipfs-http-client/src/bootstrap/list.js
var createList = configure((api) => {
  async function list(options = {}) {
    const res = await api.post("bootstrap/list", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    const { Peers } = await res.json();
    return { Peers: Peers.map((ma) => multiaddr(ma)) };
  }
  return list;
});

// node_modules/ipfs-http-client/src/bootstrap/reset.js
var createReset = configure((api) => {
  async function reset(options = {}) {
    const res = await api.post("bootstrap/add", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        ...options,
        default: true
      }),
      headers: options.headers
    });
    const { Peers } = await res.json();
    return { Peers: Peers.map((ma) => multiaddr(ma)) };
  }
  return reset;
});

// node_modules/ipfs-http-client/src/bootstrap/rm.js
var createRm2 = configure((api) => {
  async function rm(addr, options = {}) {
    const res = await api.post("bootstrap/rm", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: addr,
        ...options
      }),
      headers: options.headers
    });
    const { Peers } = await res.json();
    return { Peers: Peers.map((ma) => multiaddr(ma)) };
  }
  return rm;
});

// node_modules/ipfs-http-client/src/bootstrap/index.js
function createBootstrap(config) {
  return {
    add: createAdd(config),
    clear: createClear(config),
    list: createList(config),
    reset: createReset(config),
    rm: createRm2(config)
  };
}

// node_modules/ipfs-http-client/src/config/profiles/apply.js
var createApply = configure((api) => {
  async function apply(profile, options = {}) {
    const res = await api.post("config/profile/apply", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: profile,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return {
      original: data.OldCfg,
      updated: data.NewCfg
    };
  }
  return apply;
});

// node_modules/ipfs-http-client/src/lib/object-to-camel.js
function objectToCamel(obj) {
  if (obj == null) {
    return obj;
  }
  const caps = /^[A-Z]+$/;
  const output = {};
  return Object.keys(obj).reduce((camelObj, k) => {
    if (caps.test(k)) {
      camelObj[k.toLowerCase()] = obj[k];
    } else if (caps.test(k[0])) {
      camelObj[k[0].toLowerCase() + k.slice(1)] = obj[k];
    } else {
      camelObj[k] = obj[k];
    }
    return camelObj;
  }, output);
}

// node_modules/ipfs-http-client/src/config/profiles/list.js
var createList2 = configure((api) => {
  async function list(options = {}) {
    const res = await api.post("config/profile/list", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    const data = await res.json();
    return data.map((profile) => objectToCamel(profile));
  }
  return list;
});

// node_modules/ipfs-http-client/src/config/profiles/index.js
function createProfiles(config) {
  return {
    apply: createApply(config),
    list: createList2(config)
  };
}

// node_modules/ipfs-http-client/src/config/get.js
var createGet2 = configure((api) => {
  const get = async (key, options = {}) => {
    if (!key) {
      throw new Error("key argument is required");
    }
    const res = await api.post("config", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: key,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return data.Value;
  };
  return get;
});

// node_modules/ipfs-http-client/src/config/get-all.js
var createGetAll = configure((api) => {
  const getAll = async (options = {}) => {
    const res = await api.post("config/show", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return data;
  };
  return getAll;
});

// node_modules/ipfs-http-client/src/config/replace.js
var createReplace = configure((api) => {
  const replace = async (config, options = {}) => {
    const controller = new AbortController();
    const signal = abortSignal(controller.signal, options.signal);
    const res = await api.post("config/replace", {
      signal,
      searchParams: toUrlSearchParams(options),
      ...await multipartRequest([fromString5(JSON.stringify(config))], controller, options.headers)
    });
    await res.text();
  };
  return replace;
});

// node_modules/ipfs-http-client/src/config/set.js
var createSet = configure((api) => {
  const set = async (key, value, options = {}) => {
    if (typeof key !== "string") {
      throw new Error("Invalid key type");
    }
    const params = {
      ...options,
      ...encodeParam(key, value)
    };
    const res = await api.post("config", {
      signal: options.signal,
      searchParams: toUrlSearchParams(params),
      headers: options.headers
    });
    await res.text();
  };
  return set;
});
var encodeParam = (key, value) => {
  switch (typeof value) {
    case "boolean":
      return { arg: [key, value.toString()], bool: true };
    case "string":
      return { arg: [key, value] };
    default:
      return { arg: [key, JSON.stringify(value)], json: true };
  }
};

// node_modules/ipfs-http-client/src/config/index.js
function createConfig(config) {
  return {
    getAll: createGetAll(config),
    get: createGet2(config),
    set: createSet(config),
    replace: createReplace(config),
    profiles: createProfiles(config)
  };
}

// node_modules/ipfs-http-client/src/dag/export.js
var createExport = configure((api) => {
  async function* dagExport(root, options = {}) {
    const res = await api.post("dag/export", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: root.toString()
      }),
      headers: options.headers
    });
    yield* res.iterator();
  }
  return dagExport;
});

// node_modules/ipfs-http-client/src/lib/resolve.js
var import_err_code6 = __toESM(require_err_code(), 1);
async function* resolve(cid, path, codecs3, getBlock, options) {
  const load = async (cid2) => {
    const codec = await codecs3.getCodec(cid2.code);
    const block = await getBlock(cid2, options);
    return codec.decode(block);
  };
  const parts = path.split("/").filter(Boolean);
  let value = await load(cid);
  let lastCid = cid;
  while (parts.length) {
    const key = parts.shift();
    if (!key) {
      throw (0, import_err_code6.default)(new Error(`Could not resolve path "${path}"`), "ERR_INVALID_PATH");
    }
    if (Object.prototype.hasOwnProperty.call(value, key)) {
      value = value[key];
      yield {
        value,
        remainderPath: parts.join("/")
      };
    } else {
      throw (0, import_err_code6.default)(new Error(`no link named "${key}" under ${lastCid}`), "ERR_NO_LINK");
    }
    const cid2 = CID5.asCID(value);
    if (cid2) {
      lastCid = cid2;
      value = await load(value);
    }
  }
  yield {
    value,
    remainderPath: ""
  };
}

// node_modules/it-first/dist/src/index.js
async function first(source) {
  for await (const entry of source) {
    return entry;
  }
  return void 0;
}

// node_modules/it-last/dist/src/index.js
async function last(source) {
  let res;
  for await (const entry of source) {
    res = entry;
  }
  return res;
}

// node_modules/ipfs-http-client/src/dag/get.js
var import_err_code7 = __toESM(require_err_code(), 1);
var createGet3 = (codecs3, options) => {
  const fn = configure((api, opts) => {
    const getBlock = createGet(opts);
    const get = async (cid, options2 = {}) => {
      if (options2.path) {
        const entry = options2.localResolve ? await first(resolve(cid, options2.path, codecs3, getBlock, options2)) : await last(resolve(cid, options2.path, codecs3, getBlock, options2));
        const result = entry;
        if (!result) {
          throw (0, import_err_code7.default)(new Error("Not found"), "ERR_NOT_FOUND");
        }
        return result;
      }
      const codec = await codecs3.getCodec(cid.code);
      const block = await getBlock(cid, options2);
      const node = codec.decode(block);
      return {
        value: node,
        remainderPath: ""
      };
    };
    return get;
  });
  return fn(options);
};

// node_modules/ipfs-http-client/src/dag/import.js
var createImport = configure((api) => {
  async function* dagImport(source, options = {}) {
    const controller = new AbortController();
    const signal = abortSignal(controller.signal, options.signal);
    const { headers, body } = await multipartRequest(source, controller, options.headers);
    const res = await api.post("dag/import", {
      signal,
      headers,
      body,
      searchParams: toUrlSearchParams({ "pin-roots": options.pinRoots })
    });
    for await (const { Root } of res.ndjson()) {
      if (Root !== void 0) {
        const { Cid: { "/": Cid }, PinErrorMsg } = Root;
        yield {
          root: {
            cid: CID5.parse(Cid),
            pinErrorMsg: PinErrorMsg
          }
        };
      }
    }
  }
  return dagImport;
});

// node_modules/ipfs-http-client/src/dag/put.js
var createPut2 = (codecs3, options) => {
  const fn = configure((api) => {
    const put = async (dagNode, options2 = {}) => {
      const settings = {
        storeCodec: "dag-cbor",
        hashAlg: "sha2-256",
        ...options2
      };
      let serialized;
      if (settings.inputCodec) {
        if (!(dagNode instanceof Uint8Array)) {
          throw new Error("Can only inputCodec on raw bytes that can be decoded");
        }
        serialized = dagNode;
      } else {
        const storeCodec = await codecs3.getCodec(settings.storeCodec);
        serialized = storeCodec.encode(dagNode);
        settings.inputCodec = settings.storeCodec;
      }
      const controller = new AbortController();
      const signal = abortSignal(controller.signal, settings.signal);
      const res = await api.post("dag/put", {
        timeout: settings.timeout,
        signal,
        searchParams: toUrlSearchParams(settings),
        ...await multipartRequest([serialized], controller, settings.headers)
      });
      const data = await res.json();
      return CID5.parse(data.Cid["/"]);
    };
    return put;
  });
  return fn(options);
};

// node_modules/ipfs-http-client/src/dag/resolve.js
var createResolve = configure((api) => {
  const resolve2 = async (ipfsPath, options = {}) => {
    const res = await api.post("dag/resolve", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: `${ipfsPath}${options.path ? `/${options.path}`.replace(/\/[/]+/g, "/") : ""}`,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return { cid: CID5.parse(data.Cid["/"]), remainderPath: data.RemPath };
  };
  return resolve2;
});

// node_modules/ipfs-http-client/src/dag/index.js
function createDag(codecs3, config) {
  return {
    export: createExport(config),
    get: createGet3(codecs3, config),
    import: createImport(config),
    put: createPut2(codecs3, config),
    resolve: createResolve(config)
  };
}

// node_modules/ipfs-http-client/src/dht/response-types.js
var SendingQuery = 0;
var PeerResponse = 1;
var FinalPeer = 2;
var QueryError = 3;
var Provider = 4;
var Value = 5;
var AddingPeer = 6;
var DialingPeer = 7;

// node_modules/ipfs-http-client/src/dht/map-event.js
var mapEvent = (event) => {
  if (event.Type === SendingQuery) {
    return {
      name: "SENDING_QUERY",
      type: event.Type
    };
  }
  if (event.Type === PeerResponse) {
    return {
      from: peerIdFromString(event.ID),
      name: "PEER_RESPONSE",
      type: event.Type,
      // TODO: how to infer this from the go-ipfs response
      messageType: 0,
      // TODO: how to infer this from the go-ipfs response
      messageName: "PUT_VALUE",
      closer: (event.Responses || []).map(({ ID, Addrs }) => ({ id: peerIdFromString(ID), multiaddrs: Addrs.map((addr) => multiaddr(addr)), protocols: [] })),
      providers: (event.Responses || []).map(({ ID, Addrs }) => ({ id: peerIdFromString(ID), multiaddrs: Addrs.map((addr) => multiaddr(addr)), protocols: [] }))
      // TODO: how to infer this from the go-ipfs response
      // record: ???
    };
  }
  if (event.Type === FinalPeer) {
    let peer = {
      // @ts-expect-error go-ipfs does not return this
      id: event.ID ?? peerIdFromString(event.ID),
      /** @type {Multiaddr[]} */
      multiaddrs: [],
      protocols: []
    };
    if (event.Responses && event.Responses.length) {
      peer = {
        id: peerIdFromString(event.Responses[0].ID),
        multiaddrs: event.Responses[0].Addrs.map((addr) => multiaddr(addr)),
        protocols: []
      };
    }
    return {
      name: "FINAL_PEER",
      type: event.Type,
      peer
    };
  }
  if (event.Type === QueryError) {
    return {
      name: "QUERY_ERROR",
      type: event.Type,
      error: new Error(event.Extra)
    };
  }
  if (event.Type === Provider) {
    return {
      name: "PROVIDER",
      type: event.Type,
      providers: event.Responses.map(({ ID, Addrs }) => ({ id: peerIdFromString(ID), multiaddrs: Addrs.map((addr) => multiaddr(addr)), protocols: [] }))
    };
  }
  if (event.Type === Value) {
    return {
      name: "VALUE",
      type: event.Type,
      value: fromString5(event.Extra, "base64pad")
    };
  }
  if (event.Type === AddingPeer) {
    const peers = event.Responses.map(({ ID }) => peerIdFromString(ID));
    if (!peers.length) {
      throw new Error("No peer found");
    }
    return {
      name: "ADDING_PEER",
      type: event.Type,
      peer: peers[0]
    };
  }
  if (event.Type === DialingPeer) {
    return {
      name: "DIALING_PEER",
      type: event.Type,
      peer: peerIdFromString(event.ID)
    };
  }
  throw new Error("Unknown DHT event type");
};

// node_modules/ipfs-http-client/src/dht/find-peer.js
var createFindPeer = configure((api) => {
  async function* findPeer(peerId, options = {}) {
    const res = await api.post("dht/findpeer", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: peerId,
        ...options
      }),
      headers: options.headers
    });
    for await (const event of res.ndjson()) {
      yield mapEvent(event);
    }
  }
  return findPeer;
});

// node_modules/ipfs-http-client/src/dht/find-provs.js
var createFindProvs = configure((api) => {
  async function* findProvs(cid, options = {}) {
    const res = await api.post("dht/findprovs", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: cid.toString(),
        ...options
      }),
      headers: options.headers
    });
    for await (const event of res.ndjson()) {
      yield mapEvent(event);
    }
  }
  return findProvs;
});

// node_modules/ipfs-http-client/src/dht/get.js
var createGet4 = configure((api) => {
  async function* get(key, options = {}) {
    const res = await api.post("dht/get", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        // arg: base36.encode(key),
        arg: key instanceof Uint8Array ? toString4(key) : key.toString(),
        ...options
      }),
      headers: options.headers
    });
    for await (const event of res.ndjson()) {
      yield mapEvent(event);
    }
  }
  return get;
});

// node_modules/ipfs-http-client/src/dht/provide.js
var createProvide = configure((api) => {
  async function* provide(cids, options = { recursive: false }) {
    const cidArr = Array.isArray(cids) ? cids : [cids];
    const res = await api.post("dht/provide", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: cidArr.map((cid) => cid.toString()),
        ...options
      }),
      headers: options.headers
    });
    for await (const event of res.ndjson()) {
      yield mapEvent(event);
    }
  }
  return provide;
});

// node_modules/ipfs-http-client/src/dht/put.js
var createPut3 = configure((api) => {
  async function* put(key, value, options = {}) {
    const controller = new AbortController();
    const signal = abortSignal(controller.signal, options.signal);
    const res = await api.post("dht/put", {
      signal,
      searchParams: toUrlSearchParams({
        arg: key instanceof Uint8Array ? toString4(key) : key.toString(),
        ...options
      }),
      ...await multipartRequest([value], controller, options.headers)
    });
    for await (const event of res.ndjson()) {
      yield mapEvent(event);
    }
  }
  return put;
});

// node_modules/ipfs-http-client/src/dht/query.js
var createQuery = configure((api) => {
  async function* query(peerId, options = {}) {
    const res = await api.post("dht/query", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: peerId.toString(),
        ...options
      }),
      headers: options.headers
    });
    for await (const event of res.ndjson()) {
      yield mapEvent(event);
    }
  }
  return query;
});

// node_modules/ipfs-http-client/src/dht/index.js
function createDht(config) {
  return {
    findPeer: createFindPeer(config),
    findProvs: createFindProvs(config),
    get: createGet4(config),
    provide: createProvide(config),
    put: createPut3(config),
    query: createQuery(config)
  };
}

// node_modules/ipfs-http-client/src/diag/cmds.js
var createCmds = configure((api) => {
  async function cmds(options = {}) {
    const res = await api.post("diag/cmds", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    return res.json();
  }
  return cmds;
});

// node_modules/ipfs-http-client/src/diag/net.js
var createNet = configure((api) => {
  async function net(options = {}) {
    const res = await api.post("diag/net", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    return res.json();
  }
  return net;
});

// node_modules/ipfs-http-client/src/diag/sys.js
var createSys = configure((api) => {
  async function sys(options = {}) {
    const res = await api.post("diag/sys", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    return res.json();
  }
  return sys;
});

// node_modules/ipfs-http-client/src/diag/index.js
function createDiag(config) {
  return {
    cmds: createCmds(config),
    net: createNet(config),
    sys: createSys(config)
  };
}

// node_modules/ipfs-http-client/src/files/chmod.js
var createChmod = configure((api) => {
  async function chmod(path, mode, options = {}) {
    const res = await api.post("files/chmod", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path,
        mode,
        ...options
      }),
      headers: options.headers
    });
    await res.text();
  }
  return chmod;
});

// node_modules/ipfs-http-client/src/files/cp.js
var createCp = configure((api) => {
  async function cp(sources, destination, options = {}) {
    const sourceArr = Array.isArray(sources) ? sources : [sources];
    const res = await api.post("files/cp", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: sourceArr.concat(destination).map((src12) => CID5.asCID(src12) ? `/ipfs/${src12}` : src12),
        ...options
      }),
      headers: options.headers
    });
    await res.text();
  }
  return cp;
});

// node_modules/ipfs-http-client/src/files/flush.js
var createFlush = configure((api) => {
  async function flush(path, options = {}) {
    if (!path || typeof path !== "string") {
      throw new Error("ipfs.files.flush requires a path");
    }
    const res = await api.post("files/flush", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return CID5.parse(data.Cid);
  }
  return flush;
});

// node_modules/ipfs-http-client/src/lib/object-to-camel-with-metadata.js
function objectToCamelWithMetadata(entry) {
  const file = objectToCamel(entry);
  if (Object.prototype.hasOwnProperty.call(file, "mode")) {
    file.mode = parseInt(file.mode, 8);
  }
  if (Object.prototype.hasOwnProperty.call(file, "mtime")) {
    file.mtime = {
      secs: file.mtime,
      nsecs: file.mtimeNsecs || 0
    };
    delete file.mtimeNsecs;
  }
  return file;
}

// node_modules/ipfs-http-client/src/files/ls.js
var createLs = configure((api) => {
  async function* ls(path, options = {}) {
    if (!path) {
      throw new Error("ipfs.files.ls requires a path");
    }
    const res = await api.post("files/ls", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: CID5.asCID(path) ? `/ipfs/${path}` : path,
        // default long to true, diverges from go-ipfs where its false by default
        long: true,
        ...options,
        stream: true
      }),
      headers: options.headers
    });
    for await (const result of res.ndjson()) {
      if ("Entries" in result) {
        for (const entry of result.Entries || []) {
          yield toCoreInterface3(objectToCamelWithMetadata(entry));
        }
      } else {
        yield toCoreInterface3(objectToCamelWithMetadata(result));
      }
    }
  }
  return ls;
});
function toCoreInterface3(entry) {
  if (entry.hash) {
    entry.cid = CID5.parse(entry.hash);
  }
  delete entry.hash;
  entry.type = entry.type === 1 ? "directory" : "file";
  return entry;
}

// node_modules/ipfs-http-client/src/files/mkdir.js
var createMkdir = configure((api) => {
  async function mkdir(path, options = {}) {
    const res = await api.post("files/mkdir", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path,
        ...options
      }),
      headers: options.headers
    });
    await res.text();
  }
  return mkdir;
});

// node_modules/ipfs-http-client/src/files/mv.js
var createMv = configure((api) => {
  async function mv(sources, destination, options = {}) {
    if (!Array.isArray(sources)) {
      sources = [sources];
    }
    const res = await api.post("files/mv", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: sources.concat(destination),
        ...options
      }),
      headers: options.headers
    });
    await res.text();
  }
  return mv;
});

// node_modules/ipfs-http-client/src/files/read.js
var import_source = __toESM(require_source(), 1);
var createRead = configure((api) => {
  async function* read11(path, options = {}) {
    const res = await api.post("files/read", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path,
        count: options.length,
        ...options
      }),
      headers: options.headers
    });
    yield* (0, import_source.default)(res.body);
  }
  return read11;
});

// node_modules/ipfs-http-client/src/files/rm.js
var import_http2 = __toESM(require_http(), 1);
var createRm3 = configure((api) => {
  async function rm(path, options = {}) {
    const res = await api.post("files/rm", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path,
        ...options
      }),
      headers: options.headers
    });
    const body = await res.text();
    if (body !== "") {
      const error = new import_http2.default.HTTPError(res);
      error.message = body;
      throw error;
    }
  }
  return rm;
});

// node_modules/ipfs-http-client/src/files/stat.js
var createStat3 = configure((api) => {
  async function stat(path, options = {}) {
    const res = await api.post("files/stat", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    data.WithLocality = data.WithLocality || false;
    return toCoreInterface4(objectToCamelWithMetadata(data));
  }
  return stat;
});
function toCoreInterface4(entry) {
  entry.cid = CID5.parse(entry.hash);
  delete entry.hash;
  return entry;
}

// node_modules/ipfs-http-client/src/files/touch.js
var createTouch = configure((api) => {
  async function touch(path, options = {}) {
    const res = await api.post("files/touch", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path,
        ...options
      }),
      headers: options.headers
    });
    await res.text();
  }
  return touch;
});

// node_modules/ipfs-http-client/src/files/write.js
var createWrite = configure((api) => {
  async function write(path, input, options = {}) {
    const controller = new AbortController();
    const signal = abortSignal(controller.signal, options.signal);
    const res = await api.post("files/write", {
      signal,
      searchParams: toUrlSearchParams({
        arg: path,
        streamChannels: true,
        count: options.length,
        ...options
      }),
      ...await multipartRequest([{
        content: input,
        path: "arg",
        mode: modeToString(options.mode),
        mtime: parseMtime(options.mtime)
      }], controller, options.headers)
    });
    await res.text();
  }
  return write;
});

// node_modules/ipfs-http-client/src/files/index.js
function createFiles(config) {
  return {
    chmod: createChmod(config),
    cp: createCp(config),
    flush: createFlush(config),
    ls: createLs(config),
    mkdir: createMkdir(config),
    mv: createMv(config),
    read: createRead(config),
    rm: createRm3(config),
    stat: createStat3(config),
    touch: createTouch(config),
    write: createWrite(config)
  };
}

// node_modules/ipfs-http-client/src/key/export.js
var import_err_code8 = __toESM(require_err_code(), 1);
var createExport2 = configure((api) => {
  const exportKey = async (name12, password, options = {}) => {
    throw (0, import_err_code8.default)(new Error("Not implemented"), "ERR_NOT_IMPLEMENTED");
  };
  return exportKey;
});

// node_modules/ipfs-http-client/src/key/gen.js
var createGen = configure((api) => {
  async function gen2(name12, options) {
    const opts = options ?? { type: "Ed25519" };
    const res = await api.post("key/gen", {
      signal: opts.signal,
      searchParams: toUrlSearchParams({
        arg: name12,
        ...opts
      }),
      headers: opts.headers
    });
    const data = await res.json();
    return objectToCamel(data);
  }
  return gen2;
});

// node_modules/ipfs-http-client/src/key/import.js
var createImport2 = configure((api) => {
  async function importKey(name12, pem, password, options = {}) {
    const res = await api.post("key/import", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: name12,
        pem,
        password,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return objectToCamel(data);
  }
  return importKey;
});

// node_modules/ipfs-http-client/src/key/info.js
var import_err_code9 = __toESM(require_err_code(), 1);
var createInfo = configure((api) => {
  const info = async (name12, options = {}) => {
    throw (0, import_err_code9.default)(new Error("Not implemented"), "ERR_NOT_IMPLEMENTED");
  };
  return info;
});

// node_modules/ipfs-http-client/src/key/list.js
var createList3 = configure((api) => {
  async function list(options = {}) {
    const res = await api.post("key/list", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    const data = await res.json();
    return (data.Keys || []).map((k) => objectToCamel(k));
  }
  return list;
});

// node_modules/ipfs-http-client/src/key/rename.js
var createRename = configure((api) => {
  async function rename(oldName, newName, options = {}) {
    const res = await api.post("key/rename", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: [
          oldName,
          newName
        ],
        ...options
      }),
      headers: options.headers
    });
    return objectToCamel(await res.json());
  }
  return rename;
});

// node_modules/ipfs-http-client/src/key/rm.js
var createRm4 = configure((api) => {
  async function rm(name12, options = {}) {
    const res = await api.post("key/rm", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: name12,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return objectToCamel(data.Keys[0]);
  }
  return rm;
});

// node_modules/ipfs-http-client/src/key/index.js
function createKey(config) {
  return {
    export: createExport2(config),
    gen: createGen(config),
    import: createImport2(config),
    info: createInfo(config),
    list: createList3(config),
    rename: createRename(config),
    rm: createRm4(config)
  };
}

// node_modules/ipfs-http-client/src/log/level.js
var createLevel = configure((api) => {
  async function level(subsystem, level2, options = {}) {
    const res = await api.post("log/level", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: [
          subsystem,
          level2
        ],
        ...options
      }),
      headers: options.headers
    });
    return objectToCamel(await res.json());
  }
  return level;
});

// node_modules/ipfs-http-client/src/log/ls.js
var createLs2 = configure((api) => {
  async function ls(options = {}) {
    const res = await api.post("log/ls", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    const data = await res.json();
    return data.Strings;
  }
  return ls;
});

// node_modules/ipfs-http-client/src/log/tail.js
var createTail = configure((api) => {
  async function* tail(options = {}) {
    const res = await api.post("log/tail", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    yield* res.ndjson();
  }
  return tail;
});

// node_modules/ipfs-http-client/src/log/index.js
function createLog(config) {
  return {
    level: createLevel(config),
    ls: createLs2(config),
    tail: createTail(config)
  };
}

// node_modules/ipfs-http-client/src/name/publish.js
var createPublish = configure((api) => {
  async function publish(path, options = {}) {
    const res = await api.post("name/publish", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: `${path}`,
        ...options
      }),
      headers: options.headers
    });
    return objectToCamel(await res.json());
  }
  return publish;
});

// node_modules/ipfs-http-client/src/name/resolve.js
var createResolve2 = configure((api) => {
  async function* resolve2(path, options = {}) {
    const res = await api.post("name/resolve", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path,
        stream: true,
        ...options
      }),
      headers: options.headers
    });
    for await (const result of res.ndjson()) {
      yield result.Path;
    }
  }
  return resolve2;
});

// node_modules/ipfs-http-client/src/name/pubsub/cancel.js
var createCancel = configure((api) => {
  async function cancel(name12, options = {}) {
    const res = await api.post("name/pubsub/cancel", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: name12,
        ...options
      }),
      headers: options.headers
    });
    return objectToCamel(await res.json());
  }
  return cancel;
});

// node_modules/ipfs-http-client/src/name/pubsub/state.js
var createState = configure((api) => {
  async function state(options = {}) {
    const res = await api.post("name/pubsub/state", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    return objectToCamel(await res.json());
  }
  return state;
});

// node_modules/ipfs-http-client/src/name/pubsub/subs.js
var createSubs = configure((api) => {
  async function subs(options = {}) {
    const res = await api.post("name/pubsub/subs", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    const data = await res.json();
    return data.Strings || [];
  }
  return subs;
});

// node_modules/ipfs-http-client/src/name/pubsub/index.js
function createPubsub(config) {
  return {
    cancel: createCancel(config),
    state: createState(config),
    subs: createSubs(config)
  };
}

// node_modules/ipfs-http-client/src/name/index.js
function createName(config) {
  return {
    publish: createPublish(config),
    resolve: createResolve2(config),
    pubsub: createPubsub(config)
  };
}

// node_modules/ipfs-http-client/src/object/data.js
var createData = configure((api) => {
  async function data(cid, options = {}) {
    const res = await api.post("object/data", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: `${cid instanceof Uint8Array ? CID5.decode(cid) : cid}`,
        ...options
      }),
      headers: options.headers
    });
    const data2 = await res.arrayBuffer();
    return new Uint8Array(data2, 0, data2.byteLength);
  }
  return data;
});

// node_modules/ipfs-http-client/src/object/get.js
var createGet5 = configure((api) => {
  async function get(cid, options = {}) {
    const res = await api.post("object/get", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: `${cid instanceof Uint8Array ? CID5.decode(cid) : cid}`,
        dataEncoding: "base64",
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return {
      Data: fromString5(data.Data, "base64pad"),
      Links: (data.Links || []).map((link) => ({
        Name: link.Name,
        Hash: CID5.parse(link.Hash),
        Tsize: link.Size
      }))
    };
  }
  return get;
});

// node_modules/ipfs-http-client/src/object/links.js
var createLinks = configure((api) => {
  async function links(cid, options = {}) {
    const res = await api.post("object/links", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: `${cid instanceof Uint8Array ? CID5.decode(cid) : cid}`,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return (data.Links || []).map((l) => ({
      Name: l.Name,
      Tsize: l.Size,
      Hash: CID5.parse(l.Hash)
    }));
  }
  return links;
});

// node_modules/ipfs-http-client/src/object/new.js
var createNew = configure((api) => {
  async function newObject(options = {}) {
    const res = await api.post("object/new", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: options.template,
        ...options
      }),
      headers: options.headers
    });
    const { Hash: Hash2 } = await res.json();
    return CID5.parse(Hash2);
  }
  return newObject;
});

// node_modules/ipfs-http-client/src/object/put.js
var createPut4 = (codecs3, options) => {
  const fn = configure((api) => {
    const dagPut = createPut2(codecs3, options);
    async function put(obj, options2 = {}) {
      return dagPut(obj, {
        ...options2,
        storeCodec: "dag-pb",
        hashAlg: "sha2-256",
        version: 1
      });
    }
    return put;
  });
  return fn(options);
};

// node_modules/ipfs-http-client/src/object/stat.js
var createStat4 = configure((api) => {
  async function stat(cid, options = {}) {
    const res = await api.post("object/stat", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: `${cid}`,
        ...options
      }),
      headers: options.headers
    });
    const output = await res.json();
    return {
      ...output,
      Hash: CID5.parse(output.Hash)
    };
  }
  return stat;
});

// node_modules/ipfs-http-client/src/object/patch/add-link.js
var createAddLink = configure((api) => {
  async function addLink(cid, dLink, options = {}) {
    const res = await api.post("object/patch/add-link", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: [
          `${cid}`,
          // @ts-expect-error loose types
          dLink.Name || dLink.name || "",
          // @ts-expect-error loose types
          (dLink.Hash || dLink.cid || "").toString() || null
        ],
        ...options
      }),
      headers: options.headers
    });
    const { Hash: Hash2 } = await res.json();
    return CID5.parse(Hash2);
  }
  return addLink;
});

// node_modules/ipfs-http-client/src/object/patch/append-data.js
var createAppendData = configure((api) => {
  async function appendData(cid, data, options = {}) {
    const controller = new AbortController();
    const signal = abortSignal(controller.signal, options.signal);
    const res = await api.post("object/patch/append-data", {
      signal,
      searchParams: toUrlSearchParams({
        arg: `${cid}`,
        ...options
      }),
      ...await multipartRequest([data], controller, options.headers)
    });
    const { Hash: Hash2 } = await res.json();
    return CID5.parse(Hash2);
  }
  return appendData;
});

// node_modules/ipfs-http-client/src/object/patch/rm-link.js
var createRmLink = configure((api) => {
  async function rmLink(cid, dLink, options = {}) {
    const res = await api.post("object/patch/rm-link", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: [
          `${cid}`,
          // @ts-expect-error loose types
          dLink.Name || dLink.name || null
        ],
        ...options
      }),
      headers: options.headers
    });
    const { Hash: Hash2 } = await res.json();
    return CID5.parse(Hash2);
  }
  return rmLink;
});

// node_modules/ipfs-http-client/src/object/patch/set-data.js
var createSetData = configure((api) => {
  async function setData(cid, data, options = {}) {
    const controller = new AbortController();
    const signal = abortSignal(controller.signal, options.signal);
    const res = await api.post("object/patch/set-data", {
      signal,
      searchParams: toUrlSearchParams({
        arg: [
          `${cid}`
        ],
        ...options
      }),
      ...await multipartRequest([data], controller, options.headers)
    });
    const { Hash: Hash2 } = await res.json();
    return CID5.parse(Hash2);
  }
  return setData;
});

// node_modules/ipfs-http-client/src/object/patch/index.js
function createPatch(config) {
  return {
    addLink: createAddLink(config),
    appendData: createAppendData(config),
    rmLink: createRmLink(config),
    setData: createSetData(config)
  };
}

// node_modules/ipfs-http-client/src/object/index.js
function createObject(codecs3, config) {
  return {
    data: createData(config),
    get: createGet5(config),
    links: createLinks(config),
    new: createNew(config),
    put: createPut4(codecs3, config),
    stat: createStat4(config),
    patch: createPatch(config)
  };
}

// node_modules/ipfs-core-utils/src/pins/normalise-input.js
var import_err_code10 = __toESM(require_err_code(), 1);

// node_modules/ipfs-core-utils/node_modules/multiformats/vendor/varint.js
var encode_110 = encode40;
var MSB11 = 128;
var REST11 = 127;
var MSBALL10 = ~REST11;
var INT10 = Math.pow(2, 31);
function encode40(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT10) {
    out[offset++] = num & 255 | MSB11;
    num /= 128;
  }
  while (num & MSBALL10) {
    out[offset++] = num & 255 | MSB11;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode40.bytes = offset - oldOffset + 1;
  return out;
}
var decode54 = read10;
var MSB$110 = 128;
var REST$110 = 127;
function read10(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
  do {
    if (counter >= l) {
      read10.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf2[counter++];
    res += shift < 28 ? (b & REST$110) << shift : (b & REST$110) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$110);
  read10.bytes = counter - offset;
  return res;
}
var N111 = Math.pow(2, 7);
var N211 = Math.pow(2, 14);
var N311 = Math.pow(2, 21);
var N411 = Math.pow(2, 28);
var N511 = Math.pow(2, 35);
var N611 = Math.pow(2, 42);
var N711 = Math.pow(2, 49);
var N810 = Math.pow(2, 56);
var N910 = Math.pow(2, 63);
var length10 = function(value) {
  return value < N111 ? 1 : value < N211 ? 2 : value < N311 ? 3 : value < N411 ? 4 : value < N511 ? 5 : value < N611 ? 6 : value < N711 ? 7 : value < N810 ? 8 : value < N910 ? 9 : 10;
};
var varint13 = {
  encode: encode_110,
  decode: decode54,
  encodingLength: length10
};
var _brrp_varint10 = varint13;
var varint_default10 = _brrp_varint10;

// node_modules/ipfs-core-utils/node_modules/multiformats/src/varint.js
var decode55 = (data, offset = 0) => {
  const code12 = varint_default10.decode(data, offset);
  return [code12, varint_default10.decode.bytes];
};
var encodeTo10 = (int, target, offset = 0) => {
  varint_default10.encode(int, target, offset);
  return target;
};
var encodingLength11 = (int) => {
  return varint_default10.encodingLength(int);
};

// node_modules/ipfs-core-utils/node_modules/multiformats/src/bytes.js
var empty11 = new Uint8Array(0);
var equals21 = (aa, bb) => {
  if (aa === bb) return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
};
var coerce11 = (o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array") return o;
  if (o instanceof ArrayBuffer) return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};

// node_modules/ipfs-core-utils/node_modules/multiformats/src/hashes/digest.js
var create10 = (code12, digest6) => {
  const size = digest6.byteLength;
  const sizeOffset = encodingLength11(code12);
  const digestOffset = sizeOffset + encodingLength11(size);
  const bytes = new Uint8Array(digestOffset + size);
  encodeTo10(code12, bytes, 0);
  encodeTo10(size, bytes, sizeOffset);
  bytes.set(digest6, digestOffset);
  return new Digest10(code12, size, digest6, bytes);
};
var decode56 = (multihash) => {
  const bytes = coerce11(multihash);
  const [code12, sizeOffset] = decode55(bytes);
  const [size, digestOffset] = decode55(bytes.subarray(sizeOffset));
  const digest6 = bytes.subarray(sizeOffset + digestOffset);
  if (digest6.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest10(code12, size, digest6, bytes);
};
var equals22 = (a, b) => {
  if (a === b) {
    return true;
  } else {
    const data = (
      /** @type {{code?:unknown, size?:unknown, bytes?:unknown}} */
      b
    );
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals21(a.bytes, data.bytes);
  }
};
var Digest10 = class {
  /**
   * Creates a multihash digest.
   *
   * @param {Code} code
   * @param {Size} size
   * @param {Uint8Array} digest
   * @param {Uint8Array} bytes
   */
  constructor(code12, size, digest6, bytes) {
    this.code = code12;
    this.size = size;
    this.digest = digest6;
    this.bytes = bytes;
  }
};

// node_modules/ipfs-core-utils/node_modules/multiformats/vendor/base-x.js
function base13(ALPHABET, name12) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode42(source) {
    if (source instanceof Uint8Array) ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length11 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length11) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length11 = i2;
      pbegin++;
    }
    var it2 = size - length11;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length11 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length11) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length11 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length11;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode58(string3) {
    var buffer2 = decodeUnsafe(string3);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name12} character`);
  }
  return {
    encode: encode42,
    decodeUnsafe,
    decode: decode58
  };
}
var src11 = base13;
var _brrp__multiformats_scope_baseX11 = src11;
var base_x_default11 = _brrp__multiformats_scope_baseX11;

// node_modules/ipfs-core-utils/node_modules/multiformats/src/bases/base.js
var Encoder11 = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   */
  constructor(name12, prefix, baseEncode) {
    this.name = name12;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {API.Multibase<Prefix>}
   */
  encode(bytes) {
    if (bytes instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder11 = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name12, prefix, baseDecode) {
    this.name = name12;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = /** @type {number} */
    prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  /**
   * @param {string} text
   */
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or11(this, decoder);
  }
};
var ComposedDecoder11 = class {
  /**
   * @param {Decoders<Prefix>} decoders
   */
  constructor(decoders3) {
    this.decoders = decoders3;
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or11(this, decoder);
  }
  /**
   * @param {string} input
   * @returns {Uint8Array}
   */
  decode(input) {
    const prefix = (
      /** @type {Prefix} */
      input[0]
    );
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or11 = (left, right) => new ComposedDecoder11(
  /** @type {Decoders<L|R>} */
  {
    ...left.decoders || { [
      /** @type API.UnibaseDecoder<L> */
      left.prefix
    ]: left },
    ...right.decoders || { [
      /** @type API.UnibaseDecoder<R> */
      right.prefix
    ]: right }
  }
);
var Codec11 = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name12, prefix, baseEncode, baseDecode) {
    this.name = name12;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder11(name12, prefix, baseEncode);
    this.decoder = new Decoder11(name12, prefix, baseDecode);
  }
  /**
   * @param {Uint8Array} input
   */
  encode(input) {
    return this.encoder.encode(input);
  }
  /**
   * @param {string} input
   */
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from16 = ({ name: name12, prefix, encode: encode42, decode: decode58 }) => new Codec11(name12, prefix, encode42, decode58);
var baseX11 = ({ prefix, name: name12, alphabet: alphabet7 }) => {
  const { encode: encode42, decode: decode58 } = base_x_default11(alphabet7, name12);
  return from16({
    prefix,
    name: name12,
    encode: encode42,
    /**
     * @param {string} text
     */
    decode: (text) => coerce11(decode58(text))
  });
};
var decode57 = (string3, alphabet7, bitsPerChar, name12) => {
  const codes2 = {};
  for (let i = 0; i < alphabet7.length; ++i) {
    codes2[alphabet7[i]] = i;
  }
  let end = string3.length;
  while (string3[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes2[string3[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name12} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer2 >> bits;
    }
  }
  if (bits >= bitsPerChar || 255 & buffer2 << 8 - bits) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
var encode41 = (data, alphabet7, bitsPerChar) => {
  const pad = alphabet7[alphabet7.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer2 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer2 = buffer2 << 8 | data[i];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet7[mask & buffer2 >> bits];
    }
  }
  if (bits) {
    out += alphabet7[mask & buffer2 << bitsPerChar - bits];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
var rfc464811 = ({ name: name12, prefix, bitsPerChar, alphabet: alphabet7 }) => {
  return from16({
    prefix,
    name: name12,
    encode(input) {
      return encode41(input, alphabet7, bitsPerChar);
    },
    decode(input) {
      return decode57(input, alphabet7, bitsPerChar, name12);
    }
  });
};

// node_modules/ipfs-core-utils/node_modules/multiformats/src/bases/base58.js
var base58btc11 = baseX11({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr11 = baseX11({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/ipfs-core-utils/node_modules/multiformats/src/bases/base32.js
var base3211 = rfc464811({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper11 = rfc464811({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad11 = rfc464811({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper11 = rfc464811({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex11 = rfc464811({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper11 = rfc464811({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad11 = rfc464811({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper11 = rfc464811({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z11 = rfc464811({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/ipfs-core-utils/node_modules/multiformats/src/cid.js
var format11 = (link, base14) => {
  const { bytes, version } = link;
  switch (version) {
    case 0:
      return toStringV010(
        bytes,
        baseCache10(link),
        /** @type {API.MultibaseEncoder<"z">} */
        base14 || base58btc11.encoder
      );
    default:
      return toStringV110(
        bytes,
        baseCache10(link),
        /** @type {API.MultibaseEncoder<Prefix>} */
        base14 || base3211.encoder
      );
  }
};
var cache10 = /* @__PURE__ */ new WeakMap();
var baseCache10 = (cid) => {
  const baseCache11 = cache10.get(cid);
  if (baseCache11 == null) {
    const baseCache12 = /* @__PURE__ */ new Map();
    cache10.set(cid, baseCache12);
    return baseCache12;
  }
  return baseCache11;
};
var CID10 = class _CID {
  /**
   * @param {Version} version - Version of the CID
   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.
   * @param {Uint8Array} bytes
   *
   */
  constructor(version, code12, multihash, bytes) {
    this.code = code12;
    this.version = version;
    this.multihash = multihash;
    this.bytes = bytes;
    this["/"] = bytes;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  /**
   * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}
   */
  toV0() {
    switch (this.version) {
      case 0: {
        return (
          /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
          this
        );
      }
      case 1: {
        const { code: code12, multihash } = this;
        if (code12 !== DAG_PB_CODE10) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE10) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return (
          /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
          _CID.createV0(
            /** @type {API.MultihashDigest<API.SHA_256>} */
            multihash
          )
        );
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 0. This is a bug please report`
        );
      }
    }
  }
  /**
   * @returns {CID<Data, Format, Alg, 1>}
   */
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code12, digest: digest6 } = this.multihash;
        const multihash = create10(code12, digest6);
        return (
          /** @type {CID<Data, Format, Alg, 1>} */
          _CID.createV1(this.code, multihash)
        );
      }
      case 1: {
        return (
          /** @type {CID<Data, Format, Alg, 1>} */
          this
        );
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 1. This is a bug please report`
        );
      }
    }
  }
  /**
   * @param {unknown} other
   * @returns {other is CID<Data, Format, Alg, Version>}
   */
  equals(other) {
    return _CID.equals(this, other);
  }
  /**
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @param {API.Link<Data, Format, Alg, Version>} self
   * @param {unknown} other
   * @returns {other is CID}
   */
  static equals(self2, other) {
    const unknown = (
      /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */
      other
    );
    return unknown && self2.code === unknown.code && self2.version === unknown.version && equals22(self2.multihash, unknown.multihash);
  }
  /**
   * @param {API.MultibaseEncoder<string>} [base]
   * @returns {string}
   */
  toString(base14) {
    return format11(this, base14);
  }
  toJSON() {
    return { "/": format11(this) };
  }
  link() {
    return this;
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   *
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @template {unknown} U
   * @param {API.Link<Data, Format, Alg, Version>|U} input
   * @returns {CID<Data, Format, Alg, Version>|null}
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value = (
      /** @type {any} */
      input
    );
    if (value instanceof _CID) {
      return value;
    } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
      const { version, code: code12, multihash, bytes } = value;
      return new _CID(
        version,
        code12,
        /** @type {API.MultihashDigest<Alg>} */
        multihash,
        bytes || encodeCID10(version, code12, multihash.bytes)
      );
    } else if (value[cidSymbol10] === true) {
      const { version, multihash, code: code12 } = value;
      const digest6 = (
        /** @type {API.MultihashDigest<Alg>} */
        decode56(multihash)
      );
      return _CID.create(version, code12, digest6);
    } else {
      return null;
    }
  }
  /**
   *
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @param {Version} version - Version of the CID
   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.
   * @returns {CID<Data, Format, Alg, Version>}
   */
  static create(version, code12, digest6) {
    if (typeof code12 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest6.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version) {
      case 0: {
        if (code12 !== DAG_PB_CODE10) {
          throw new Error(
            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE10}) block encoding`
          );
        } else {
          return new _CID(version, code12, digest6, digest6.bytes);
        }
      }
      case 1: {
        const bytes = encodeCID10(version, code12, digest6.bytes);
        return new _CID(version, code12, digest6, bytes);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   *
   * @template {unknown} [T=unknown]
   * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.
   * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}
   */
  static createV0(digest6) {
    return _CID.create(0, DAG_PB_CODE10, digest6);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @param {Code} code - Content encoding format code.
   * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.
   * @returns {CID<Data, Code, Alg, 1>}
   */
  static createV1(code12, digest6) {
    return _CID.create(1, code12, digest6);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   *
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @template {API.Version} Ver
   * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes
   * @returns {CID<Data, Code, Alg, Ver>}
   */
  static decode(bytes) {
    const [cid, remainder] = _CID.decodeFirst(bytes);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   *
   * @template {unknown} T
   * @template {number} C
   * @template {number} A
   * @template {API.Version} V
   * @param {API.ByteView<API.Link<T, C, A, V>>} bytes
   * @returns {[CID<T, C, A, V>, Uint8Array]}
   */
  static decodeFirst(bytes) {
    const specs = _CID.inspectBytes(bytes);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce11(
      bytes.subarray(prefixSize, prefixSize + specs.multihashSize)
    );
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(
      specs.multihashSize - specs.digestSize
    );
    const digest6 = new Digest10(
      specs.multihashCode,
      specs.digestSize,
      digestBytes,
      multihashBytes
    );
    const cid = specs.version === 0 ? _CID.createV0(
      /** @type {API.MultihashDigest<API.SHA_256>} */
      digest6
    ) : _CID.createV1(specs.codec, digest6);
    return [
      /** @type {CID<T, C, A, V>} */
      cid,
      bytes.subarray(specs.size)
    ];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   *
   * @template {unknown} T
   * @template {number} C
   * @template {number} A
   * @template {API.Version} V
   * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes
   * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i, length11] = decode55(initialBytes.subarray(offset));
      offset += length11;
      return i;
    };
    let version = (
      /** @type {V} */
      next()
    );
    let codec = (
      /** @type {C} */
      DAG_PB_CODE10
    );
    if (
      /** @type {number} */
      version === 18
    ) {
      version = /** @type {V} */
      0;
      offset = 0;
    } else {
      codec = /** @type {C} */
      next();
    }
    if (version !== 0 && version !== 1) {
      throw new RangeError(`Invalid CID version ${version}`);
    }
    const prefixSize = offset;
    const multihashCode = (
      /** @type {A} */
      next()
    );
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   *
   * @template {string} Prefix
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @template {API.Version} Ver
   * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source
   * @param {API.MultibaseDecoder<Prefix>} [base]
   * @returns {CID<Data, Code, Alg, Ver>}
   */
  static parse(source, base14) {
    const [prefix, bytes] = parseCIDtoBytes10(source, base14);
    const cid = _CID.decode(bytes);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache10(cid).set(prefix, source);
    return cid;
  }
};
var parseCIDtoBytes10 = (source, base14) => {
  switch (source[0]) {
    // CIDv0 is parsed differently
    case "Q": {
      const decoder = base14 || base58btc11;
      return [
        /** @type {Prefix} */
        base58btc11.prefix,
        decoder.decode(`${base58btc11.prefix}${source}`)
      ];
    }
    case base58btc11.prefix: {
      const decoder = base14 || base58btc11;
      return [
        /** @type {Prefix} */
        base58btc11.prefix,
        decoder.decode(source)
      ];
    }
    case base3211.prefix: {
      const decoder = base14 || base3211;
      return [
        /** @type {Prefix} */
        base3211.prefix,
        decoder.decode(source)
      ];
    }
    default: {
      if (base14 == null) {
        throw Error(
          "To parse non base32 or base58btc encoded CID multibase decoder must be provided"
        );
      }
      return [
        /** @type {Prefix} */
        source[0],
        base14.decode(source)
      ];
    }
  }
};
var toStringV010 = (bytes, cache11, base14) => {
  const { prefix } = base14;
  if (prefix !== base58btc11.prefix) {
    throw Error(`Cannot string encode V0 in ${base14.name} encoding`);
  }
  const cid = cache11.get(prefix);
  if (cid == null) {
    const cid2 = base14.encode(bytes).slice(1);
    cache11.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var toStringV110 = (bytes, cache11, base14) => {
  const { prefix } = base14;
  const cid = cache11.get(prefix);
  if (cid == null) {
    const cid2 = base14.encode(bytes);
    cache11.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var DAG_PB_CODE10 = 112;
var SHA_256_CODE10 = 18;
var encodeCID10 = (version, code12, multihash) => {
  const codeOffset = encodingLength11(version);
  const hashOffset = codeOffset + encodingLength11(code12);
  const bytes = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo10(version, bytes, 0);
  encodeTo10(code12, bytes, codeOffset);
  bytes.set(multihash, hashOffset);
  return bytes;
};
var cidSymbol10 = Symbol.for("@ipld/js-cid/CID");

// node_modules/ipfs-core-utils/src/pins/normalise-input.js
function isIterable(thing) {
  return Symbol.iterator in thing;
}
function isAsyncIterable(thing) {
  return Symbol.asyncIterator in thing;
}
function isCID(thing) {
  return CID10.asCID(thing) != null;
}
async function* normaliseInput2(input) {
  if (input === null || input === void 0) {
    throw (0, import_err_code10.default)(new Error(`Unexpected input: ${input}`), "ERR_UNEXPECTED_INPUT");
  }
  const cid = CID10.asCID(input);
  if (cid) {
    yield toPin({ cid });
    return;
  }
  if (input instanceof String || typeof input === "string") {
    yield toPin({ path: input });
    return;
  }
  if (input.cid != null || input.path != null) {
    return yield toPin(input);
  }
  if (isIterable(input)) {
    const iterator = input[Symbol.iterator]();
    const first2 = iterator.next();
    if (first2.done) {
      return iterator;
    }
    if (isCID(first2.value)) {
      yield toPin({ cid: first2.value });
      for (const cid2 of iterator) {
        yield toPin({ cid: cid2 });
      }
      return;
    }
    if (first2.value instanceof String || typeof first2.value === "string") {
      yield toPin({ path: first2.value });
      for (const path of iterator) {
        yield toPin({ path });
      }
      return;
    }
    if (first2.value.cid != null || first2.value.path != null) {
      yield toPin(first2.value);
      for (const obj of iterator) {
        yield toPin(obj);
      }
      return;
    }
    throw (0, import_err_code10.default)(new Error("Unexpected input: " + typeof input), "ERR_UNEXPECTED_INPUT");
  }
  if (isAsyncIterable(input)) {
    const iterator = input[Symbol.asyncIterator]();
    const first2 = await iterator.next();
    if (first2.done) return iterator;
    if (isCID(first2.value)) {
      yield toPin({ cid: first2.value });
      for await (const cid2 of iterator) {
        yield toPin({ cid: cid2 });
      }
      return;
    }
    if (first2.value instanceof String || typeof first2.value === "string") {
      yield toPin({ path: first2.value });
      for await (const path of iterator) {
        yield toPin({ path });
      }
      return;
    }
    if (first2.value.cid != null || first2.value.path != null) {
      yield toPin(first2.value);
      for await (const obj of iterator) {
        yield toPin(obj);
      }
      return;
    }
    throw (0, import_err_code10.default)(new Error("Unexpected input: " + typeof input), "ERR_UNEXPECTED_INPUT");
  }
  throw (0, import_err_code10.default)(new Error("Unexpected input: " + typeof input), "ERR_UNEXPECTED_INPUT");
}
function toPin(input) {
  const path = input.cid || `${input.path}`;
  if (!path) {
    throw (0, import_err_code10.default)(new Error("Unexpected input: Please path either a CID or an IPFS path"), "ERR_UNEXPECTED_INPUT");
  }
  const pin = {
    path,
    recursive: input.recursive !== false
  };
  if (input.metadata != null) {
    pin.metadata = input.metadata;
  }
  return pin;
}

// node_modules/ipfs-http-client/src/pin/add-all.js
var createAddAll = configure((api) => {
  async function* addAll(source, options = {}) {
    for await (const { path, recursive, metadata } of normaliseInput2(source)) {
      const res = await api.post("pin/add", {
        signal: options.signal,
        searchParams: toUrlSearchParams({
          ...options,
          arg: path,
          recursive,
          metadata: metadata ? JSON.stringify(metadata) : void 0,
          stream: true
        }),
        headers: options.headers
      });
      for await (const pin of res.ndjson()) {
        if (pin.Pins) {
          for (const cid of pin.Pins) {
            yield CID5.parse(cid);
          }
          continue;
        }
        yield CID5.parse(pin);
      }
    }
  }
  return addAll;
});

// node_modules/ipfs-http-client/src/pin/add.js
function createAdd2(config) {
  const all2 = createAddAll(config);
  return configure(() => {
    async function add2(path, options = {}) {
      return last(all2([{
        path,
        ...options
      }], options));
    }
    return add2;
  })(config);
}

// node_modules/ipfs-http-client/src/pin/ls.js
function toPin2(type, cid, metadata) {
  const pin = {
    type,
    cid: CID5.parse(cid)
  };
  if (metadata) {
    pin.metadata = metadata;
  }
  return pin;
}
var createLs3 = configure((api) => {
  async function* ls(options = {}) {
    let paths = [];
    if (options.paths) {
      paths = Array.isArray(options.paths) ? options.paths : [options.paths];
    }
    const res = await api.post("pin/ls", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        ...options,
        arg: paths.map((path) => `${path}`),
        stream: true
      }),
      headers: options.headers
    });
    for await (const pin of res.ndjson()) {
      if (pin.Keys) {
        for (const cid of Object.keys(pin.Keys)) {
          yield toPin2(pin.Keys[cid].Type, cid, pin.Keys[cid].Metadata);
        }
        return;
      }
      yield toPin2(pin.Type, pin.Cid, pin.Metadata);
    }
  }
  return ls;
});

// node_modules/ipfs-http-client/src/pin/rm-all.js
var createRmAll = configure((api) => {
  async function* rmAll(source, options = {}) {
    for await (const { path, recursive } of normaliseInput2(source)) {
      const searchParams = new URLSearchParams(options.searchParams);
      searchParams.append("arg", `${path}`);
      if (recursive != null) searchParams.set("recursive", String(recursive));
      const res = await api.post("pin/rm", {
        signal: options.signal,
        headers: options.headers,
        searchParams: toUrlSearchParams({
          ...options,
          arg: `${path}`,
          recursive
        })
      });
      for await (const pin of res.ndjson()) {
        if (pin.Pins) {
          yield* pin.Pins.map((cid) => CID5.parse(cid));
          continue;
        }
        yield CID5.parse(pin);
      }
    }
  }
  return rmAll;
});

// node_modules/ipfs-http-client/src/pin/rm.js
var createRm5 = (config) => {
  const all2 = createRmAll(config);
  return configure(() => {
    async function rm(path, options = {}) {
      return last(all2([{
        path,
        ...options
      }], options));
    }
    return rm;
  })(config);
};

// node_modules/ipfs-http-client/src/pin/remote/utils.js
var decodePin = ({ Name: name12, Status: status, Cid: cid }) => {
  return {
    cid: CID5.parse(cid),
    name: name12,
    status
  };
};
var encodeService = (service) => {
  if (typeof service === "string" && service !== "") {
    return service;
  } else {
    throw new TypeError("service name must be passed");
  }
};
var encodeCID11 = (cid) => {
  if (CID5.asCID(cid)) {
    return cid.toString();
  } else {
    throw new TypeError(`CID instance expected instead of ${typeof cid}`);
  }
};
var encodeQuery = ({ service, cid, name: name12, status, all: all2 }) => {
  const query = toUrlSearchParams({
    service: encodeService(service),
    name: name12,
    force: all2 ? true : void 0
  });
  if (cid) {
    for (const value of cid) {
      query.append("cid", encodeCID11(value));
    }
  }
  if (status) {
    for (const value of status) {
      query.append("status", value);
    }
  }
  return query;
};
var encodeAddParams = ({ cid, service, background, name: name12, origins }) => {
  const params = toUrlSearchParams({
    arg: encodeCID11(cid),
    service: encodeService(service),
    name: name12,
    background: background ? true : void 0
  });
  if (origins) {
    for (const origin of origins) {
      params.append("origin", origin.toString());
    }
  }
  return params;
};

// node_modules/ipfs-http-client/src/pin/remote/add.js
function createAdd3(client2) {
  async function add2(cid, { timeout, signal, headers, ...query }) {
    const response = await client2.post("pin/remote/add", {
      timeout,
      signal,
      headers,
      searchParams: encodeAddParams({ cid, ...query })
    });
    return decodePin(await response.json());
  }
  return add2;
}

// node_modules/ipfs-http-client/src/pin/remote/ls.js
function createLs4(client2) {
  async function* ls({ timeout, signal, headers, ...query }) {
    const response = await client2.post("pin/remote/ls", {
      timeout,
      signal,
      headers,
      searchParams: encodeQuery(query)
    });
    for await (const pin of response.ndjson()) {
      yield decodePin(pin);
    }
  }
  return ls;
}

// node_modules/ipfs-http-client/src/pin/remote/rm.js
function createRm6(client2) {
  async function rm({ timeout, signal, headers, ...query }) {
    await client2.post("pin/remote/rm", {
      timeout,
      signal,
      headers,
      searchParams: encodeQuery({
        ...query,
        all: false
      })
    });
  }
  return rm;
}

// node_modules/ipfs-http-client/src/pin/remote/rm-all.js
function createRmAll2(client2) {
  async function rmAll({ timeout, signal, headers, ...query }) {
    await client2.post("pin/remote/rm", {
      timeout,
      signal,
      headers,
      searchParams: encodeQuery({
        ...query,
        all: true
      })
    });
  }
  return rmAll;
}

// node_modules/ipfs-http-client/src/pin/remote/service/utils.js
function encodeEndpoint(url) {
  const href = String(url);
  if (href === "undefined") {
    throw Error("endpoint is required");
  }
  return href[href.length - 1] === "/" ? href.slice(0, -1) : href;
}
function decodeRemoteService(json) {
  return {
    service: json.Service,
    endpoint: new URL(json.ApiEndpoint),
    ...json.Stat && { stat: decodeStat(json.Stat) }
  };
}
function decodeStat(json) {
  switch (json.Status) {
    case "valid": {
      const { Pinning, Pinned, Queued, Failed } = json.PinCount;
      return {
        status: "valid",
        pinCount: {
          queued: Queued,
          pinning: Pinning,
          pinned: Pinned,
          failed: Failed
        }
      };
    }
    case "invalid": {
      return { status: "invalid" };
    }
    default: {
      return { status: json.Status };
    }
  }
}

// node_modules/ipfs-http-client/src/pin/remote/service/add.js
function createAdd4(client2) {
  async function add2(name12, options) {
    const { endpoint, key, headers, timeout, signal } = options;
    await client2.post("pin/remote/service/add", {
      timeout,
      signal,
      searchParams: toUrlSearchParams({
        arg: [name12, encodeEndpoint(endpoint), key]
      }),
      headers
    });
  }
  return add2;
}

// node_modules/ipfs-http-client/src/pin/remote/service/ls.js
function createLs5(client2) {
  async function ls(options = {}) {
    const { stat, headers, timeout, signal } = options;
    const response = await client2.post("pin/remote/service/ls", {
      timeout,
      signal,
      headers,
      searchParams: stat === true ? toUrlSearchParams({ stat }) : void 0
    });
    const { RemoteServices } = await response.json();
    return RemoteServices.map(decodeRemoteService);
  }
  return ls;
}

// node_modules/ipfs-http-client/src/pin/remote/service/rm.js
function createRm7(client2) {
  async function rm(name12, options = {}) {
    await client2.post("pin/remote/service/rm", {
      signal: options.signal,
      headers: options.headers,
      searchParams: toUrlSearchParams({
        arg: name12
      })
    });
  }
  return rm;
}

// node_modules/ipfs-http-client/src/pin/remote/service/index.js
function createService(config) {
  const client2 = new Client(config);
  return {
    add: createAdd4(client2),
    ls: createLs5(client2),
    rm: createRm7(client2)
  };
}

// node_modules/ipfs-http-client/src/pin/remote/index.js
function createRemote(config) {
  const client2 = new Client(config);
  return {
    add: createAdd3(client2),
    ls: createLs4(client2),
    rm: createRm6(client2),
    rmAll: createRmAll2(client2),
    service: createService(config)
  };
}

// node_modules/ipfs-http-client/src/pin/index.js
function createPin(config) {
  return {
    addAll: createAddAll(config),
    add: createAdd2(config),
    ls: createLs3(config),
    rmAll: createRmAll(config),
    rm: createRm5(config),
    remote: createRemote(config)
  };
}

// node_modules/ipfs-http-client/src/lib/http-rpc-wire-format.js
var rpcArrayToTextArray = (strings) => {
  if (Array.isArray(strings)) {
    return strings.map(rpcToText);
  }
  return strings;
};
var rpcToText = (mb) => toString4(rpcToBytes(mb));
var rpcToBytes = (mb) => base64url3.decode(mb);
var rpcToBigInt = (mb) => BigInt(`0x${toString4(base64url3.decode(mb), "base16")}`);
var textToUrlSafeRpc = (text) => base64url3.encode(fromString5(text));

// node_modules/ipfs-http-client/src/pubsub/ls.js
var createLs6 = configure((api) => {
  async function ls(options = {}) {
    const { Strings } = await (await api.post("pubsub/ls", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    })).json();
    return rpcArrayToTextArray(Strings) || [];
  }
  return ls;
});

// node_modules/ipfs-http-client/src/pubsub/peers.js
var createPeers = configure((api) => {
  async function peers(topic, options = {}) {
    const res = await api.post("pubsub/peers", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: textToUrlSafeRpc(topic),
        ...options
      }),
      headers: options.headers
    });
    const { Strings } = await res.json();
    return Strings || [];
  }
  return peers;
});

// node_modules/ipfs-http-client/src/pubsub/publish.js
var createPublish2 = configure((api) => {
  async function publish(topic, data, options = {}) {
    const searchParams = toUrlSearchParams({
      arg: textToUrlSafeRpc(topic),
      ...options
    });
    const controller = new AbortController();
    const signal = abortSignal(controller.signal, options.signal);
    const res = await api.post("pubsub/pub", {
      signal,
      searchParams,
      ...await multipartRequest([data], controller, options.headers)
    });
    await res.text();
  }
  return publish;
});

// node_modules/ipfs-http-client/src/pubsub/subscribe.js
var log2 = logger("ipfs-http-client:pubsub:subscribe");
var createSubscribe = (options, subsTracker) => {
  return configure((api) => {
    async function subscribe(topic, handler, options2 = {}) {
      options2.signal = subsTracker.subscribe(topic, handler, options2.signal);
      let done;
      let fail;
      const result = new Promise((resolve2, reject) => {
        done = resolve2;
        fail = reject;
      });
      const ffWorkaround = setTimeout(() => done(), 1e3);
      api.post("pubsub/sub", {
        signal: options2.signal,
        searchParams: toUrlSearchParams({
          arg: textToUrlSafeRpc(topic),
          ...options2
        }),
        headers: options2.headers
      }).catch((err) => {
        subsTracker.unsubscribe(topic, handler);
        fail(err);
      }).then((response) => {
        clearTimeout(ffWorkaround);
        if (!response) {
          return;
        }
        readMessages(response, {
          onMessage: (message) => {
            if (!handler) {
              return;
            }
            if (typeof handler === "function") {
              handler(message);
              return;
            }
            if (typeof handler.handleEvent === "function") {
              handler.handleEvent(message);
            }
          },
          onEnd: () => subsTracker.unsubscribe(topic, handler),
          onError: options2.onError
        });
        done();
      });
      return result;
    }
    return subscribe;
  })(options);
};
async function readMessages(response, { onMessage, onEnd, onError }) {
  onError = onError || log2;
  try {
    for await (const msg of response.ndjson()) {
      try {
        if (!msg.from) {
          continue;
        }
        if (msg.from != null && msg.seqno != null) {
          onMessage({
            type: "signed",
            from: peerIdFromString(msg.from),
            data: rpcToBytes(msg.data),
            sequenceNumber: rpcToBigInt(msg.seqno),
            topic: rpcToText(msg.topicIDs[0]),
            key: rpcToBytes(msg.key ?? "u"),
            signature: rpcToBytes(msg.signature ?? "u")
          });
        } else {
          onMessage({
            type: "unsigned",
            data: rpcToBytes(msg.data),
            topic: rpcToText(msg.topicIDs[0])
          });
        }
      } catch (err) {
        err.message = `Failed to parse pubsub message: ${err.message}`;
        onError(err, false, msg);
      }
    }
  } catch (err) {
    if (!isAbortError(err)) {
      onError(err, true);
    }
  } finally {
    onEnd();
  }
}
var isAbortError = (error) => {
  switch (error.type) {
    case "aborted":
      return true;
    // It is `abort` in Electron instead of `aborted`
    case "abort":
      return true;
    default:
      return error.name === "AbortError";
  }
};

// node_modules/ipfs-http-client/src/pubsub/unsubscribe.js
var createUnsubscribe = (options, subsTracker) => {
  async function unsubscribe(topic, handler) {
    subsTracker.unsubscribe(topic, handler);
  }
  return unsubscribe;
};

// node_modules/ipfs-http-client/src/pubsub/subscription-tracker.js
var SubscriptionTracker = class {
  constructor() {
    this._subs = /* @__PURE__ */ new Map();
  }
  /**
   * @param {string} topic
   * @param {MessageHandlerFn} handler
   * @param {AbortSignal} [signal]
   */
  subscribe(topic, handler, signal) {
    const topicSubs = this._subs.get(topic) || [];
    if (topicSubs.find((s) => s.handler === handler)) {
      throw new Error(`Already subscribed to ${topic} with this handler`);
    }
    const controller = new AbortController();
    this._subs.set(topic, [{ handler, controller }].concat(topicSubs));
    if (signal) {
      signal.addEventListener("abort", () => this.unsubscribe(topic, handler));
    }
    return controller.signal;
  }
  /**
   * @param {string} topic
   * @param {MessageHandlerFn} [handler]
   */
  unsubscribe(topic, handler) {
    const subs = this._subs.get(topic) || [];
    let unsubs;
    if (handler) {
      this._subs.set(topic, subs.filter((s) => s.handler !== handler));
      unsubs = subs.filter((s) => s.handler === handler);
    } else {
      this._subs.set(topic, []);
      unsubs = subs;
    }
    if (!(this._subs.get(topic) || []).length) {
      this._subs.delete(topic);
    }
    unsubs.forEach((s) => s.controller.abort());
  }
};

// node_modules/ipfs-http-client/src/pubsub/index.js
function createPubsub2(config) {
  const subscriptionTracker = new SubscriptionTracker();
  return {
    ls: createLs6(config),
    peers: createPeers(config),
    publish: createPublish2(config),
    subscribe: createSubscribe(config, subscriptionTracker),
    unsubscribe: createUnsubscribe(config, subscriptionTracker)
  };
}

// node_modules/ipfs-http-client/src/refs/local.js
var createLocal = configure((api) => {
  async function* refsLocal(options = {}) {
    const res = await api.post("refs/local", {
      signal: options.signal,
      transform: objectToCamel,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    yield* res.ndjson();
  }
  return refsLocal;
});

// node_modules/ipfs-http-client/src/refs/index.js
var createRefs = configure((api, opts) => {
  const refs = async function* (args, options = {}) {
    const argsArr = Array.isArray(args) ? args : [args];
    const res = await api.post("refs", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: argsArr.map((arg) => `${arg instanceof Uint8Array ? CID5.decode(arg) : arg}`),
        ...options
      }),
      headers: options.headers,
      transform: objectToCamel
    });
    yield* res.ndjson();
  };
  return Object.assign(refs, {
    local: createLocal(opts)
  });
});

// node_modules/ipfs-http-client/src/repo/gc.js
var createGc = configure((api) => {
  async function* gc(options = {}) {
    const res = await api.post("repo/gc", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers,
      transform: (res2) => {
        return {
          err: res2.Error ? new Error(res2.Error) : null,
          cid: (res2.Key || {})["/"] ? CID5.parse(res2.Key["/"]) : null
        };
      }
    });
    yield* res.ndjson();
  }
  return gc;
});

// node_modules/ipfs-http-client/src/repo/stat.js
var createStat5 = configure((api) => {
  async function stat(options = {}) {
    const res = await api.post("repo/stat", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    const data = await res.json();
    return {
      numObjects: BigInt(data.NumObjects),
      repoSize: BigInt(data.RepoSize),
      repoPath: data.RepoPath,
      version: data.Version,
      storageMax: BigInt(data.StorageMax)
    };
  }
  return stat;
});

// node_modules/ipfs-http-client/src/repo/version.js
var createVersion = configure((api) => {
  async function version(options = {}) {
    const res = await (await api.post("repo/version", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    })).json();
    return res.Version;
  }
  return version;
});

// node_modules/ipfs-http-client/src/repo/index.js
function createRepo(config) {
  return {
    gc: createGc(config),
    stat: createStat5(config),
    version: createVersion(config)
  };
}

// node_modules/ipfs-http-client/src/stats/bw.js
var createBw = configure((api) => {
  async function* bw(options = {}) {
    const res = await api.post("stats/bw", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers,
      transform: (stats) => ({
        totalIn: BigInt(stats.TotalIn),
        totalOut: BigInt(stats.TotalOut),
        rateIn: parseFloat(stats.RateIn),
        rateOut: parseFloat(stats.RateOut)
      })
    });
    yield* res.ndjson();
  }
  return bw;
});

// node_modules/ipfs-http-client/src/stats/index.js
function createStats(config) {
  return {
    bitswap: createStat(config),
    repo: createStat5(config),
    bw: createBw(config)
  };
}

// node_modules/ipfs-http-client/src/swarm/addrs.js
var createAddrs = configure((api) => {
  async function addrs(options = {}) {
    const res = await api.post("swarm/addrs", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    const { Addrs } = await res.json();
    return Object.keys(Addrs).map((id) => ({
      id: peerIdFromString(id),
      addrs: (Addrs[id] || []).map((a) => multiaddr(a))
    }));
  }
  return addrs;
});

// node_modules/ipfs-http-client/src/swarm/connect.js
var createConnect = configure((api) => {
  async function connect(addr, options = {}) {
    const res = await api.post("swarm/connect", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: addr,
        ...options
      }),
      headers: options.headers
    });
    const { Strings } = await res.json();
    return Strings || [];
  }
  return connect;
});

// node_modules/ipfs-http-client/src/swarm/disconnect.js
var createDisconnect = configure((api) => {
  async function disconnect(addr, options = {}) {
    const res = await api.post("swarm/disconnect", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: addr,
        ...options
      }),
      headers: options.headers
    });
    const { Strings } = await res.json();
    return Strings || [];
  }
  return disconnect;
});

// node_modules/ipfs-http-client/src/swarm/local-addrs.js
var createLocalAddrs = configure((api) => {
  async function localAddrs(options = {}) {
    const res = await api.post("swarm/addrs/local", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    const { Strings } = await res.json();
    return (Strings || []).map((a) => multiaddr(a));
  }
  return localAddrs;
});

// node_modules/ipfs-http-client/src/swarm/peers.js
var createPeers2 = configure((api) => {
  async function peers(options = {}) {
    const res = await api.post("swarm/peers", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    const { Peers } = await res.json();
    return (Peers || []).map((peer) => {
      return {
        addr: multiaddr(peer.Addr),
        peer: peerIdFromString(peer.Peer),
        muxer: peer.Muxer,
        latency: peer.Latency,
        streams: peer.Streams,
        direction: peer.Direction == null ? void 0 : peer.Direction === 0 ? "inbound" : "outbound"
      };
    });
  }
  return peers;
});

// node_modules/ipfs-http-client/src/swarm/index.js
function createSwarm(config) {
  return {
    addrs: createAddrs(config),
    connect: createConnect(config),
    disconnect: createDisconnect(config),
    localAddrs: createLocalAddrs(config),
    peers: createPeers2(config)
  };
}

// node_modules/ipfs-http-client/src/add-all.js
var createAddAll2 = configure((api) => {
  async function* addAll(source, options = {}) {
    const controller = new AbortController();
    const signal = abortSignal(controller.signal, options.signal);
    const { headers, body, total, parts } = await multipartRequest(source, controller, options.headers);
    const [progressFn, onUploadProgress] = typeof options.progress === "function" ? createProgressHandler(total, parts, options.progress) : [void 0, void 0];
    const res = await api.post("add", {
      searchParams: toUrlSearchParams({
        "stream-channels": true,
        ...options,
        progress: Boolean(progressFn)
      }),
      onUploadProgress,
      signal,
      headers,
      body
    });
    for await (let file of res.ndjson()) {
      file = objectToCamel(file);
      if (file.hash !== void 0) {
        yield toCoreInterface5(file);
      } else if (progressFn) {
        progressFn(file.bytes || 0, file.name);
      }
    }
  }
  return addAll;
});
var createProgressHandler = (total, parts, progress) => parts ? [void 0, createOnUploadProgress(total, parts, progress)] : [progress, void 0];
var createOnUploadProgress = (size, parts, progress) => {
  let index = 0;
  const count = parts.length;
  return ({ loaded, total }) => {
    const position = Math.floor(loaded / total * size);
    while (index < count) {
      const { start, end, name: name12 } = parts[index];
      if (position < end) {
        progress(position - start, name12);
        break;
      } else {
        progress(end - start, name12);
        index += 1;
      }
    }
  };
};
function toCoreInterface5({ name: name12, hash, size, mode, mtime, mtimeNsecs }) {
  const output = {
    path: name12,
    cid: CID5.parse(hash),
    size: parseInt(size)
  };
  if (mode != null) {
    output.mode = parseInt(mode, 8);
  }
  if (mtime != null) {
    output.mtime = {
      secs: mtime,
      nsecs: mtimeNsecs || 0
    };
  }
  return output;
}

// node_modules/ipfs-core-utils/src/files/normalise-content.js
var import_err_code11 = __toESM(require_err_code(), 1);

// node_modules/blob-to-it/dist/src/index.js
function blobToIt(blob) {
  if (typeof blob.stream === "function") {
    return browserReadableStreamToIt(blob.stream());
  }
  return browserReadableStreamToIt(new Response(blob).body);
}

// node_modules/ipfs-core-utils/src/files/normalise-content.js
async function* toAsyncIterable(thing) {
  yield thing;
}
async function normaliseContent2(input) {
  if (isBytes5(input)) {
    return toAsyncIterable(toBytes4(input));
  }
  if (typeof input === "string" || input instanceof String) {
    return toAsyncIterable(toBytes4(input.toString()));
  }
  if (isBlob(input)) {
    return blobToIt(input);
  }
  if (isReadableStream(input)) {
    input = browserReadableStreamToIt(input);
  }
  if (Symbol.iterator in input || Symbol.asyncIterator in input) {
    const peekable = peekableIterator(input);
    const { value, done } = await peekable.peek();
    if (done) {
      return toAsyncIterable(new Uint8Array(0));
    }
    peekable.push(value);
    if (Number.isInteger(value)) {
      return toAsyncIterable(Uint8Array.from(await all(peekable)));
    }
    if (isBytes5(value) || typeof value === "string" || value instanceof String) {
      return map(peekable, toBytes4);
    }
  }
  throw (0, import_err_code11.default)(new Error(`Unexpected input: ${input}`), "ERR_UNEXPECTED_INPUT");
}
function toBytes4(chunk) {
  if (chunk instanceof Uint8Array) {
    return chunk;
  }
  if (ArrayBuffer.isView(chunk)) {
    return new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength);
  }
  if (chunk instanceof ArrayBuffer) {
    return new Uint8Array(chunk);
  }
  if (Array.isArray(chunk)) {
    return Uint8Array.from(chunk);
  }
  return fromString5(chunk.toString());
}

// node_modules/ipfs-core-utils/src/files/normalise-candidate-single.js
var import_err_code12 = __toESM(require_err_code(), 1);
async function* normaliseCandidateSingle(input, normaliseContent3) {
  if (input === null || input === void 0) {
    throw (0, import_err_code12.default)(new Error(`Unexpected input: ${input}`), "ERR_UNEXPECTED_INPUT");
  }
  if (typeof input === "string" || input instanceof String) {
    yield toFileObject2(input.toString(), normaliseContent3);
    return;
  }
  if (isBytes5(input) || isBlob(input)) {
    yield toFileObject2(input, normaliseContent3);
    return;
  }
  if (isReadableStream(input)) {
    input = browserReadableStreamToIt(input);
  }
  if (Symbol.iterator in input || Symbol.asyncIterator in input) {
    const peekable = peekableIterator(input);
    const { value, done } = await peekable.peek();
    if (done) {
      yield { content: [] };
      return;
    }
    peekable.push(value);
    if (Number.isInteger(value) || isBytes5(value) || typeof value === "string" || value instanceof String) {
      yield toFileObject2(peekable, normaliseContent3);
      return;
    }
    throw (0, import_err_code12.default)(new Error("Unexpected input: multiple items passed - if you are using ipfs.add, please use ipfs.addAll instead"), "ERR_UNEXPECTED_INPUT");
  }
  if (isFileObject(input)) {
    yield toFileObject2(input, normaliseContent3);
    return;
  }
  throw (0, import_err_code12.default)(new Error('Unexpected input: cannot convert "' + typeof input + '" into ImportCandidate'), "ERR_UNEXPECTED_INPUT");
}
async function toFileObject2(input, normaliseContent3) {
  const { path, mode, mtime, content } = input;
  const file = {
    path: path || "",
    mode: parseMode(mode),
    mtime: parseMtime2(mtime)
  };
  if (content) {
    file.content = await normaliseContent3(content);
  } else if (!path) {
    file.content = await normaliseContent3(input);
  }
  return file;
}

// node_modules/ipfs-core-utils/src/files/normalise-input-single.js
function normaliseInput3(input) {
  return normaliseCandidateSingle(input, normaliseContent2);
}

// node_modules/ipfs-http-client/src/add.js
function createAdd5(options) {
  const all2 = createAddAll2(options);
  return configure(() => {
    async function add2(input, options2 = {}) {
      return await last(all2(normaliseInput3(input), options2));
    }
    return add2;
  })(options);
}

// node_modules/ipfs-http-client/src/cat.js
var createCat = configure((api) => {
  async function* cat(path, options = {}) {
    const res = await api.post("cat", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path.toString(),
        ...options
      }),
      headers: options.headers
    });
    yield* res.iterator();
  }
  return cat;
});

// node_modules/ipfs-http-client/src/commands.js
var createCommands = configure((api) => {
  const commands = async (options = {}) => {
    const res = await api.post("commands", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    return res.json();
  };
  return commands;
});

// node_modules/ipfs-http-client/src/dns.js
var createDns = configure((api) => {
  const dns = async (domain, options = {}) => {
    const res = await api.post("dns", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: domain,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return data.Path;
  };
  return dns;
});

// node_modules/ipfs-http-client/src/get-endpoint-config.js
var createGetEndpointConfig = configure((api) => {
  return () => {
    const url = new URL(api.opts.base || "");
    return {
      host: url.hostname,
      port: url.port,
      protocol: url.protocol,
      pathname: url.pathname,
      "api-path": url.pathname
    };
  };
});

// node_modules/ipfs-http-client/src/get.js
var createGet6 = configure((api) => {
  async function* get(path, options = {}) {
    const opts = {
      arg: `${path instanceof Uint8Array ? CID5.decode(path) : path}`,
      ...options
    };
    if (opts.compressionLevel) {
      opts["compression-level"] = opts.compressionLevel;
      delete opts.compressionLevel;
    }
    const res = await api.post("get", {
      signal: options.signal,
      searchParams: toUrlSearchParams(opts),
      headers: options.headers
    });
    yield* res.iterator();
  }
  return get;
});

// node_modules/ipfs-http-client/src/id.js
var createId = configure((api) => {
  async function id(options = {}) {
    const res = await api.post("id", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: options.peerId ? options.peerId.toString() : void 0,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    const output = {
      ...objectToCamel(data)
    };
    output.id = peerIdFromString(output.id);
    if (output.addresses) {
      output.addresses = output.addresses.map((ma) => multiaddr(ma));
    }
    return output;
  }
  return id;
});

// node_modules/ipfs-http-client/src/is-online.js
var createIsOnline = (options) => {
  const id = createId(options);
  async function isOnline(options2 = {}) {
    const res = await id(options2);
    return Boolean(res && res.addresses && res.addresses.length);
  }
  return isOnline;
};

// node_modules/ipfs-http-client/src/ls.js
var createLs7 = configure((api, opts) => {
  async function* ls(path, options = {}) {
    const pathStr = `${path instanceof Uint8Array ? CID5.decode(path) : path}`;
    async function mapLink(link) {
      let hash = link.Hash;
      if (hash.includes("/")) {
        const ipfsPath = hash.startsWith("/ipfs/") ? hash : `/ipfs/${hash}`;
        const stats = await createStat3(opts)(ipfsPath);
        hash = stats.cid;
      } else {
        hash = CID5.parse(hash);
      }
      const entry = {
        name: link.Name,
        path: pathStr + (link.Name ? `/${link.Name}` : ""),
        size: link.Size,
        cid: hash,
        type: typeOf(link)
      };
      if (link.Mode) {
        entry.mode = parseInt(link.Mode, 8);
      }
      if (link.Mtime !== void 0 && link.Mtime !== null) {
        entry.mtime = {
          secs: link.Mtime
        };
        if (link.MtimeNsecs !== void 0 && link.MtimeNsecs !== null) {
          entry.mtime.nsecs = link.MtimeNsecs;
        }
      }
      return entry;
    }
    const res = await api.post("ls", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: pathStr,
        ...options
      }),
      headers: options.headers
    });
    for await (let result of res.ndjson()) {
      result = result.Objects;
      if (!result) {
        throw new Error("expected .Objects in results");
      }
      result = result[0];
      if (!result) {
        throw new Error("expected one array in results.Objects");
      }
      const links = result.Links;
      if (!Array.isArray(links)) {
        throw new Error("expected one array in results.Objects[0].Links");
      }
      if (!links.length) {
        yield mapLink(result);
        return;
      }
      yield* links.map(mapLink);
    }
  }
  return ls;
});
function typeOf(link) {
  switch (link.Type) {
    case 1:
    case 5:
      return "dir";
    case 2:
      return "file";
    default:
      return "file";
  }
}

// node_modules/ipfs-http-client/src/mount.js
var createMount = configure((api) => {
  async function mount(options = {}) {
    const res = await api.post("dns", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    return objectToCamel(await res.json());
  }
  return mount;
});

// node_modules/ipfs-http-client/src/ping.js
var createPing = configure((api) => {
  async function* ping(peerId, options = {}) {
    const res = await api.post("ping", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: `${peerId}`,
        ...options
      }),
      headers: options.headers,
      transform: objectToCamel
    });
    yield* res.ndjson();
  }
  return ping;
});

// node_modules/ipfs-http-client/src/resolve.js
var createResolve3 = configure((api) => {
  async function resolve2(path, options = {}) {
    const res = await api.post("resolve", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path,
        ...options
      }),
      headers: options.headers
    });
    const { Path } = await res.json();
    return Path;
  }
  return resolve2;
});

// node_modules/ipfs-http-client/src/start.js
var import_err_code13 = __toESM(require_err_code(), 1);
var createStart = configure((api) => {
  const start = async (options = {}) => {
    throw (0, import_err_code13.default)(new Error("Not implemented"), "ERR_NOT_IMPLEMENTED");
  };
  return start;
});

// node_modules/ipfs-http-client/src/stop.js
var createStop = configure((api) => {
  async function stop(options = {}) {
    const res = await api.post("shutdown", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    await res.text();
  }
  return stop;
});

// node_modules/ipfs-http-client/src/version.js
var createVersion2 = configure((api) => {
  async function version(options = {}) {
    const res = await api.post("version", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    return {
      ...objectToCamel(await res.json()),
      "ipfs-http-client": "1.0.0"
    };
  }
  return version;
});

// node_modules/ipfs-http-client/src/index.js
var import_url_source = __toESM(require_url_source(), 1);
function create11(options = {}) {
  const id = {
    name: identity.name,
    code: identity.code,
    encode: (id2) => id2,
    decode: (id2) => id2
  };
  const multibaseCodecs = Object.values(bases);
  (options.ipld && options.ipld.bases ? options.ipld.bases : []).forEach((base14) => multibaseCodecs.push(base14));
  const multibases = new Multibases({
    bases: multibaseCodecs,
    loadBase: options.ipld && options.ipld.loadBase
  });
  const blockCodecs = Object.values(codecs);
  [src_exports, src_exports2, src_exports3, lib_exports, id].concat(options.ipld && options.ipld.codecs || []).forEach((codec) => blockCodecs.push(codec));
  const multicodecs = new Multicodecs({
    codecs: blockCodecs,
    loadCodec: options.ipld && options.ipld.loadCodec
  });
  const multihashHashers = Object.values(hashes);
  (options.ipld && options.ipld.hashers ? options.ipld.hashers : []).forEach((hasher) => multihashHashers.push(hasher));
  const multihashes = new Multihashes({
    hashers: multihashHashers,
    loadHasher: options.ipld && options.ipld.loadHasher
  });
  const client2 = {
    add: createAdd5(options),
    addAll: createAddAll2(options),
    bitswap: createBitswap(options),
    block: createBlock(options),
    bootstrap: createBootstrap(options),
    cat: createCat(options),
    commands: createCommands(options),
    config: createConfig(options),
    dag: createDag(multicodecs, options),
    dht: createDht(options),
    diag: createDiag(options),
    dns: createDns(options),
    files: createFiles(options),
    get: createGet6(options),
    getEndpointConfig: createGetEndpointConfig(options),
    id: createId(options),
    isOnline: createIsOnline(options),
    key: createKey(options),
    log: createLog(options),
    ls: createLs7(options),
    mount: createMount(options),
    name: createName(options),
    object: createObject(multicodecs, options),
    pin: createPin(options),
    ping: createPing(options),
    pubsub: createPubsub2(options),
    refs: createRefs(options),
    repo: createRepo(options),
    resolve: createResolve3(options),
    start: createStart(options),
    stats: createStats(options),
    stop: createStop(options),
    swarm: createSwarm(options),
    version: createVersion2(options),
    bases: multibases,
    codecs: multicodecs,
    hashers: multihashes
  };
  return client2;
}

// src/services/ipfs.ts
var import_buffer = __toESM(require_buffer2());
var client = create11();
async function uploadToIPFS(data) {
  const { cid } = await client.add(data);
  return cid;
}
async function downloadFromIPFS(cid) {
  const response = await fetch(`https://ipfs.io/ipfs/${cid}`);
  if (!response.ok) {
    throw new Error(`Failed to fetch from IPFS gateway: ${response.statusText}`);
  }
  const arrayBuffer = await response.arrayBuffer();
  return import_buffer.Buffer.from(arrayBuffer);
}

// src/ui/app.ts
document.getElementById("createWallet").addEventListener("click", async () => {
  const wallet = createWallet();
  const walletInfo = document.getElementById("walletInfo");
  walletInfo.innerHTML = `
    <p><strong>Mnemonic:</strong> ${wallet.mnemonic}</p>
    <p><strong>Private Key:</strong> ${wallet.privateKey}</p>
    <p><strong>Address:</strong> ${wallet.address}</p>
    <p><strong>IPFS CID:</strong> Uploading...</p>
  `;
  try {
    const walletJson = JSON.stringify(wallet);
    const cid = await uploadToIPFS(walletJson);
    walletInfo.innerHTML += `<p><strong>IPFS CID:</strong> ${cid.toString()}</p>`;
  } catch (error) {
    walletInfo.innerHTML += `<p><strong>IPFS CID:</strong> Upload failed. (No local IPFS node found)</p>`;
  }
});
document.getElementById("loadWallet").addEventListener("click", async () => {
  const cid = document.getElementById("cidInput").value;
  const walletInfo = document.getElementById("walletInfo");
  try {
    const walletJson = await downloadFromIPFS(cid);
    const wallet = JSON.parse(walletJson.toString());
    walletInfo.innerHTML = `
      <p><strong>Mnemonic:</strong> ${wallet.mnemonic}</p>
      <p><strong>Private Key:</strong> ${wallet.privateKey}</p>
      <p><strong>Address:</strong> ${wallet.address}</p>
    `;
  } catch (error) {
    walletInfo.innerHTML = `<p>Failed to load wallet from IPFS. Please check the CID and your connection.</p>`;
  }
});
/*! Bundled license information:

@noble/hashes/utils.js:
@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

js-md5/src/md5.js:
  (**
   * [js-md5]{@link https://github.com/emn178/js-md5}
   *
   * @namespace md5
   * @version 0.8.3
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2014-2023
   * @license MIT
   *)

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

@scure/base/lib/esm/index.js:
  (*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/bip39/esm/index.js:
  (*! scure-bip39 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/utils.js:
@noble/curves/esm/abstract/modular.js:
@noble/curves/esm/abstract/curve.js:
@noble/curves/esm/abstract/weierstrass.js:
@noble/curves/esm/_shortw_utils.js:
@noble/curves/esm/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/ciphers/esm/utils.js:
  (*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) *)
*/
